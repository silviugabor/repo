@startuml
abstract class io.reactivex.Completable {
 + {static} Completable ambArray(final CompletableSource... sources) 
+ {static} Completable amb(final Iterable<? extends CompletableSource> sources) 
+ {static} Completable complete() 
+ {static} Completable concatArray(CompletableSource... sources) 
+ {static} Completable concat(Iterable<? extends CompletableSource> sources) 
+ {static} Completable concat(Publisher<? extends CompletableSource> sources) 
+ {static} Completable concat(Publisher<? extends CompletableSource> sources, int prefetch) 
+ void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Completable create(CompletableOnSubscribe source) 
+ {static} Completable unsafeCreate(CompletableSource source) 
+ {static} Completable defer(final Callable<? extends CompletableSource> completableSupplier) 
+ {static} Completable error(final Callable<? extends Throwable> errorSupplier) 
+ {static} Completable error(final Throwable error) 
+ {static} Completable fromAction(final Action run) 
+ {static} Completable fromCallable(final Callable<?> callable) 
+ {static} Completable fromFuture(final Future<?> future) 
+ {static} Completable fromRunnable(final Runnable run) 
+ {static} Completable mergeArray(CompletableSource... sources) 
+ {static} Completable merge(Iterable<? extends CompletableSource> sources) 
+ {static} Completable merge(Publisher<? extends CompletableSource> sources) 
+ {static} Completable merge(Publisher<? extends CompletableSource> sources, int maxConcurrency) 
- {static} Completable merge0(Publisher<? extends CompletableSource> sources, int maxConcurrency, boolean delayErrors) 
+ {static} Completable mergeArrayDelayError(CompletableSource... sources) 
+ {static} Completable mergeDelayError(Iterable<? extends CompletableSource> sources) 
+ {static} Completable mergeDelayError(Publisher<? extends CompletableSource> sources) 
+ {static} Completable mergeDelayError(Publisher<? extends CompletableSource> sources, int maxConcurrency) 
+ {static} Completable never() 
+ {static} Completable timer(long delay, TimeUnit unit) 
+ {static} Completable timer(final long delay, final TimeUnit unit, final Scheduler scheduler) 
- {static} NullPointerException toNpe(Throwable ex) 
+ {static} Completable wrap(CompletableSource source) 
+ final Completable ambWith(CompletableSource other) 
+ final Completable andThen(CompletableSource next) 
+ final void blockingAwait() 
+ final boolean blockingAwait(long timeout, TimeUnit unit) 
+ final Throwable blockingGet() 
+ final Throwable blockingGet(long timeout, TimeUnit unit) 
+ final Completable cache() 
+ final Completable compose(CompletableTransformer transformer) 
+ final Completable concatWith(CompletableSource other) 
+ final Completable delay(long delay, TimeUnit unit) 
+ final Completable delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Completable delay(final long delay, final TimeUnit unit, final Scheduler scheduler, final boolean delayError) 
+ final Completable doOnComplete(Action onComplete) 
+ final Completable doOnDispose(Action onDispose) 
+ final Completable doOnError(Consumer<? super Throwable> onError) 
+ final Completable doOnEvent(final Consumer<? super Throwable> onEvent) 
- Completable doOnLifecycle(
            final Consumer<? super Disposable> onSubscribe,
            final Consumer<? super Throwable> onError,
            final Action onComplete,
            final Action onTerminate,
            final Action onAfterTerminate,
            final Action onDispose) 
+ final Completable doOnSubscribe(Consumer<? super Disposable> onSubscribe) 
+ final Completable doOnTerminate(final Action onTerminate) 
+ final Completable doAfterTerminate(final Action onAfterTerminate) 
+ final Completable doFinally(Action onFinally) 
+ final Completable lift(final CompletableOperator onLift) 
+ final Completable mergeWith(CompletableSource other) 
+ final Completable observeOn(final Scheduler scheduler) 
+ final Completable onErrorComplete() 
+ final Completable onErrorComplete(final Predicate<? super Throwable> predicate) 
+ final Completable onErrorResumeNext(final Function<? super Throwable, ? extends CompletableSource> errorMapper) 
+ final Completable repeat() 
+ final Completable repeat(long times) 
+ final Completable repeatUntil(BooleanSupplier stop) 
+ final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final Completable retry() 
+ final Completable retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Completable retry(long times) 
+ final Completable retry(Predicate<? super Throwable> predicate) 
+ final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final Completable startWith(CompletableSource other) 
+ final Completable hide() 
+ final Disposable subscribe() 
+ final void subscribe(CompletableObserver s) 
# {abstract} void subscribeActual(CompletableObserver s)
+ final Disposable subscribe(final Action onComplete, final Consumer<? super Throwable> onError) 
+ final Disposable subscribe(final Action onComplete) 
+ final Completable subscribeOn(final Scheduler scheduler) 
+ final Completable timeout(long timeout, TimeUnit unit) 
+ final Completable timeout(long timeout, TimeUnit unit, CompletableSource other) 
+ final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) 
- Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) 
+ final Completable unsubscribeOn(final Scheduler scheduler) 
+ final TestObserver<Void> test() 
+ final TestObserver<Void> test(boolean cancelled) 
 
}
abstract class io.reactivex.Flowable {
 + {static} int bufferSize() 
+ void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) 
+ {static} Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Flowable<Long> interval(long period, TimeUnit unit) 
+ {static} Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) 
+ {static} Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Flowable<Integer> range(int start, int count) 
+ {static} Flowable<Long> rangeLong(long start, long count) 
+ {static} Flowable<Long> timer(long delay, TimeUnit unit) 
+ {static} Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Single<Boolean> all(Predicate<? super T> predicate) 
+ final Flowable<T> ambWith(Publisher<? extends T> other) 
+ final Single<Boolean> any(Predicate<? super T> predicate) 
+ final T blockingFirst() 
+ final T blockingFirst(T defaultItem) 
+ final void blockingForEach(Consumer<? super T> onNext) 
+ final Iterable<T> blockingIterable() 
+ final Iterable<T> blockingIterable(int bufferSize) 
+ final T blockingLast() 
+ final T blockingLast(T defaultItem) 
+ final Iterable<T> blockingLatest() 
+ final Iterable<T> blockingMostRecent(T initialItem) 
+ final Iterable<T> blockingNext() 
+ final T blockingSingle() 
+ final T blockingSingle(T defaultItem) 
+ final Future<T> toFuture() 
+ final void blockingSubscribe() 
+ final void blockingSubscribe(Consumer<? super T> onNext) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) 
+ final void blockingSubscribe(Subscriber<? super T> subscriber) 
+ final Flowable<List<T>> buffer(int count) 
+ final Flowable<List<T>> buffer(int count, int skip) 
+ final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) 
+ final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> cache() 
+ final Flowable<T> cacheWithInitialCapacity(int initialCapacity) 
+ final Flowable<T> concatWith(Publisher<? extends T> other) 
+ final Single<Boolean> contains(final Object item) 
+ final Single<Long> count() 
+ final Flowable<T> debounce(long timeout, TimeUnit unit) 
+ final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> defaultIfEmpty(T defaultItem) 
+ final Flowable<T> delay(long delay, TimeUnit unit) 
+ final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) 
+ final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Flowable<T> delaySubscription(long delay, TimeUnit unit) 
+ final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> distinct() 
+ final Flowable<T> distinctUntilChanged() 
+ final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) 
+ final Flowable<T> doFinally(Action onFinally) 
+ final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) 
+ final Flowable<T> doAfterTerminate(Action onAfterTerminate) 
+ final Flowable<T> doOnCancel(Action onCancel) 
+ final Flowable<T> doOnComplete(Action onComplete) 
- Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete, Action onAfterTerminate) 
+ final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) 
+ final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) 
+ final Flowable<T> doOnError(Consumer<? super Throwable> onError) 
+ final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe,
            final LongConsumer onRequest, final Action onCancel) 
+ final Flowable<T> doOnNext(Consumer<? super T> onNext) 
+ final Flowable<T> doOnRequest(LongConsumer onRequest) 
+ final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) 
+ final Flowable<T> doOnTerminate(final Action onTerminate) 
+ final Maybe<T> elementAt(long index) 
+ final Single<T> elementAt(long index, T defaultItem) 
+ final Single<T> elementAtOrError(long index) 
+ final Flowable<T> filter(Predicate<? super T> predicate) 
+ final Maybe<T> firstElement() 
+ final Single<T> first(T defaultItem) 
+ final Single<T> firstOrError() 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors, int maxConcurrency) 
+ final Disposable forEach(Consumer<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,
            final Action onComplete) 
+ final Flowable<T> hide() 
+ final Completable ignoreElements() 
+ final Single<Boolean> isEmpty() 
+ final Maybe<T> lastElement() 
+ final Single<T> last(T defaultItem) 
+ final Single<T> lastOrError() 
+ final Flowable<Notification<T>> materialize() 
+ final Flowable<T> mergeWith(Publisher<? extends T> other) 
+ final Flowable<T> observeOn(Scheduler scheduler) 
+ final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) 
+ final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> onBackpressureBuffer() 
+ final Flowable<T> onBackpressureBuffer(boolean delayError) 
+ final Flowable<T> onBackpressureBuffer(int capacity) 
+ final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) 
+ final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) 
+ final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,
            Action onOverflow) 
+ final Flowable<T> onBackpressureBuffer(int capacity, Action onOverflow) 
+ final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) 
+ final Flowable<T> onBackpressureDrop() 
+ final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) 
+ final Flowable<T> onBackpressureLatest() 
+ final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) 
+ final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) 
+ final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) 
+ final Flowable<T> onErrorReturnItem(final T item) 
+ final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) 
+ final Flowable<T> onTerminateDetach() 
+ final ParallelFlowable<T> parallel() 
+ final ParallelFlowable<T> parallel(int parallelism) 
+ final ParallelFlowable<T> parallel(int parallelism, int prefetch) 
+ final ConnectableFlowable<T> publish() 
+ final ConnectableFlowable<T> publish(int bufferSize) 
+ final Flowable<T> rebatchRequests(int n) 
+ final Maybe<T> reduce(BiFunction<T, T, T> reducer) 
+ final Flowable<T> repeat() 
+ final Flowable<T> repeat(long times) 
+ final Flowable<T> repeatUntil(BooleanSupplier stop) 
+ final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final ConnectableFlowable<T> replay() 
+ final ConnectableFlowable<T> replay(final int bufferSize) 
+ final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) 
+ final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) 
+ final ConnectableFlowable<T> replay(long time, TimeUnit unit) 
+ final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableFlowable<T> replay(final Scheduler scheduler) 
+ final Flowable<T> retry() 
+ final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Flowable<T> retry(long count) 
+ final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) 
+ final Flowable<T> retry(Predicate<? super Throwable> predicate) 
+ final Flowable<T> retryUntil(final BooleanSupplier stop) 
+ final Flowable<T> retryWhen(
            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final void safeSubscribe(Subscriber<? super T> s) 
+ final Flowable<T> sample(long period, TimeUnit unit) 
+ final Flowable<T> sample(long period, TimeUnit unit, boolean emitLast) 
+ final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) 
+ final Flowable<T> scan(BiFunction<T, T, T> accumulator) 
+ final Flowable<T> serialize() 
+ final Flowable<T> share() 
+ final Maybe<T> singleElement() 
+ final Single<T> single(T defaultItem) 
+ final Single<T> singleOrError() 
+ final Flowable<T> skip(long count) 
+ final Flowable<T> skip(long time, TimeUnit unit) 
+ final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> skipLast(int count) 
+ final Flowable<T> skipLast(long time, TimeUnit unit) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> skipWhile(Predicate<? super T> predicate) 
+ final Flowable<T> sorted() 
+ final Flowable<T> sorted(Comparator<? super T> sortFunction) 
+ final Flowable<T> startWith(Iterable<? extends T> items) 
+ final Flowable<T> startWith(Publisher<? extends T> other) 
+ final Flowable<T> startWith(T value) 
+ final Flowable<T> startWithArray(T... items) 
+ final Disposable subscribe() 
+ final Disposable subscribe(Consumer<? super T> onNext) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete, Consumer<? super Subscription> onSubscribe) 
+ final void subscribe(Subscriber<? super T> s) 
+ final void subscribe(FlowableSubscriber<? super T> s) 
# {abstract} void subscribeActual(Subscriber<? super T> s)
+ final Flowable<T> subscribeOn(Scheduler scheduler) 
+ final Flowable<T> switchIfEmpty(Publisher<? extends T> other) 
+ final Flowable<T> take(long count) 
+ final Flowable<T> take(long time, TimeUnit unit) 
+ final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> takeLast(int count) 
+ final Flowable<T> takeLast(long count, long time, TimeUnit unit) 
+ final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> takeLast(long time, TimeUnit unit) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) 
+ final Flowable<T> takeWhile(Predicate<? super T> predicate) 
+ final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) 
+ final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) 
+ final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) 
+ final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<Timed<T>> timeInterval() 
+ final Flowable<Timed<T>> timeInterval(Scheduler scheduler) 
+ final Flowable<Timed<T>> timeInterval(TimeUnit unit) 
+ final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Publisher<? extends T> other) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher<? extends T> other) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) 
- Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Publisher<? extends T> other,
            Scheduler scheduler) 
+ final Flowable<Timed<T>> timestamp() 
+ final Flowable<Timed<T>> timestamp(Scheduler scheduler) 
+ final Flowable<Timed<T>> timestamp(TimeUnit unit) 
+ final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) 
+ final Single<List<T>> toList() 
+ final Single<List<T>> toList(final int capacityHint) 
+ final Observable<T> toObservable() 
+ final Single<List<T>> toSortedList() 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator) 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) 
+ final Single<List<T>> toSortedList(int capacityHint) 
+ final Flowable<T> unsubscribeOn(Scheduler scheduler) 
+ final Flowable<Flowable<T>> window(long count) 
+ final Flowable<Flowable<T>> window(long count, long skip) 
+ final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) 
+ final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) 
+ final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            long count) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            long count, boolean restart) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count, boolean restart) 
+ final Flowable<Flowable<T>> window(
            long timespan, TimeUnit unit, Scheduler scheduler,
            long count, boolean restart, int bufferSize) 
+ final TestSubscriber<T> test() 
+ final TestSubscriber<T> test(long initialRequest) 
+ final TestSubscriber<T> test(long initialRequest, boolean cancel) 
~    {static} final int BUFFER_SIZE;
 
}
abstract class io.reactivex.InputWithIncrementingInteger {
 + void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ boolean hasNext() 
+ Integer next() 
+ void remove() 
+ Iterator<Integer> iterator() 
+ void subscribe(Subscriber<? super Integer> s) 
+ {abstract} int getSize()
+ PerfSubscriber newLatchedObserver() 
+ FlowableSubscriber<Integer> newSubscriber() 
        - final int size;
    + Iterable<Integer> iterable;
    + Flowable<Integer> observable;
    + Flowable<Integer> firehose;
    + Blackhole bh;
 
}
abstract class io.reactivex.Maybe {
 + void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Maybe<Long> timer(long delay, TimeUnit unit) 
+ {static} Maybe<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Maybe<T> ambWith(MaybeSource<? extends T> other) 
+ final T blockingGet() 
+ final T blockingGet(T defaultValue) 
+ final Maybe<T> cache() 
+ final Flowable<T> concatWith(MaybeSource<? extends T> other) 
+ final Single<Boolean> contains(final Object item) 
+ final Single<Long> count() 
+ final Maybe<T> defaultIfEmpty(T defaultItem) 
+ final Maybe<T> delay(long delay, TimeUnit unit) 
+ final Maybe<T> delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Maybe<T> delaySubscription(long delay, TimeUnit unit) 
+ final Maybe<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Maybe<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) 
+ final Maybe<T> doAfterTerminate(Action onAfterTerminate) 
+ final Maybe<T> doFinally(Action onFinally) 
+ final Maybe<T> doOnDispose(Action onDispose) 
+ final Maybe<T> doOnComplete(Action onComplete) 
+ final Maybe<T> doOnError(Consumer<? super Throwable> onError) 
+ final Maybe<T> doOnEvent(BiConsumer<? super T, ? super Throwable> onEvent) 
+ final Maybe<T> doOnSubscribe(Consumer<? super Disposable> onSubscribe) 
+ final Maybe<T> doOnSuccess(Consumer<? super T> onSuccess) 
+ final Maybe<T> filter(Predicate<? super T> predicate) 
+ final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) 
+ final Maybe<T> hide() 
+ final Completable ignoreElement() 
+ final Single<Boolean> isEmpty() 
+ final Flowable<T> mergeWith(MaybeSource<? extends T> other) 
+ final Maybe<T> observeOn(final Scheduler scheduler) 
+ final Flowable<T> toFlowable() 
+ final Observable<T> toObservable() 
+ final Single<T> toSingle(T defaultValue) 
+ final Single<T> toSingle() 
+ final Maybe<T> onErrorComplete() 
+ final Maybe<T> onErrorComplete(final Predicate<? super Throwable> predicate) 
+ final Maybe<T> onErrorResumeNext(final MaybeSource<? extends T> next) 
+ final Maybe<T> onErrorResumeNext(Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) 
+ final Maybe<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) 
+ final Maybe<T> onErrorReturnItem(final T item) 
+ final Maybe<T> onExceptionResumeNext(final MaybeSource<? extends T> next) 
+ final Maybe<T> onTerminateDetach() 
+ final Flowable<T> repeat() 
+ final Flowable<T> repeat(long times) 
+ final Flowable<T> repeatUntil(BooleanSupplier stop) 
+ final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final Maybe<T> retry() 
+ final Maybe<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Maybe<T> retry(long count) 
+ final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) 
+ final Maybe<T> retry(Predicate<? super Throwable> predicate) 
+ final Maybe<T> retryUntil(final BooleanSupplier stop) 
+ final Maybe<T> retryWhen(
            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final Disposable subscribe() 
+ final Disposable subscribe(Consumer<? super T> onSuccess) 
+ final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? super Throwable> onError) 
+ final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? super Throwable> onError,
            Action onComplete) 
+ final void subscribe(MaybeObserver<? super T> observer) 
# {abstract} void subscribeActual(MaybeObserver<? super T> observer)
+ final Maybe<T> subscribeOn(Scheduler scheduler) 
+ final Maybe<T> switchIfEmpty(MaybeSource<? extends T> other) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit, MaybeSource<? extends T> fallback) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, MaybeSource<? extends T> fallback) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) 
+ final Maybe<T> unsubscribeOn(final Scheduler scheduler) 
+ final TestObserver<T> test() 
+ final TestObserver<T> test(boolean cancelled) 
 
}
abstract class io.reactivex.Observable {
 + {static} int bufferSize() 
+ void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Observable<Long> interval(long initialDelay, long period, TimeUnit unit) 
+ {static} Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Observable<Long> interval(long period, TimeUnit unit) 
+ {static} Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) 
+ {static} Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Observable<Integer> range(final int start, final int count) 
+ {static} Observable<Long> rangeLong(long start, long count) 
+ {static} Observable<Long> timer(long delay, TimeUnit unit) 
+ {static} Observable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Single<Boolean> all(Predicate<? super T> predicate) 
+ final Observable<T> ambWith(ObservableSource<? extends T> other) 
+ final Single<Boolean> any(Predicate<? super T> predicate) 
+ final T blockingFirst() 
+ final T blockingFirst(T defaultItem) 
+ final void blockingForEach(Consumer<? super T> onNext) 
+ final Iterable<T> blockingIterable() 
+ final Iterable<T> blockingIterable(int bufferSize) 
+ final T blockingLast() 
+ final T blockingLast(T defaultItem) 
+ final Iterable<T> blockingLatest() 
+ final Iterable<T> blockingMostRecent(T initialValue) 
+ final Iterable<T> blockingNext() 
+ final T blockingSingle() 
+ final T blockingSingle(T defaultItem) 
+ final Future<T> toFuture() 
+ final void blockingSubscribe() 
+ final void blockingSubscribe(Consumer<? super T> onNext) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) 
+ final void blockingSubscribe(Observer<? super T> subscriber) 
+ final Observable<List<T>> buffer(int count) 
+ final Observable<List<T>> buffer(int count, int skip) 
+ final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) 
+ final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit, int count) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> cache() 
+ final Observable<T> cacheWithInitialCapacity(int initialCapacity) 
+ final Observable<T> concatWith(ObservableSource<? extends T> other) 
+ final Single<Boolean> contains(final Object element) 
+ final Single<Long> count() 
+ final Observable<T> debounce(long timeout, TimeUnit unit) 
+ final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> defaultIfEmpty(T defaultItem) 
+ final Observable<T> delay(long delay, TimeUnit unit) 
+ final Observable<T> delay(long delay, TimeUnit unit, boolean delayError) 
+ final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Observable<T> delaySubscription(long delay, TimeUnit unit) 
+ final Observable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> distinct() 
+ final Observable<T> distinctUntilChanged() 
+ final Observable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) 
+ final Observable<T> doAfterNext(Consumer<? super T> onAfterNext) 
+ final Observable<T> doAfterTerminate(Action onFinally) 
+ final Observable<T> doFinally(Action onFinally) 
+ final Observable<T> doOnDispose(Action onDispose) 
+ final Observable<T> doOnComplete(Action onComplete) 
- Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) 
+ final Observable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) 
+ final Observable<T> doOnEach(final Observer<? super T> observer) 
+ final Observable<T> doOnError(Consumer<? super Throwable> onError) 
+ final Observable<T> doOnLifecycle(final Consumer<? super Disposable> onSubscribe, final Action onDispose) 
+ final Observable<T> doOnNext(Consumer<? super T> onNext) 
+ final Observable<T> doOnSubscribe(Consumer<? super Disposable> onSubscribe) 
+ final Observable<T> doOnTerminate(final Action onTerminate) 
+ final Maybe<T> elementAt(long index) 
+ final Single<T> elementAt(long index, T defaultItem) 
+ final Single<T> elementAtOrError(long index) 
+ final Observable<T> filter(Predicate<? super T> predicate) 
+ final Maybe<T> firstElement() 
+ final Single<T> first(T defaultItem) 
+ final Single<T> firstOrError() 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors) 
+ final Disposable forEach(Consumer<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer<? super Throwable> onError,
            final Action onComplete) 
+ final Observable<T> hide() 
+ final Completable ignoreElements() 
+ final Single<Boolean> isEmpty() 
+ final Maybe<T> lastElement() 
+ final Single<T> last(T defaultItem) 
+ final Single<T> lastOrError() 
+ final Observable<Notification<T>> materialize() 
+ final Observable<T> mergeWith(ObservableSource<? extends T> other) 
+ final Observable<T> observeOn(Scheduler scheduler) 
+ final Observable<T> observeOn(Scheduler scheduler, boolean delayError) 
+ final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> onErrorResumeNext(Function<? super Throwable, ? extends ObservableSource<? extends T>> resumeFunction) 
+ final Observable<T> onErrorResumeNext(final ObservableSource<? extends T> next) 
+ final Observable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) 
+ final Observable<T> onErrorReturnItem(final T item) 
+ final Observable<T> onExceptionResumeNext(final ObservableSource<? extends T> next) 
+ final Observable<T> onTerminateDetach() 
+ final ConnectableObservable<T> publish() 
+ final Maybe<T> reduce(BiFunction<T, T, T> reducer) 
+ final Observable<T> repeat() 
+ final Observable<T> repeat(long times) 
+ final Observable<T> repeatUntil(BooleanSupplier stop) 
+ final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) 
+ final ConnectableObservable<T> replay() 
+ final ConnectableObservable<T> replay(final int bufferSize) 
+ final ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit) 
+ final ConnectableObservable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableObservable<T> replay(final int bufferSize, final Scheduler scheduler) 
+ final ConnectableObservable<T> replay(long time, TimeUnit unit) 
+ final ConnectableObservable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableObservable<T> replay(final Scheduler scheduler) 
+ final Observable<T> retry() 
+ final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Observable<T> retry(long times) 
+ final Observable<T> retry(long times, Predicate<? super Throwable> predicate) 
+ final Observable<T> retry(Predicate<? super Throwable> predicate) 
+ final Observable<T> retryUntil(final BooleanSupplier stop) 
+ final Observable<T> retryWhen(
            final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) 
+ final void safeSubscribe(Observer<? super T> s) 
+ final Observable<T> sample(long period, TimeUnit unit) 
+ final Observable<T> sample(long period, TimeUnit unit, boolean emitLast) 
+ final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) 
+ final Observable<T> scan(BiFunction<T, T, T> accumulator) 
+ final Observable<T> serialize() 
+ final Observable<T> share() 
+ final Maybe<T> singleElement() 
+ final Single<T> single(T defaultItem) 
+ final Single<T> singleOrError() 
+ final Observable<T> skip(long count) 
+ final Observable<T> skip(long time, TimeUnit unit) 
+ final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> skipLast(int count) 
+ final Observable<T> skipLast(long time, TimeUnit unit) 
+ final Observable<T> skipLast(long time, TimeUnit unit, boolean delayError) 
+ final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> skipWhile(Predicate<? super T> predicate) 
+ final Observable<T> sorted() 
+ final Observable<T> sorted(Comparator<? super T> sortFunction) 
+ final Observable<T> startWith(Iterable<? extends T> items) 
+ final Observable<T> startWith(ObservableSource<? extends T> other) 
+ final Observable<T> startWith(T item) 
+ final Observable<T> startWithArray(T... items) 
+ final Disposable subscribe() 
+ final Disposable subscribe(Consumer<? super T> onNext) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete, Consumer<? super Disposable> onSubscribe) 
+ final void subscribe(Observer<? super T> observer) 
# {abstract} void subscribeActual(Observer<? super T> observer)
+ final Observable<T> subscribeOn(Scheduler scheduler) 
+ final Observable<T> switchIfEmpty(ObservableSource<? extends T> other) 
+ final Observable<T> take(long count) 
+ final Observable<T> take(long time, TimeUnit unit) 
+ final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> takeLast(int count) 
+ final Observable<T> takeLast(long count, long time, TimeUnit unit) 
+ final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> takeLast(long time, TimeUnit unit) 
+ final Observable<T> takeLast(long time, TimeUnit unit, boolean delayError) 
+ final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> takeUntil(Predicate<? super T> stopPredicate) 
+ final Observable<T> takeWhile(Predicate<? super T> predicate) 
+ final Observable<T> throttleFirst(long windowDuration, TimeUnit unit) 
+ final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> throttleLast(long intervalDuration, TimeUnit unit) 
+ final Observable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) 
+ final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Observable<Timed<T>> timeInterval() 
+ final Observable<Timed<T>> timeInterval(Scheduler scheduler) 
+ final Observable<Timed<T>> timeInterval(TimeUnit unit) 
+ final Observable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, ObservableSource<? extends T> other) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) 
- Observable<T> timeout0(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other,
            Scheduler scheduler) 
+ final Observable<Timed<T>> timestamp() 
+ final Observable<Timed<T>> timestamp(Scheduler scheduler) 
+ final Observable<Timed<T>> timestamp(TimeUnit unit) 
+ final Observable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) 
+ final Single<List<T>> toList() 
+ final Single<List<T>> toList(final int capacityHint) 
+ final Flowable<T> toFlowable(BackpressureStrategy strategy) 
+ final Single<List<T>> toSortedList() 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator) 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) 
+ final Single<List<T>> toSortedList(int capacityHint) 
+ final Observable<T> unsubscribeOn(Scheduler scheduler) 
+ final Observable<Observable<T>> window(long count) 
+ final Observable<Observable<T>> window(long count, long skip) 
+ final Observable<Observable<T>> window(long count, long skip, int bufferSize) 
+ final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit) 
+ final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            long count) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            long count, boolean restart) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count, boolean restart) 
+ final Observable<Observable<T>> window(
            long timespan, TimeUnit unit, Scheduler scheduler,
            long count, boolean restart, int bufferSize) 
+ final TestObserver<T> test() 
+ final TestObserver<T> test(boolean dispose) 
 
}
abstract class io.reactivex.Scheduler {
 + {static} long clockDriftTolerance() 
+ {abstract} Worker createWorker()
+ void start() 
+ void shutdown() 
+ Disposable scheduleDirect(@NonNull Runnable run) 
+ Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) 
+ Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) 
+ Disposable schedule(@NonNull Runnable run) 
+ {abstract} Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit)
+ Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) 
+ long now(@NonNull TimeUnit unit) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
~    {static} final long CLOCK_DRIFT_TOLERANCE_NANOSECONDS;
~            final Runnable decoratedRun;
~            final SequentialDisposable sd;
~            final long periodInNanoseconds;
~        final Runnable run;
~        final Worker worker;
~        final Runnable decoratedRun;
~        final Worker w;
 
}
abstract class io.reactivex.Single {
 + void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Single<Long> timer(long delay, TimeUnit unit) 
+ {static} Single<Long> timer(final long delay, final TimeUnit unit, final Scheduler scheduler) 
+ final Single<T> ambWith(SingleSource<? extends T> other) 
+ final Single<T> hide() 
+ final Single<T> cache() 
+ final Flowable<T> concatWith(SingleSource<? extends T> other) 
+ final Single<T> delay(long time, TimeUnit unit) 
+ final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final Single<T> delaySubscription(CompletableSource other) 
+ final Single<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) 
+ final Single<T> doAfterTerminate(Action onAfterTerminate) 
+ final Single<T> doFinally(Action onFinally) 
+ final Single<T> doOnSubscribe(final Consumer<? super Disposable> onSubscribe) 
+ final Single<T> doOnSuccess(final Consumer<? super T> onSuccess) 
+ final Single<T> doOnEvent(final BiConsumer<? super T, ? super Throwable> onEvent) 
+ final Single<T> doOnError(final Consumer<? super Throwable> onError) 
+ final Single<T> doOnDispose(final Action onDispose) 
+ final Maybe<T> filter(Predicate<? super T> predicate) 
+ final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) 
+ final T blockingGet() 
+ final Single<Boolean> contains(Object value) 
+ final Single<Boolean> contains(final Object value, final BiPredicate<Object, Object> comparer) 
+ final Flowable<T> mergeWith(SingleSource<? extends T> other) 
+ final Single<T> observeOn(final Scheduler scheduler) 
+ final Single<T> onErrorReturn(final Function<Throwable, ? extends T> resumeFunction) 
+ final Single<T> onErrorReturnItem(final T value) 
+ final Single<T> onErrorResumeNext(final Single<? extends T> resumeSingleInCaseOfError) 
+ final Single<T> onErrorResumeNext(
            final Function<? super Throwable, ? extends SingleSource<? extends T>> resumeFunctionInCaseOfError) 
+ final Flowable<T> repeat() 
+ final Flowable<T> repeat(long times) 
+ final Flowable<T> repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final Flowable<T> repeatUntil(BooleanSupplier stop) 
+ final Single<T> retry() 
+ final Single<T> retry(long times) 
+ final Single<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Single<T> retry(Predicate<? super Throwable> predicate) 
+ final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final Disposable subscribe() 
+ final Disposable subscribe(final BiConsumer<? super T, ? super Throwable> onCallback) 
+ final Disposable subscribe(Consumer<? super T> onSuccess) 
+ final Disposable subscribe(final Consumer<? super T> onSuccess, final Consumer<? super Throwable> onError) 
+ final void subscribe(SingleObserver<? super T> subscriber) 
# {abstract} void subscribeActual(@NonNull SingleObserver<? super T> observer)
+ final Single<T> subscribeOn(final Scheduler scheduler) 
+ final Single<T> takeUntil(final CompletableSource other) 
+ final Single<T> timeout(long timeout, TimeUnit unit) 
+ final Single<T> timeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Single<T> timeout(long timeout, TimeUnit unit, Scheduler scheduler, SingleSource<? extends T> other) 
+ final Single<T> timeout(long timeout, TimeUnit unit, SingleSource<? extends T> other) 
- Single<T> timeout0(final long timeout, final TimeUnit unit, final Scheduler scheduler, final SingleSource<? extends T> other) 
+ final Completable toCompletable() 
+ final Flowable<T> toFlowable() 
+ final Future<T> toFuture() 
+ final Maybe<T> toMaybe() 
+ final Observable<T> toObservable() 
+ final Single<T> unsubscribeOn(final Scheduler scheduler) 
+ final TestObserver<T> test() 
+ final TestObserver<T> test(boolean cancelled) 
 
}
abstract class io.reactivex.disposables.ReferenceDisposable {
 # {abstract} void onDisposed(@NonNull T value)
+ final boolean isDisposed() 
 
}
abstract class io.reactivex.flowables.ConnectableFlowable {
 + {abstract} void connect(@NonNull Consumer<? super Disposable> connection)
+ final Disposable connect() 
+ Flowable<T> refCount() 
+ Flowable<T> autoConnect() 
+ Flowable<T> autoConnect(int numberOfSubscribers) 
+ Flowable<T> autoConnect(int numberOfSubscribers, @NonNull Consumer<? super Disposable> connection) 
 
}
abstract class io.reactivex.flowables.GroupedFlowable {
 + K getKey() 
~    final K key;
 
}
abstract class io.reactivex.internal.observers.BasicFuseableObserver {
 + final void onSubscribe(Disposable s) 
# boolean beforeDownstream() 
# void afterDownstream() 
+ void onError(Throwable t) 
# final void fail(Throwable t) 
+ void onComplete() 
# final int transitiveBoundaryFusion(int mode) 
+ void dispose() 
+ boolean isDisposed() 
+ boolean isEmpty() 
+ void clear() 
+ final boolean offer(R e) 
+ final boolean offer(R v1, R v2) 
    # Disposable s;
    # QueueDisposable<T> qs;
    # boolean done;
    # int sourceMode;
 
}
abstract class io.reactivex.internal.observers.BasicIntQueueDisposable {
 + final boolean offer(T e) 
+ final boolean offer(T v1, T v2) 
 
}
abstract class io.reactivex.internal.observers.BasicQueueDisposable {
 + final boolean offer(T e) 
+ final boolean offer(T v1, T v2) 
 
}
abstract class io.reactivex.internal.observers.BlockingBaseObserver {
 + final void onSubscribe(Disposable d) 
+ final void onComplete() 
+ final void dispose() 
+ final boolean isDisposed() 
+ final T blockingGet() 
 
}
abstract class io.reactivex.internal.observers.DeferredScalarObserver {
 + void onSubscribe(Disposable s) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
    # Disposable s;
 
}
abstract class io.reactivex.internal.observers.QueueDrainObserver {
 + final boolean cancelled() 
+ final boolean done() 
+ final boolean enter() 
+ final boolean fastEnter() 
# final void fastPathEmit(U value, boolean delayError, Disposable dispose) 
# final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) 
+ final Throwable error() 
+ final int leave(int m) 
+ void accept(Observer<? super V> a, U v) 
    # final SimplePlainQueue<U> queue;
    # Throwable error;
 
}
abstract class io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream {
 + final Publisher<T> source() 
    # final Flowable<T> source;
 
}
abstract class io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream {
 + final MaybeSource<T> source() 
    # final MaybeSource<T> source;
 
}
abstract class io.reactivex.internal.operators.observable.AbstractObservableWithUpstream {
 + final ObservableSource<T> source() 
    # final ObservableSource<T> source;
 
}
abstract class io.reactivex.internal.schedulers.AbstractDirectTask {
 + final void dispose() 
+ final boolean isDisposed() 
+ final void setFuture(Future<?> future) 
    # final Runnable runnable;
    # Thread runner;
 
}
abstract class io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber {
 + final void onSubscribe(Subscription s) 
# boolean beforeDownstream() 
# void afterDownstream() 
+ void onError(Throwable t) 
# final void fail(Throwable t) 
+ void onComplete() 
# final int transitiveBoundaryFusion(int mode) 
+ void request(long n) 
+ void cancel() 
+ boolean isEmpty() 
+ void clear() 
+ final boolean offer(R e) 
+ final boolean offer(R v1, R v2) 
    # Subscription s;
    # QueueSubscription<T> qs;
    # boolean done;
    # int sourceMode;
 
}
abstract class io.reactivex.internal.subscribers.BasicFuseableSubscriber {
 + final void onSubscribe(Subscription s) 
# boolean beforeDownstream() 
# void afterDownstream() 
+ void onError(Throwable t) 
# final void fail(Throwable t) 
+ void onComplete() 
# final int transitiveBoundaryFusion(int mode) 
+ void request(long n) 
+ void cancel() 
+ boolean isEmpty() 
+ void clear() 
+ final boolean offer(R e) 
+ final boolean offer(R v1, R v2) 
    # Subscription s;
    # QueueSubscription<T> qs;
    # boolean done;
    # int sourceMode;
 
}
abstract class io.reactivex.internal.subscribers.BlockingBaseSubscriber {
 + final void onSubscribe(Subscription s) 
+ final void onComplete() 
+ final T blockingGet() 
 
}
abstract class io.reactivex.internal.subscribers.DeferredScalarSubscriber {
 + void onSubscribe(Subscription s) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
    # Subscription s;
    # boolean hasValue;
 
}
abstract class io.reactivex.internal.subscribers.QueueDrainSubscriber {
 + final boolean cancelled() 
+ final boolean done() 
+ final boolean enter() 
+ final boolean fastEnter() 
# final void fastPathEmitMax(U value, boolean delayError, Disposable dispose) 
# final void fastPathOrderedEmitMax(U value, boolean delayError, Disposable dispose) 
+ boolean accept(Subscriber<? super V> a, U v) 
+ final Throwable error() 
+ final int leave(int m) 
+ final long requested() 
+ final long produced(long n) 
+ final void requested(long n) 
    # final SimplePlainQueue<U> queue;
    # Throwable error;
 
}
abstract class io.reactivex.internal.subscribers.SinglePostCompleteSubscriber {
 + void onSubscribe(Subscription s) 
# final void complete(R n) 
# void onDrop(R n) 
+ final void request(long n) 
+ void cancel() 
    # Subscription s;
    # R value;
    # long produced;
 
}
abstract class io.reactivex.internal.subscriptions.BasicIntQueueSubscription {
 + final boolean offer(T e) 
+ final boolean offer(T v1, T v2) 
 
}
abstract class io.reactivex.internal.subscriptions.BasicQueueSubscription {
 + final boolean offer(T e) 
+ final boolean offer(T v1, T v2) 
 
}
abstract class io.reactivex.observables.ConnectableObservable {
 + {abstract} void connect(@NonNull Consumer<? super Disposable> connection)
+ final Disposable connect() 
+ Observable<T> refCount() 
+ Observable<T> autoConnect() 
+ Observable<T> autoConnect(int numberOfSubscribers) 
+ Observable<T> autoConnect(int numberOfSubscribers, @NonNull Consumer<? super Disposable> connection) 
 
}
abstract class io.reactivex.observables.GroupedObservable {
 + K getKey() 
~    final K key;
 
}
abstract class io.reactivex.observers.BaseTestConsumer {
 + final Thread lastThread() 
+ final List<T> values() 
+ final List<Throwable> errors() 
+ final long completions() 
+ final boolean isTerminated() 
+ final int valueCount() 
+ final int errorCount() 
# final AssertionError fail(String message) 
+ final U await() 
+ final boolean await(long time, TimeUnit unit) 
+ final U assertComplete() 
+ final U assertNotComplete() 
+ final U assertNoErrors() 
+ final U assertError(Throwable error) 
+ final U assertError(Class<? extends Throwable> errorClass) 
+ final U assertError(Predicate<Throwable> errorPredicate) 
+ final U assertValue(T value) 
+ final U assertNever(T value) 
+ final U assertValue(Predicate<T> valuePredicate) 
+ final U assertNever(Predicate<? super T> valuePredicate) 
+ final U assertValueAt(int index, Predicate<T> valuePredicate) 
+ {static} String valueAndClass(Object o) 
+ final U assertValueCount(int count) 
+ final U assertNoValues() 
+ final U assertValues(T... values) 
+ final U assertValueSet(Collection<? extends T> expected) 
+ final U assertValueSequence(Iterable<? extends T> sequence) 
+ final U assertTerminated() 
+ final U assertNotTerminated() 
+ final boolean awaitTerminalEvent() 
+ final boolean awaitTerminalEvent(long duration, TimeUnit unit) 
+ final U assertErrorMessage(String message) 
+ final List<List<Object>> getEvents() 
+ {abstract} U assertSubscribed()
+ final U assertFailure(Class<? extends Throwable> error, T... values) 
+ final U assertFailure(Predicate<Throwable> errorPredicate, T... values) 
+ final U assertFailureAndMessage(Class<? extends Throwable> error,
            String message, T... values) 
+ final U awaitDone(long time, TimeUnit unit) 
+ final U assertEmpty() 
+ final U withTag(CharSequence tag) 
+ void run() 
+ {abstract} void run()
+ final U awaitCount(int atLeast) 
+ final U awaitCount(int atLeast, Runnable waitStrategy) 
+ final U awaitCount(int atLeast, Runnable waitStrategy, long timeoutMillis) 
+ final boolean isTimeout() 
+ final U clearTimeout() 
+ final U assertTimeout() 
+ final U assertNoTimeout() 
    # final CountDownLatch done;
    # final List<T> values;
    # final List<Throwable> errors;
    # long completions;
    # Thread lastThread;
    # boolean checkSubscriptionOnce;
    # int initialFusionMode;
    # int establishedFusionMode;
    # CharSequence tag;
    # boolean timeout;
 
}
abstract class io.reactivex.observers.DefaultObserver {
 + void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void onSubscribe(@NonNull Disposable s) 
# final void cancel() 
# void onStart() 
    - Disposable s;
 
}
abstract class io.reactivex.observers.DisposableCompletableObserver {
 + void onStart() 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final boolean isDisposed() 
+ final void dispose() 
 
}
abstract class io.reactivex.observers.DisposableMaybeObserver {
 + void onStart() 
+ void onSuccess(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final boolean isDisposed() 
+ final void dispose() 
 
}
abstract class io.reactivex.observers.DisposableObserver {
 + void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final boolean isDisposed() 
+ final void dispose() 
 
}
abstract class io.reactivex.observers.DisposableSingleObserver {
 + void onStart() 
+ void onSuccess(Integer t) 
+ void onError(Throwable t) 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final boolean isDisposed() 
+ final void dispose() 
 
}
abstract class io.reactivex.observers.ResourceCompletableObserver {
 + void onStart() 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void add(@NonNull Disposable resource) 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final void dispose() 
+ final boolean isDisposed() 
 
}
abstract class io.reactivex.observers.ResourceMaybeObserver {
 + void onStart() 
+ void onSuccess(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void add(@NonNull Disposable resource) 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final void dispose() 
+ final boolean isDisposed() 
 
}
abstract class io.reactivex.observers.ResourceObserver {
 + void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void add(@NonNull Disposable resource) 
+ final void onSubscribe(Disposable s) 
# void onStart() 
+ final void dispose() 
+ final boolean isDisposed() 
 
}
abstract class io.reactivex.observers.ResourceSingleObserver {
 + void onStart() 
+ void onSuccess(Integer t) 
+ void onError(Throwable t) 
+ final void add(@NonNull Disposable resource) 
+ final void onSubscribe(@NonNull Disposable s) 
# void onStart() 
+ final void dispose() 
+ final boolean isDisposed() 
 
}
abstract class io.reactivex.parallel.ParallelFlowable {
 + {abstract} void subscribe(@NonNull Subscriber<? super T>[] subscribers)
+ final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate) 
+ final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate, @NonNull ParallelFailureHandling errorHandler) 
+ final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate, @NonNull BiFunction<? super Long, ? super Throwable, ParallelFailureHandling> errorHandler) 
+ final ParallelFlowable<T> runOn(@NonNull Scheduler scheduler) 
+ final ParallelFlowable<T> runOn(@NonNull Scheduler scheduler, int prefetch) 
+ final Flowable<T> reduce(@NonNull BiFunction<T, T, T> reducer) 
+ final Flowable<T> sequential() 
+ final Flowable<T> sequential(int prefetch) 
+ final Flowable<T> sequentialDelayError() 
+ final Flowable<T> sequentialDelayError(int prefetch) 
+ final Flowable<T> sorted(@NonNull Comparator<? super T> comparator) 
+ final Flowable<T> sorted(@NonNull Comparator<? super T> comparator, int capacityHint) 
+ final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator) 
+ final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) 
+ final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext) 
+ final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext, @NonNull ParallelFailureHandling errorHandler) 
+ final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext, @NonNull BiFunction<? super Long, ? super Throwable, ParallelFailureHandling> errorHandler) 
+ final ParallelFlowable<T> doAfterNext(@NonNull Consumer<? super T> onAfterNext) 
+ final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) 
+ final ParallelFlowable<T> doOnComplete(@NonNull Action onComplete) 
+ final ParallelFlowable<T> doAfterTerminated(@NonNull Action onAfterTerminate) 
+ final ParallelFlowable<T> doOnSubscribe(@NonNull Consumer<? super Subscription> onSubscribe) 
+ final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) 
+ final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) 
 
}
abstract class io.reactivex.processors.DelayedFlowableProcessorTest {
 + void onNextNullDelayed() 
+ void onErrorNullDelayed() 
 
}
abstract class io.reactivex.processors.FlowableProcessor {
 + {abstract} boolean hasSubscribers()
 
}
abstract class io.reactivex.processors.FlowableProcessorTest {
 # {abstract} FlowableProcessor<T> create()
+ void onErrorNull() 
 
}
abstract class io.reactivex.schedulers.AbstractSchedulerConcurrencyTests {
 + final void testUnSubscribeForScheduler() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testUnsubscribeRecursiveScheduleFromOutside() 
+ void testUnsubscribeRecursiveScheduleFromInside() 
+ void testUnsubscribeRecursiveScheduleWithDelay() 
+ void recursionFromOuterActionAndUnsubscribeInside() 
+ void testRecursion() 
+ void testRecursionAndOuterUnsubscribe() 
+ void cancel() 
+ void request(long n) 
+ void onNext(Integer args) 
+ final void testSubscribeWithScheduler() 
+ void accept(Integer t) 
 
}
abstract class io.reactivex.schedulers.AbstractSchedulerTests {
 # {abstract} Scheduler getScheduler()
+ void run() 
+ final void testNestedScheduling() 
+ final void testSequenceOfActions() 
+ Object answer(InvocationOnMock invocation) 
+ void testSequenceOfDelayedActions() 
+ void testMixOfDelayedAndNonDelayedActions() 
+ final void testRecursiveExecution() 
+ final void testRecursiveExecutionWithDelayTime() 
+ final void testRecursiveSchedulerInObservable() 
+ void accept(Integer v) 
+ final void testConcurrentOnNextFailsValidation() 
+ final void testObserveOn() 
+ final void testSubscribeOnNestedConcurrency() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(T args) 
+ void scheduleDirect() 
+ void scheduleDirectDelayed() 
+ void scheduleDirectPeriodic() 
 
}
abstract class io.reactivex.subjects.Subject {
 + {abstract} boolean hasObservers()
+ {abstract} boolean hasThrowable()
 
}
abstract class io.reactivex.subscribers.DefaultSubscriber {
 + void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void onSubscribe(Subscription s) 
# final void request(long n) 
# final void cancel() 
# void onStart() 
    - Subscription s;
 
}
abstract class io.reactivex.subscribers.DisposableSubscriber {
 + void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void onSubscribe(Subscription s) 
# void onStart() 
# final void request(long n) 
# final void cancel() 
+ final boolean isDisposed() 
+ final void dispose() 
 
}
abstract class io.reactivex.subscribers.ResourceSubscriber {
 + void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void add(Disposable resource) 
+ final void onSubscribe(Subscription s) 
# void onStart() 
# final void request(long n) 
+ final void dispose() 
+ final boolean isDisposed() 
 
}
abstract class io.reactivex.tck.BaseTck {
 + Publisher<T> createFailedPublisher() 
+ long maxElementsFromPublisher() 
# Iterable<Long> iterate(long elements) 
# Iterable<Long> iterate(boolean useInfinite, long elements) 
# Long[] array(long elements) 
+ Iterator<Long> iterator() 
+ boolean hasNext() 
+ Long next() 
+ void remove() 
~        final long end;
~            final long end;
 
}
class Scheduler.Worker
class io.reactivex.BackpressureEnumTest {
 + void backpressureOverflowStrategy() 
+ void backpressureStrategy() 
+ void backpressureKind() 
 
}
class io.reactivex.BaseTypeAnnotations {
 ~{static} void checkCheckReturnValueSupport(Class<?> clazz) 
~{static} void checkSchedulerSupport(Class<?> clazz) 
~{static} void checkBackpressureSupport(Class<?> clazz) 
+ void checkReturnValueFlowable() 
+ void checkReturnValueObservable() 
+ void checkReturnValueSingle() 
+ void checkReturnValueCompletable() 
+ void checkReturnValueMaybe() 
+ void schedulerSupportFlowable() 
+ void schedulerSupportObservable() 
+ void schedulerSupportSingle() 
+ void schedulerSupportCompletable() 
+ void schedulerSupportMaybe() 
+ void backpressureSupportFlowable() 
+ void backpressureSupportObservable() 
+ void backpressureSupportSingle() 
+ void backpressureSupportCompletable() 
+ void backpressureSupportMaybe() 
 
}
class io.reactivex.BaseTypeParser {
 + {static} List<RxMethod> parse(File f, String baseClassName) 
        + String signature;
        + String backpressureKind;
        + String schedulerKind;
        + String javadoc;
        + String backpressureDocumentation;
        + String schedulerDocumentation;
        + int javadocLine;
        + int methodLine;
        + int backpressureDocLine;
        + int schedulerDocLine;
 
}
class io.reactivex.BaseTypeParser.RxMethod
class io.reactivex.BlockingGetPerf {
 + void setup() 
+ Object flowableBlockingFirst() 
+ Object flowableBlockingLast() 
+ Object observableBlockingLast() 
+ Object observableBlockingFirst() 
+ Object single() 
+ Object maybe() 
+ Object completable() 
 
}
class io.reactivex.BlockingPerf {
 + void setup() 
+ Object flowableBlockingFirst() 
+ Object flowableBlockingLast() 
+ Object observableBlockingLast() 
+ Object observableBlockingFirst() 
    + int times;
 
}
class io.reactivex.CallableAsyncPerf {
 + void setup() 
+ void subscribeOnFlowable(Blackhole bh) 
+ void observeOnFlowable(Blackhole bh) 
+ void pipelineFlowable(Blackhole bh) 
+ void subscribeOnObservable(Blackhole bh) 
+ void observeOnObservable(Blackhole bh) 
+ void pipelineObservable(Blackhole bh) 
+ void observeOnSingle(Blackhole bh) 
+ void subscribeOnSingle(Blackhole bh) 
+ void pipelineSingle(Blackhole bh) 
+ void observeOnCompletable(Blackhole bh) 
+ void subscribeOnCompletable(Blackhole bh) 
+ void pipelineCompletable(Blackhole bh) 
+ void observeOnMaybe(Blackhole bh) 
+ void subscribeOnMaybe(Blackhole bh) 
+ void pipelineMaybe(Blackhole bh) 
 
}
class io.reactivex.CountDownLatch
class io.reactivex.EachTypeFlatMapPerf {
 + void setup() 
+ Observable<Integer> apply(Integer v) 
+ Publisher<Integer> apply(Integer v) 
+ Single<Integer> apply(Integer v) 
+ void bpRange(Blackhole bh) 
+ void bpRangeMapJust(Blackhole bh) 
+ void bpRangeMapRange(Blackhole bh) 
+ void nbpRange(Blackhole bh) 
+ void nbpRangeMapJust(Blackhole bh) 
+ void nbpRangeMapRange(Blackhole bh) 
+ void singleJust(Blackhole bh) 
+ void singleJustMapJust(Blackhole bh) 
    + int times;
 
}
class io.reactivex.FixLicenseHeaders {
 + void checkAndUpdateLicenses() 
 
}
class io.reactivex.FlatMapJustPerf {
 + void setup() 
+ Observable<Integer> apply(Integer v) 
+ void flowable(Blackhole bh) 
+ void observable(Blackhole bh) 
    + int times;
 
}
class io.reactivex.FlattenCrossMapPerf {
 + void setup() 
+ Iterable<Integer> apply(Integer v) 
+ void flowable(Blackhole bh) 
+ void observable(Blackhole bh) 
    + int times;
 
}
class io.reactivex.FlattenJustPerf {
 + void setup() 
+ Iterable<Integer> apply(Integer v) 
+ void flowable(Blackhole bh) 
+ void observable(Blackhole bh) 
    + int times;
 
}
class io.reactivex.InternalWrongNaming {
 ~{static} void checkInternalOperatorNaming(String baseClassName, String consumerClassName, String... ignore) 
~{static} List<String> readFile(File u) 
+ void observableNoSubscriber() 
+ void observableNoSubscribers() 
+ void observableNoSubscription() 
+ void observableNoPublisher() 
+ void observableNoFlowable() 
+ void observableProducer() 
+ void observableProducers() 
+ void flowableNoProducer() 
+ void flowableNoProducers() 
+ void flowableNoUnsubscrib() 
+ void observableNoUnsubscrib() 
+ void flowableNoObserver() 
 
}
class io.reactivex.JavadocForAnnotations {
 ~{static} void checkSource(String baseClassName, boolean scheduler) 
+ {static} StringBuilder readFile(File f) 
~{static} final void scanFor(StringBuilder sourceCode, String annotation, String inDoc,
            StringBuilder e, String baseClassName) 
~{static} final void scanForBadMethod(StringBuilder sourceCode, String annotation, String inDoc,
            StringBuilder e, String baseClassName) 
~{static} void checkSchedulerBadMethod(String baseClassName) 
+ {static} int lineNumber(StringBuilder s, int index) 
+ void checkFlowableBackpressure() 
+ void checkFlowableScheduler() 
+ void checkObservableBackpressure() 
+ void checkObservableScheduler() 
+ void checkSingleBackpressure() 
+ void checkSingleScheduler() 
+ void checkCompletableBackpressure() 
+ void checkCompletableScheduler() 
+ void checkMaybeBackpressure() 
+ void checkMaybeScheduler() 
+ void checkFlowableSchedulerDoc() 
+ void checkObservableSchedulerDoc() 
+ void checkSingleSchedulerDoc() 
+ void checkCompletableSchedulerDoc() 
+ void checkMaybeSchedulerDoc() 
 
}
class io.reactivex.JavadocWording {
 + {static} int lineNumber(CharSequence s, int index) 
+ void maybeDocRefersToMaybeTypes() 
+ void flowableDocRefersToFlowableTypes() 
+ void observableDocRefersToObservableTypes() 
+ void singleDocRefersToSingleTypes() 
+ void completableDocRefersToCompletableTypes() 
~{static} void aOrAn(StringBuilder e, RxMethod m, String baseTypeName) 
~{static} void aOrAn(StringBuilder e, RxMethod m, String wrongPre, String word, String baseTypeName) 
~{static} void missingClosingDD(StringBuilder e, RxMethod m, String baseTypeName) 
~{static} void backpressureMentionedWithoutAnnotation(StringBuilder e, RxMethod m, String baseTypeName) 
 
}
class io.reactivex.JustAsyncPerf {
 + void setup() 
+ void subscribeOnFlowable(Blackhole bh) 
+ void observeOnFlowable(Blackhole bh) 
+ void pipelineFlowable(Blackhole bh) 
+ void subscribeOnObservable(Blackhole bh) 
+ void observeOnObservable(Blackhole bh) 
+ void pipelineObservable(Blackhole bh) 
+ void observeOnSingle(Blackhole bh) 
+ void subscribeOnSingle(Blackhole bh) 
+ void pipelineSingle(Blackhole bh) 
+ void observeOnCompletable(Blackhole bh) 
+ void subscribeOnCompletable(Blackhole bh) 
+ void pipelineCompletable(Blackhole bh) 
+ void observeOnMaybe(Blackhole bh) 
+ void subscribeOnMaybe(Blackhole bh) 
+ void pipelineMaybe(Blackhole bh) 
 
}
class io.reactivex.LatchedSingleObserver {
 + void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final CountDownLatch cdl;
~    final Blackhole bh;
 
}
class io.reactivex.MaybeNo2Dot0Since {
 + {static} File findSource(String baseClassName) 
+ void noSince20InMaybe() 
 
}
class io.reactivex.NoAnonymousInnerClassesTest {
 + void verify() 
 
}
class io.reactivex.Notification {
 + boolean isOnComplete() 
+ boolean isOnError() 
+ boolean isOnNext() 
+ T getValue() 
+ Throwable getError() 
+ boolean equals(Object obj) 
+ int hashCode() 
+ String toString() 
~    final Object value;
 
}
class io.reactivex.NotificationTest {
 + void valueOfOnErrorIsNull() 
+ void valueOfOnCompleteIsNull() 
+ void notEqualsToObject() 
+ void hashCodeIsTheInner() 
+ void toStringPattern() 
 
}
class io.reactivex.ObservableFlatMapPerf {
 + void setup() 
+ void flatMapXRange(Blackhole bh) 
    + int count;
 
}
class io.reactivex.OperatorFlatMapPerf {
 + int getSize() 
+ void flatMapIntPassthruSync(Input input) 
+ void flatMapIntPassthruAsync(Input input) 
+ void flatMapTwoNestedSync(final Input input) 
+ void flatMapTwoNestedAsync(final Input input) 
        + int size;
 
}
class io.reactivex.OperatorMergePerf {
 + void oneStreamOfNthatMergesIn1(final InputMillion input) 
+ void merge1SyncStreamOfN(final InputMillion input) 
+ void mergeNSyncStreamsOfN(final InputThousand input) 
+ void mergeNAsyncStreamsOfN(final InputThousand input) 
+ void mergeTwoAsyncStreamsOfN(final InputThousand input) 
+ void mergeNSyncStreamsOf1(final InputForMergeN input) 
+ void setup(final Blackhole bh) 
+ PerfSubscriber newLatchedObserver() 
+ int getSize() 
        + int size;
        - Blackhole bh;
 
}
class io.reactivex.OperatorsAreFinal {
 + void flowable() 
+ void observable() 
+ void single() 
+ void completable() 
+ void maybe() 
 
}
class io.reactivex.ParamValidationCheckerTest {
 + void checkFlowable() 
+ void checkObservable() 
+ void checkSingle() 
+ void checkMaybe() 
+ void checkCompletable() 
+ void checkParallelFlowable() 
~{static} void addIgnore(ParamIgnore ignore) 
~{static} void addOverride(ParamOverride ignore) 
~{static} void addDefaultInstance(Class<?> clazz, Object o, String tag) 
+ ParallelFlowable apply(ParallelFlowable upstream) 
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7, Object t8,
                Object t9) 
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7, Object t8)
                
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7)
                
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6) 
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5) 
+ Object apply(Object t1, Object t2, Object t3, Object t4) 
+ Object apply(Object t1, Object t2, Object t3) 
+ void accept(Object t1, Object t2) 
+ Object apply(Object t1, Object t2) 
+ void subscribe(CompletableEmitter e) 
+ void subscribe(MaybeEmitter e) 
+ void subscribe(SingleEmitter e) 
+ void subscribe(ObservableEmitter e) 
+ void subscribe(FlowableEmitter e) 
+ boolean test(Object t1, Object t2) 
+ boolean test(Object t) 
+ void onSuccess(Object t) 
+ void onSubscribe(Disposable d) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ CompletableSource apply(Completable upstream) 
+ MaybeSource apply(Maybe upstream) 
+ SingleSource apply(Single upstream) 
+ ObservableSource apply(Observable upstream) 
+ Publisher apply(Flowable upstream) 
+ CompletableObserver apply(CompletableObserver observer) 
+ MaybeObserver apply(MaybeObserver observer) 
+ SingleObserver apply(SingleObserver observer) 
+ Observer apply(Observer observer) 
+ Subscriber apply(Subscriber observer) 
+ boolean getAsBoolean() 
+ int compare(Object o1, Object o2) 
+ String toString() 
+ void subscribeActual(Subscriber<? super Object> s) 
+ void subscribeActual(Observer<? super Object> s) 
+ void subscribeActual(SingleObserver<? super Object> s) 
+ void subscribeActual(MaybeObserver<? super Object> s) 
+ void subscribeActual(CompletableObserver s) 
~        final String name;
~        final int index;
~        final ParamMode mode;
 
}
class io.reactivex.PerfAsyncConsumer {
 + void onSuccess(Object value) 
+ void onSubscribe(Disposable d) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void await(int count) 
~    final Blackhole bh;
 
}
class io.reactivex.PerfConsumer {
 + void onSuccess(Object value) 
+ void onSubscribe(Disposable d) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Blackhole bh;
 
}
class io.reactivex.PerfInteropConsumer {
 + void onSuccess(Object value) 
+ void onSubscribe(Disposable d) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Blackhole bh;
 
}
class io.reactivex.PerfObserver {
 + void onSubscribe(Disposable d) 
+ void onNext(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final CountDownLatch cdl;
~    final Blackhole bh;
 
}
class io.reactivex.PerfSubscriber {
 + void onSubscribe(Subscription s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Object t) 
    - final Blackhole bh;
 
}
class io.reactivex.PublicFinalMethods {
 ~{static} void scan(Class<?> clazz) 
+ void flowable() 
+ void observable() 
+ void single() 
+ void completable() 
+ void maybe() 
 
}
class io.reactivex.RangePerf {
 + void setup() 
+ Object rangeSync(Blackhole bh) 
+ void rangeAsync(Blackhole bh) 
+ void rangePipeline(Blackhole bh) 
    + int times;
 
}
class io.reactivex.ReducePerf {
 + Integer apply(Integer t1, Integer t2) 
+ void setup() 
+ void obsSingle(Blackhole bh) 
+ void flowSingle(Blackhole bh) 
+ void obsMaybe(Blackhole bh) 
+ void flowMaybe(Blackhole bh) 
    + int times;
 
}
class io.reactivex.Retry {
 + void evaluate() 
+ Statement apply(Statement base, Description description) 
- Statement statement(final Statement base, final Description description) 
        - final Statement base;
        - final Description description;
~    final int retryCount;
~    final int sleep;
~    final boolean backoff;
 
}
class io.reactivex.RxVsStreamPerf {
 + void setup() 
+ Publisher<Integer> apply(Integer v) 
+ Observable<Integer> apply(Integer v) 
+ void range(Blackhole bh) 
+ void rangeObservable(Blackhole bh) 
+ void rangeFlatMap(Blackhole bh) 
+ void rangeObservableFlatMap(Blackhole bh) 
+ void rangeFlatMapJust(Blackhole bh) 
+ void rangeObservableFlatMapJust(Blackhole bh) 
    + int times;
 
}
class io.reactivex.Scheduler.Worker
class io.reactivex.StrictPerf {
 + void setup() 
+ void internal(Blackhole bh) 
+ void external(Blackhole bh) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void onSubscribe(Subscription s) 
    + int count;
    + int cpu;
~        final Blackhole bh;
~        final int cycles;
 
}
class io.reactivex.TextualAorAn {
 + void checkFiles() 
~{static} void processFile(StringBuilder b, List<String> lines, String className, String fileName) 
 
}
class io.reactivex.ToFlowablePerf {
 + void setup() 
+ Publisher<Integer> apply(Integer v) 
+ Observable<Integer> apply(Integer v) 
+ Object flowable() 
+ Object flowableInner() 
+ Object observable() 
+ Object observableInner() 
+ {static} void main(String[] args) 
    + int times;
 
}
class io.reactivex.TransformerTest {
 + void flowableTransformerThrows() 
+ void observableTransformerThrows() 
+ void singleTransformerThrows() 
+ void maybeTransformerThrows() 
+ void completableTransformerThrows() 
+ void observableGenericsSignatureTest() 
+ void singleGenericsSignatureTest() 
+ void maybeGenericsSignatureTest() 
+ void flowableGenericsSignatureTest() 
+ ObservableSource<B<T>> apply(Observable<A<T, ?>> a) 
+ SingleSource<B<T>> apply(Single<A<T, ?>> a) 
+ MaybeSource<B<T>> apply(Maybe<A<T, ?>> a) 
+ Publisher<B<T>> apply(Flowable<A<T, ?>> a) 
 
}
class io.reactivex.XFlatMapTest {
 + void flowableFlowable() 
+ void flowableSingle() 
+ void flowableMaybe() 
+ void flowableCompletable() 
+ void flowableCompletable2() 
+ void observableFlowable() 
+ void observerSingle() 
+ void observerMaybe() 
+ void observerCompletable() 
+ void observerCompletable2() 
+ void singleSingle() 
+ void singleMaybe() 
+ void singleCompletable() 
+ void singleCompletable2() 
+ void maybeSingle() 
+ void maybeMaybe() 
+ void maybeCompletable() 
+ void maybeCompletable2() 
 
}
class io.reactivex.XMapYPerf {
 + void setup() 
+ Publisher<Integer> apply(Integer v) 
+ SingleSource<Integer> apply(Integer v) 
+ MaybeSource<Integer> apply(Integer v) 
+ CompletableSource apply(Integer v) 
+ Iterable<Integer> apply(Integer v) 
+ Observable<Integer> apply(Integer v) 
+ void flowFlatMapIterable1(Blackhole bh) 
+ void flowFlatMapIterable0(Blackhole bh) 
+ void flowFlatMapFlowable0(Blackhole bh) 
+ void flowFlatMapFlowable1(Blackhole bh) 
+ void flowFlatMapSingle1(Blackhole bh) 
+ void flowFlatMapMaybe1(Blackhole bh) 
+ void flowFlatMapMaybe0(Blackhole bh) 
+ void flowFlatMapCompletable0(Blackhole bh) 
+ void flowFlatMapIterableAsFlow1(Blackhole bh) 
+ void flowFlatMapIterableAsFlow0(Blackhole bh) 
+ void flowFlatMapSingleAsFlow1(Blackhole bh) 
+ void flowFlatMapMaybeAsFlow1(Blackhole bh) 
+ void flowFlatMapMaybeAsFlow0(Blackhole bh) 
+ void flowFlatMapCompletableAsFlow0(Blackhole bh) 
+ void obsFlatMapIterable0(Blackhole bh) 
+ void obsFlatMapIterable1(Blackhole bh) 
+ void obsFlatMapObservable0(Blackhole bh) 
+ void obsFlatMapObservable1(Blackhole bh) 
+ void obsFlatMapSingle1(Blackhole bh) 
+ void obsFlatMapMaybe1(Blackhole bh) 
+ void obsFlatMapMaybe0(Blackhole bh) 
+ void obsFlatMapCompletable0(Blackhole bh) 
+ void obsFlatMapIterableAsObs1(Blackhole bh) 
+ void obsFlatMapIterableAsObs0(Blackhole bh) 
+ void obsFlatMapSingleAsObs1(Blackhole bh) 
+ void obsFlatMapMaybeAsObs1(Blackhole bh) 
+ void obsFlatMapMaybeAsObs0(Blackhole bh) 
+ void obsFlatMapCompletableAsObs0(Blackhole bh) 
    + int times;
 
}
class io.reactivex.completable.CapturingUncaughtExceptionHandler {
 + void uncaughtException(Thread t, Throwable e) 
    + int count;
    + Throwable caught;
 
}
class io.reactivex.completable.CompletableTest {
 + Iterator<Completable> iterator() 
+ Completable next() 
+ void remove() 
+ void subscribe(CompletableObserver s) 
+ void assertSubscriptions(int n) 
+ void complete() 
+ void concatNull() 
+ void concatEmpty() 
+ void concatSingleSource() 
+ void concatSingleSourceThrows() 
+ void concatMultipleSources() 
+ void concatMultipleOneThrows() 
+ void concatMultipleOneIsNull() 
+ void concatIterableEmpty() 
+ void concatIterableNull() 
+ void concatIterableIteratorNull() 
+ void concatIterableWithNull() 
+ void concatIterableSingle() 
+ void concatIterableMany() 
+ void concatIterableOneThrows() 
+ void concatIterableManyOneThrows() 
+ void concatIterableIterableThrows() 
+ void concatIterableIteratorHasNextThrows() 
+ void concatIterableIteratorNextThrows() 
+ void concatObservableEmpty() 
+ void concatObservableError() 
+ void concatObservableSingle() 
+ void concatObservableSingleThrows() 
+ void concatObservableMany() 
+ void concatObservableManyOneThrows() 
+ void concatObservablePrefetch() 
+ void createNull() 
+ void createOnSubscribeThrowsNPE() 
+ void createOnSubscribeThrowsRuntimeException() 
+ void defer() 
+ void deferNull() 
+ void deferReturnsNull() 
+ void deferFunctionThrows() 
+ void deferErrorSource() 
+ void errorSupplierNull() 
+ void errorSupplierNormal() 
+ void errorSupplierReturnsNull() 
+ void errorSupplierThrows() 
+ void errorNull() 
+ void errorNormal() 
+ void fromCallableNull() 
+ void fromCallableNormal() 
+ void fromCallableThrows() 
+ void fromFlowableNull() 
+ void fromFlowableEmpty() 
+ void fromFlowableSome() 
+ void fromFlowableError() 
+ void fromObservableNull() 
+ void fromObservableEmpty() 
+ void fromObservableSome() 
+ void fromObservableError() 
+ void fromActionNull() 
+ void fromActionNormal() 
+ void fromActionThrows() 
+ void fromSingleNull() 
+ void fromSingleNormal() 
+ void fromSingleThrows() 
+ void mergeNull() 
+ void mergeEmpty() 
+ void mergeSingleSource() 
+ void mergeSingleSourceThrows() 
+ void mergeMultipleSources() 
+ void mergeMultipleOneThrows() 
+ void mergeMultipleOneIsNull() 
+ void mergeIterableEmpty() 
+ void mergeIterableNull() 
+ void mergeIterableIteratorNull() 
+ void mergeIterableWithNull() 
+ void mergeIterableSingle() 
+ void mergeIterableMany() 
+ void mergeIterableOneThrows() 
+ void mergeIterableManyOneThrows() 
+ void mergeIterableIterableThrows() 
+ void mergeIterableIteratorHasNextThrows() 
+ void mergeIterableIteratorNextThrows() 
+ void mergeObservableEmpty() 
+ void mergeObservableError() 
+ void mergeObservableSingle() 
+ void mergeObservableSingleThrows() 
+ void mergeObservableMany() 
+ void mergeObservableManyOneThrows() 
+ void mergeObservableMaxConcurrent() 
+ void mergeDelayErrorNull() 
+ void mergeDelayErrorEmpty() 
+ void mergeDelayErrorSingleSource() 
+ void mergeDelayErrorSingleSourceThrows() 
+ void mergeDelayErrorMultipleSources() 
+ void mergeDelayErrorMultipleOneThrows() 
+ void mergeDelayErrorMultipleOneIsNull() 
+ void mergeDelayErrorIterableEmpty() 
+ void mergeDelayErrorIterableNull() 
+ void mergeDelayErrorIterableIteratorNull() 
+ void mergeDelayErrorIterableWithNull() 
+ void mergeDelayErrorIterableSingle() 
+ void mergeDelayErrorIterableMany() 
+ void mergeDelayErrorIterableOneThrows() 
+ void mergeDelayErrorIterableManyOneThrows() 
+ void mergeDelayErrorIterableIterableThrows() 
+ void mergeDelayErrorIterableIteratorHasNextThrows() 
+ void mergeDelayErrorIterableIteratorNextThrows() 
+ void mergeDelayErrorObservableEmpty() 
+ void mergeDelayErrorObservableError() 
+ void mergeDelayErrorObservableSingle() 
+ void mergeDelayErrorObservableSingleThrows() 
+ void mergeDelayErrorObservableMany() 
+ void mergeDelayErrorObservableManyOneThrows() 
+ void mergeDelayErrorObservableMaxConcurrent() 
+ void never() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void timer() 
+ void timerNewThread() 
+ void timerTestScheduler() 
+ void timerCancel() 
+ void timerUnitNull() 
+ void timerSchedulerNull() 
+ void usingNormalEager() 
+ Completable apply(Object v) 
+ void accept(Integer d) 
+ void onSubscribe(Disposable d) 
+ void usingNormalLazy() 
+ Completable apply(Integer v) 
+ void usingErrorEager() 
+ void usingErrorLazy() 
+ void usingResourceSupplierNull() 
+ void accept(Object v) 
+ void usingMapperNull() 
+ void usingMapperReturnsNull() 
+ void usingDisposeNull() 
+ void usingResourceThrows() 
+ void usingMapperThrows() 
+ void usingDisposerThrows() 
+ void composeNormal() 
+ void composeNull() 
+ void concatWithNormal() 
+ void concatWithError() 
+ void concatWithNull() 
+ void delayUnitNull() 
+ void delaySchedulerNull() 
+ void delayNormal() 
+ void delayErrorImmediately() 
+ void delayErrorToo() 
+ void doOnCompleteNormal() 
+ void doOnCompleteError() 
+ void doOnCompleteNull() 
+ void doOnCompleteThrows() 
+ void doOnDisposeNormalDoesntCall() 
+ void doOnDisposeErrorDoesntCall() 
+ void doOnDisposeChildCancels() 
+ void doOnDisposeNull() 
+ void doOnDisposeThrows() 
+ void doOnErrorNoError() 
+ void doOnErrorHasError() 
+ void doOnErrorNull() 
+ void doOnErrorThrows() 
+ void doOnSubscribeNormal() 
+ void doOnSubscribeNull() 
+ void doOnSubscribeThrows() 
+ void doOnTerminateNormal() 
+ void doOnTerminateError() 
+ void getNormal() 
+ void getError() 
+ void getTimeout() 
+ void getNullUnit() 
+ void liftNull() 
+ void liftReturnsNull() 
+ CompletableObserver apply(final CompletableObserver v) 
+ void liftOnCompleteError() 
+ void liftOnErrorComplete() 
+ void mergeWithNull() 
+ void mergeWithNormal() 
+ void observeOnNull() 
+ void observeOnNormal() 
+ void observeOnError() 
+ void onErrorComplete() 
+ void onErrorCompleteFalse() 
+ void onErrorCompleteNull() 
+ void onErrorResumeNextNull() 
+ void onErrorResumeNextFunctionReturnsNull() 
+ void onErrorResumeNextFunctionThrows() 
+ void onErrorResumeNextNormal() 
+ void onErrorResumeNextError() 
+ void repeatNormal() 
+ void onSubscribe(final Disposable d) 
+ void repeatError() 
+ void repeat5Times() 
+ void repeat1Time() 
+ void repeat0Time() 
+ void repeatUntilNormal() 
+ boolean getAsBoolean() 
+ void repeatUntilNull() 
+ void repeatWhenNull() 
+ void retryNormal() 
+ void retry5Times() 
+ void retryBiPredicate5Times() 
+ void retryTimes5Error() 
+ void retryTimes5Normal() 
+ void retryNegativeTimes() 
+ void retryPredicateError() 
+ void retryPredicateNull() 
+ void retryPredicate5Times() 
+ boolean test(Throwable e) 
+ void retryWhen5Times() 
+ Publisher<Object> apply(Flowable<? extends Throwable> o) 
+ void subscribe() 
+ void subscribeDispose() 
+ void subscribeTwoCallbacksNormal() 
+ void accept(Throwable e) 
+ void subscribeTwoCallbacksError() 
+ void subscribeTwoCallbacksFirstNull() 
+ void subscribeTwoCallbacksSecondNull() 
+ void subscribeTwoCallbacksCompleteThrows() 
+ void subscribeTwoCallbacksOnErrorThrows() 
+ void subscribeObserverNormal() 
+ void subscribeObserverError() 
+ void subscribeActionNormal() 
+ void subscribeActionError() 
+ void subscribeActionNull() 
+ void subscribeSubscriberNull() 
+ void subscribeObserverNull() 
+ void subscribeCompletableSubscriberNull() 
+ void subscribeSubscriberNormal() 
+ void subscribeSubscriberError() 
+ void subscribeOnNull() 
+ void subscribeOnNormal() 
+ void subscribeOnError() 
+ void timeoutEmitError() 
+ void timeoutSwitchNormal() 
+ void timeoutTimerCancelled() 
+ void timeoutUnitNull() 
+ void timeoutSchedulerNull() 
+ void timeoutOtherNull() 
+ void toNormal() 
+ void accept(Object e) 
+ void toNull() 
+ void toFlowableNormal() 
+ void toFlowableError() 
+ void toObservableNormal() 
+ void toObservableError() 
+ void toSingleSupplierNormal() 
+ void toSingleSupplierError() 
+ void toSingleSupplierNull() 
+ void toSingleSupplierReturnsNull() 
+ void toSingleSupplierThrows() 
+ void toSingleDefaultError() 
+ void toSingleDefaultNormal() 
+ void toSingleDefaultNull() 
+ void unsubscribeOnNormal() 
+ void ambArrayNull() 
+ void ambArrayEmpty() 
+ void ambArraySingleNormal() 
+ void ambArraySingleError() 
+ void ambArrayOneFires() 
+ void ambArrayOneFiresError() 
+ void ambArraySecondFires() 
+ void ambArraySecondFiresError() 
+ void ambMultipleOneIsNull() 
+ void ambIterableEmpty() 
+ void ambIterableNull() 
+ void ambIterableIteratorNull() 
+ void ambIterableWithNull() 
+ void ambIterableSingle() 
+ void ambIterableMany() 
+ void ambIterableOneThrows() 
+ void ambIterableManyOneThrows() 
+ void ambIterableIterableThrows() 
+ void ambIterableIteratorHasNextThrows() 
+ void ambIterableIteratorNextThrows() 
+ void ambWithNull() 
+ void ambWithArrayOneFires() 
+ void ambWithArrayOneFiresError() 
+ void ambWithArraySecondFires() 
+ void ambWithArraySecondFiresError() 
+ void startWithCompletableNormal() 
+ void startWithCompletableError() 
+ void startWithFlowableNormal() 
+ void startWithFlowableError() 
+ void startWithObservableNormal() 
+ void startWithObservableError() 
+ void startWithCompletableNull() 
+ void startWithFlowableNull() 
+ void startWithObservableNull() 
+ void andThen() 
- {static} void expectUncaughtTestException(Action action) 
+ void subscribeOneActionThrowFromOnCompleted() 
+ void subscribeTwoActionsThrowFromOnError() 
+ void accept(Throwable throwable) 
+ void propagateExceptionSubscribeOneAction() 
+ void usingFactoryReturnsNullAndDisposerThrows() 
+ Integer call() 
+ Completable apply(Integer t) 
+ void subscribeReportsUnsubscribedOnError() 
+ void subscribeActionReportsUnsubscribed() 
+ void subscribeActionReportsUnsubscribedAfter() 
+ void subscribeActionReportsUnsubscribedOnError() 
+ void subscribeAction2ReportsUnsubscribed() 
+ void accept(Throwable t) 
+ void subscribeAction2ReportsUnsubscribedOnError() 
+ void andThenSubscribeOn() 
+ void andThenSingleNever() 
+ void andThenSingleError() 
+ void andThenSingleSubscribeOn() 
+ void setUp() 
+ CompletableObserver apply(Completable t1, CompletableObserver t2) 
+ void after() 
+ void testHookCreate() 
+ void doOnCompletedNormal() 
+ void doOnCompletedError() 
+ void doOnCompletedNull() 
+ void doOnCompletedThrows() 
+ void doAfterTerminateNormal() 
+ void doAfterTerminateWithError() 
+ void doAfterTerminateNull() 
+ void subscribeEmptyOnError() 
+ void subscribeOneActionOnError() 
+ void propagateExceptionSubscribeEmpty() 
+ void andThenCompletableNull() 
+ void andThenFlowableNull() 
+ void andThenCompletableNormal() 
+ void andThenCompletableError() 
+ void andThenFlowableNormal() 
+ void andThenFlowableError() 
+ void usingFactoryThrows() 
+ void usingFactoryAndDisposerThrow() 
+ void usingFactoryReturnsNull() 
+ void subscribeReportsUnsubscribed() 
+ void safeOnCompleteThrows() 
+ void onSubscribe(Subscription d) 
+ void safeOnErrorThrows() 
+ void testHookSubscribeStart() 
+ void testHookUnsafeSubscribeStart() 
+ void onStartCalledSafe() 
+ void onStartCalledUnsafeSafe() 
+ void onErrorCompleteFunctionThrows() 
+ void subscribeAction2ReportsUnsubscribedAfter() 
+ void subscribeAction2ReportsUnsubscribedOnErrorAfter() 
+ void safeOnCompleteThrowsRegularSubscriber() 
+ void onNext(Object t) 
+ void safeOnErrorThrowsRegularSubscriber() 
+ void propagateExceptionSubscribeOneActionThrowFromOnSuccess() 
+ void andThenNever() 
+ void andThenError() 
+ void subscribe(Subscriber<? super String> s) 
+ void andThenSingle() 
+ void fromFutureNull() 
+ void fromFutureNormal() 
+ void fromFutureThrows() 
+ void fromRunnableNull() 
+ void fromRunnableNormal() 
+ void fromRunnableThrows() 
+ void doOnErrorNullValue() 
+ void doOnSubscribeNullValue() 
+ void doAfterTerminateNullValue() 
+ void doOnTerminateNullValue() 
+ void doOnCompleteNullValue() 
+ void doOnDisposeNullValue() 
+ void doOnEventNullValue() 
+ void doOnEventComplete() 
+ void doOnEventError() 
+ void subscribeTwoCallbacksDispose() 
 
}
class io.reactivex.completable.CompletableTimerTest {
 + void timer() 
 
}
class io.reactivex.disposables.ActionDisposable {
 # void onDisposed(@NonNull Action value) 
 
}
class io.reactivex.disposables.CompositeDisposable {
 + void dispose() 
+ boolean isDisposed() 
+ boolean add(@NonNull Disposable d) 
+ boolean addAll(@NonNull Disposable... ds) 
+ boolean remove(@NonNull Disposable d) 
+ boolean delete(@NonNull Disposable d) 
+ void clear() 
+ int size() 
 
}
class io.reactivex.disposables.CompositeDisposableTest {
 + void testSuccess() 
+ void run() 
+ void shouldUnsubscribeAll() 
+ void testException() 
+ void testCompositeException() 
+ void testRemoveUnsubscribes() 
+ void testClear() 
+ void testUnsubscribeIdempotence() 
+ void testUnsubscribeIdempotenceConcurrently()
            
+ void testTryRemoveIfNotIn() 
+ void testAddingNullDisposableIllegal() 
+ void initializeVarargs() 
+ void initializeIterable() 
+ void addAll() 
+ void addAfterDisposed() 
+ void delete() 
+ void disposeRace() 
+ void addRace() 
+ void addAllRace() 
+ void removeRace() 
+ void deleteRace() 
+ void clearRace() 
+ void addDisposeRace() 
+ void addAllDisposeRace() 
+ void removeDisposeRace() 
+ void deleteDisposeRace() 
+ void clearDisposeRace() 
+ void sizeDisposeRace() 
+ void disposeThrowsIAE() 
+ void disposeThrowsError() 
+ void disposeThrowsCheckedException() 
+ void disposeThrowsCheckedExceptionSneaky() 
+ boolean isDisposed() 
 
}
class io.reactivex.disposables.Disposable {
  
}s
class io.reactivex.disposables.Disposables {
 + {static} Disposable fromRunnable(@NonNull Runnable run) 
+ {static} Disposable fromAction(@NonNull Action run) 
+ {static} Disposable fromFuture(@NonNull Future<?> future) 
+ {static} Disposable fromFuture(@NonNull Future<?> future, boolean allowInterrupt) 
+ {static} Disposable fromSubscription(@NonNull Subscription subscription) 
+ {static} Disposable empty() 
+ {static} Disposable disposed() 
 
}Test
class io.reactivex.disposables.FutureDisposable {
 + boolean isDisposed() 
+ void dispose() 
    - final boolean allowInterrupt;
 
}
class io.reactivex.disposables.FutureDisposableTest {
 + void normal() 
+ void interruptible() 
+ void normalDone() 
 
}
class io.reactivex.disposables.RunnableDisposable {
 # void onDisposed(@NonNull Runnable value) 
+ String toString() 
 
}
class io.reactivex.disposables.SequentialDisposableTest {
 + void setUp() 
+ void unsubscribingWithoutUnderlyingDoesNothing() 
+ void getDisposableShouldReturnset() 
+ void notDisposedWhenReplaced() 
+ void unsubscribingTwiceDoesUnsubscribeOnce() 
+ void settingSameDisposableTwiceDoesUnsubscribeIt() 
+ void unsubscribingWithSingleUnderlyingUnsubscribes() 
+ void replacingFirstUnderlyingCausesUnsubscription() 
+ void whenUnsubscribingSecondUnderlyingUnsubscribed() 
+ void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() 
+ void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently()
            
+ void concurrentSetDisposableShouldNotInterleave()
            
    - SequentialDisposable serialDisposable;
 
}
class io.reactivex.disposables.SerialDisposable {
 + boolean set(@Nullable Disposable next) 
+ boolean replace(@Nullable Disposable next) 
+ Disposable get() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<Disposable> resource;
 
}
class io.reactivex.disposables.SerialDisposableTests {
 + void setUp() 
+ void unsubscribingWithoutUnderlyingDoesNothing() 
+ void getDisposableShouldReturnset() 
+ void notDisposedWhenReplaced() 
+ void unsubscribingTwiceDoesUnsubscribeOnce() 
+ void settingSameDisposableTwiceDoesUnsubscribeIt() 
+ void unsubscribingWithSingleUnderlyingUnsubscribes() 
+ void replacingFirstUnderlyingCausesUnsubscription() 
+ void whenUnsubscribingSecondUnderlyingUnsubscribed() 
+ void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() 
+ void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently()
            
+ void concurrentSetDisposableShouldNotInterleave()
            
+ void disposeState() 
    - SerialDisposable serialDisposable;
 
}
class io.reactivex.disposables.SubscriptionDisposable {
 # void onDisposed(@NonNull Subscription value) 
 
}
class io.reactivex.exceptions.CompositeException {
 + List<Throwable> getExceptions() 
+ String getMessage() 
+ synchronized Throwable getCause() 
+ void printStackTrace() 
+ void printStackTrace(PrintStream s) 
+ void printStackTrace(PrintWriter s) 
- void printStackTrace(PrintStreamOrWriter s) 
- void appendStackTrace(StringBuilder b, Throwable ex, String prefix) 
~{abstract} void println(Object o)
- List<Throwable> getListOfCauses(Throwable ex) 
+ int size() 
- Throwable getRootCause(Throwable e) 
    - final List<Throwable> exceptions;
    - final String message;
    - Throwable cause;
        - final PrintStream printStream;
        - final PrintWriter printWriter;
 
}
class io.reactivex.exceptions.CompositeException.CompositeExceptionCausalChain
class io.reactivex.exceptions.CompositeExceptionTest {
 - CompositeException getNewCompositeExceptionWithEx123() 
+ void testMultipleWithSameCause() 
+ void testEmptyErrors() 
+ void testCompositeExceptionFromParentThenChild() 
+ void testCompositeExceptionFromChildThenParent() 
+ void testCompositeExceptionFromChildAndComposite() 
+ void testCompositeExceptionFromCompositeAndChild() 
+ void testCompositeExceptionFromTwoDuplicateComposites() 
- {static} void assertNoCircularReferences(Throwable ex) 
- {static} Throwable getRootCause(Throwable ex) 
+ void testNullCollection() 
+ void testNullElement() 
+ void testCompositeExceptionWithUnsupportedInitCause() 
+ void testCompositeExceptionWithNullInitCause() 
+ void messageCollection() 
+ void messageVarargs() 
+ void complexCauses() 
+ void constructorWithNull() 
+ void printStackTrace() 
+ void cyclicRootCause() 
+ Throwable getCause() 
+ void nullRootCause() 
+ void badException() 
+ synchronized Throwable getCause() 
 
}
class io.reactivex.exceptions.Exceptions {
 + {static} RuntimeException propagate(@NonNull Throwable t) 
+ {static} void throwIfFatal(@NonNull Throwable t) 
 
}
class io.reactivex.exceptions.ExceptionsNullTest {
 + void testOnCompleteFailedExceptionNull() 
+ void testOnCompleteFailedExceptionMessageAndNull() 
+ void testOnErrorFailedExceptionNull() 
+ void testOnErrorFailedExceptionMessageAndNull() 
+ void testUnsubscribeFailedExceptionNull() 
+ void testUnsubscribeFailedExceptionMessageAndNull() 
+ void testOnErrorNotImplementedExceptionNull() 
+ void testOnErrorNotImplementedExceptionMessageAndNull() 
+ void testOnErrorThrowableFrom() 
+ void testOnErrorThrowableAddValueAsLastCause() 
 
}
class io.reactivex.exceptions.ExceptionsTest {
 + void constructorShouldBePrivate() 
+ void testOnErrorNotImplementedIsThrown() 
+ void testOnCompletedExceptionIsThrown() 
+ void onError(Throwable e) 
+ void onNext(Object o) 
+ void onSubscribe(Disposable d) 
+ void testStackOverflowWouldOccur() 
+ void onComplete() 
+ void onNext(Integer n) 
+ void testStackOverflowErrorIsThrown() 
+ void onNext(Integer t) 
+ void testThreadDeathIsThrown() 
+ void testOnErrorExceptionIsThrown() 
+ void testOnErrorExceptionIsThrownFromGroupBy() 
+ void onNext(GroupedObservable<Integer, Integer> integerIntegerGroupedObservable) 
+ void testOnErrorExceptionIsThrownFromOnNext() 
+ void onNext(Integer integer) 
+ void testOnErrorExceptionIsThrownFromSubscribe() 
+ void testOnErrorExceptionIsThrownFromUnsafeSubscribe() 
+ void testOnErrorExceptionIsThrownFromSingleDoOnSuccess() 
+ void testOnErrorExceptionIsThrownFromSingleSubscribe() 
+ void testOnErrorExceptionIsThrownFromSingleUnsafeSubscribe() 
+ void onSubscribe(Subscription s) 
+ void onNext(Integer v) 
+ void onNext(Integer value) 
+ void utilityClass() 
+ void manualThrowIfFatal() 
+ void manualPropagate() 
+ void errorNotImplementedNull1() 
+ void errorNotImplementedNull2() 
+ void errorNotImplementedWithCause() 
 
}
class io.reactivex.exceptions.MissingBackpressureException {
  
}
class io.reactivex.exceptions.OnErrorNotImplementedException {
  
}
class io.reactivex.exceptions.OnErrorNotImplementedExceptionTest {
 + void before() 
+ void after() 
+ void flowableSubscribe0() 
+ void flowableSubscribe1() 
+ void flowableForEachWhile() 
+ void flowableBlockingSubscribe1() 
+ void observableSubscribe0() 
+ void observableSubscribe1() 
+ void observableForEachWhile() 
+ void observableBlockingSubscribe1() 
+ void singleSubscribe0() 
+ void singleSubscribe1() 
+ void maybeSubscribe0() 
+ void maybeSubscribe1() 
+ void completableSubscribe0() 
+ void completableSubscribe1() 
 
}
class io.reactivex.exceptions.OnNextValueTest {
 + String toString() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(BadToString badToString) 
+ void onSubscribe(Disposable d) 
+ {static} String stackTraceAsString(Throwable e) 
+ void addOnNextValueExceptionAdded() 
+ void addOnNextValueExceptionNotAddedWithBadString() 
+ void testRenderInteger() 
+ void testRenderByte() 
+ void testRenderBoolean() 
+ void testRenderShort() 
+ void testRenderLong() 
+ void testRenderCharacter() 
+ void testRenderFloat() 
+ void testRenderDouble() 
+ void testRenderVoid() 
        - final boolean throwDuringToString;
 
}
class io.reactivex.exceptions.ProtocolViolationException {
  
}
class io.reactivex.exceptions.TestException {
  
}
class io.reactivex.exceptions.UndeliverableException {
  
}
class io.reactivex.flowable.Burst {
 # void subscribeActual(final Subscriber<? super T> subscriber) 
+ void request(long n) 
+ void cancel() 
+ Flowable<T> error(Throwable e) 
+ Flowable<T> create() 
~    final List<T> items;
~    final Throwable error;
        - final List<T> items;
        - Throwable error;
 
}
class io.reactivex.flowable.FlowableBackpressureTests {
 + void request(long n) 
+ void cancel() 
+ void doAfterTest() 
+ void testObserveOn() 
+ void testObserveOnWithSlowConsumer() 
+ void testMergeSync() 
+ void testMergeAsync() 
+ void testMergeAsyncThenObserveOnLoop() 
+ void testMergeAsyncThenObserveOn() 
+ void testFlatMapSync() 
+ void testFlatMapAsync() 
+ void testZipSync() 
+ void testZipAsync() 
+ void testSubscribeOnScheduling() 
+ void testTakeFilterSkipChainAsync() 
+ void testUserSubscriberUsingRequestSync() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testUserSubscriberUsingRequestAsync() 
+ void testFirehoseFailsAsExpected() 
+ void testFirehoseFailsAsExpectedLoop() 
+ void testOnBackpressureDrop() 
+ void testOnBackpressureDropWithAction() 
+ void accept(Integer v) 
+ void testOnBackpressureDropSynchronous() 
+ void testOnBackpressureDropSynchronousWithAction() 
+ void testOnBackpressureBuffer() 
- {static} Flowable<Integer> incrementingIntegers(final AtomicInteger counter) 
- {static} Flowable<Integer> incrementingIntegers(final AtomicInteger counter, final ConcurrentLinkedQueue<Thread> threadsSeen) 
- {static} Flowable<Integer> firehose(final AtomicInteger counter) 
+ Integer apply(Integer t1) 
        - final AtomicInteger counter;
 
}
class io.reactivex.flowable.FlowableCollectTest {
 + void testCollectToListFlowable() 
+ void accept(List<Integer> list, Integer v) 
+ void testCollectToStringFlowable() 
+ void accept(StringBuilder sb, Integer v) 
+ void testFactoryFailureResultsInErrorEmissionFlowable() 
+ void accept(List<Integer> list, Integer t) 
+ void testCollectorFailureDoesNotResultInTwoErrorEmissionsFlowable() 
+ void testCollectorFailureDoesNotResultInErrorAndCompletedEmissionsFlowable() 
+ void testCollectorFailureDoesNotResultInErrorAndOnNextEmissionsFlowable() 
+ void collectIntoFlowable() 
+ void testCollectToList() 
+ void testCollectToString() 
+ void testFactoryFailureResultsInErrorEmission() 
+ void testCollectorFailureDoesNotResultInTwoErrorEmissions() 
+ void testCollectorFailureDoesNotResultInErrorAndCompletedEmissions() 
+ void testCollectorFailureDoesNotResultInErrorAndOnNextEmissions() 
+ void collectInto() 
+ void dispose() 
+ void accept(ArrayList<Integer> a, Integer b) 
+ void doubleOnSubscribe() 
+ Single<ArrayList<Integer>> apply(Flowable<Integer> f) 
 
}
class io.reactivex.flowable.FlowableCombineLatestTests {
 + void testCovarianceOfCombineLatest() 
+ ExtendedResult apply(Media m, Rating r) 
+ void accept(Result t1) 
+ void accept(ExtendedResult t1) 
+ void testNullEmitting() 
+ void accept(Boolean aBoolean) 
 
}
class io.reactivex.flowable.FlowableConcatTests {
 + void testConcatSimple() 
+ void testConcatWithFlowableOfFlowable() 
+ void testConcatWithIterableOfFlowable() 
+ void testConcatCovariance() 
+ void testConcatCovariance2() 
+ void testConcatCovariance3() 
+ void testConcatCovariance4() 
 
}
class io.reactivex.flowable.FlowableConversionTest {
 + void subscribe(Subscriber<T> subscriber) 
+ final CylonDetectorObservable<T> beep(Predicate<? super T> predicate) 
+ CylonDetectorObservable<String> DESTROY() 
- {static} void throwOutTheAirlock(Object cylon) 
+ CylonDetectorObservable<R> apply(final Publisher<T> onSubscribe) 
+ CylonDetectorObservable<T> apply(final Publisher<T> onSubscribe) 
+ Flowable<T> apply(final Publisher<T> onSubscribe) 
+ void testConversionBetweenObservableClasses() 
+ void onError(Throwable e) 
+ void onNext(String t) 
+ void accept(Object pv) 
+ boolean test(Object t) 
+ Object apply(Object cylon) 
+ String apply(String a, String n) 
+ void testConvertToConcurrentQueue() 
+ ConcurrentLinkedQueue<Integer> apply(Flowable<Integer> onSubscribe) 
+ void onNext(Integer t) 
        # Publisher<T> onSubscribe;
 
}
class io.reactivex.flowable.FlowableCovarianceTest {
 + void testCovarianceOfFrom() 
+ void testSortedList() 
+ void testGroupByCompose() 
+ void accept(GroupedFlowable<Object, Movie> g) 
+ Publisher<String> apply(GroupedFlowable<Object, Movie> g) 
+ Publisher<Movie> apply(Flowable<Movie> m) 
+ String apply(Object v) 
+ void testCovarianceOfCompose() 
+ void testCovarianceOfCompose2() 
+ void testCovarianceOfCompose3() 
+ void testCovarianceOfCompose4() 
+ void testComposeWithDeltaLogic() 
+ Flowable<Movie> apply(List<List<Movie>> listOfLists) 
+ Publisher<Movie> apply(Flowable<List<Movie>> movieList) 
 
}
class io.reactivex.flowable.FlowableDoAfterNextTest {
 + void testIfFunctionThrowsThatNoMoreEventsAreProcessed() 
 
}
class io.reactivex.flowable.FlowableDoOnTest {
 + void testDoOnEach() 
+ void testDoOnError() 
+ void testDoOnCompleted() 
+ void doOnTerminateError() 
+ void doOnTerminateComplete() 
 
}
class io.reactivex.flowable.FlowableErrorHandlingTests {
 + void testOnNextError() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testOnNextErrorAcrossThread() 
 
}
class io.reactivex.flowable.FlowableEventStream {
 + {static} Flowable<Event> getEventStream(final String type, final int numInstances) 
+ {static} Event randomEvent(String type, int numInstances) 
- {static} int randomIntFrom0to(int max) 
+ void accept(Emitter<Event> s) 
        - final String type;
        - final int numInstances;
        + final String type;
        + final String instanceId;
 
}
class io.reactivex.flowable.FlowableEventStream.Event
class io.reactivex.flowable.FlowableEventStreamTest {
 + void constructorShouldBePrivate() 
 
}
class io.reactivex.flowable.FlowableFuseableTest {
 + void syncRange() 
+ void syncArray() 
+ void syncIterable() 
+ void syncRangeHidden() 
+ void syncArrayHidden() 
+ void syncIterableHidden() 
 
}
class io.reactivex.flowable.FlowableGroupByTests {
 + void testTakeUnsubscribesOnGroupBy() 
+ void accept(GroupedFlowable<Object, Event> v) 
+ void testTakeUnsubscribesOnFlatMapOfGroupBy() 
+ Publisher<Object> apply(GroupedFlowable<Object, Event> g) 
+ void accept(Object v) 
+ void groupsCompleteAsSoonAsMainCompletes() 
+ Flowable<Integer> apply(GroupedFlowable<Integer, Integer> v) 
 
}
class io.reactivex.flowable.FlowableMergeTests {
 + void testCovarianceOfMerge() 
+ void testMergeCovariance() 
+ void testMergeCovariance2() 
+ void testMergeCovariance3() 
+ void testMergeCovariance4() 
 
}
class io.reactivex.flowable.FlowableNotificationTest {
 + void testOnNextIntegerNotificationDoesNotEqualNullNotification() 
+ void testOnNextNullNotificationDoesNotEqualIntegerNotification() 
+ void testOnNextIntegerNotificationsWhenEqual() 
+ void testOnNextIntegerNotificationsWhenNotEqual() 
+ void testOnErrorIntegerNotificationDoesNotEqualNullNotification() 
+ void testOnErrorNullNotificationDoesNotEqualIntegerNotification() 
+ void testOnErrorIntegerNotificationsWhenEqual() 
+ void testOnErrorIntegerNotificationWhenNotEqual() 
 
}
class io.reactivex.flowable.FlowableNullTests {
 + void ambVarargsNull() 
+ void ambVarargsOneIsNull() 
+ void ambIterableNull() 
+ void ambIterableIteratorNull() 
+ void ambIterableOneIsNull() 
+ void combineLatestVarargsNull() 
+ void combineLatestVarargsOneIsNull() 
+ void combineLatestIterableNull() 
+ void combineLatestIterableIteratorNull() 
+ Object apply(Object[] v) 
+ void combineLatestIterableOneIsNull() 
+ void combineLatestVarargsFunctionNull() 
+ void combineLatestVarargsFunctionReturnsNull() 
+ void combineLatestIterableFunctionNull() 
+ void combineLatestIterableFunctionReturnsNull() 
+ void concatIterableNull() 
+ void concatIterableIteratorNull() 
+ void concatIterableOneIsNull() 
+ void concatPublisherNull() 
+ void concatArrayNull() 
+ void concatArrayOneIsNull() 
+ void createNull() 
+ void deferFunctionNull() 
+ void deferFunctionReturnsNull() 
+ void errorFunctionNull() 
+ void errorFunctionReturnsNull() 
+ void errorThrowableNull() 
+ void fromArrayNull() 
+ void fromArrayOneIsNull() 
+ void fromCallableNull() 
+ void fromCallableReturnsNull() 
+ void fromFutureNull() 
+ void fromFutureReturnsNull() 
+ void fromFutureTimedFutureNull() 
+ void fromFutureTimedUnitNull() 
+ void fromFutureTimedSchedulerNull() 
+ void fromFutureTimedReturnsNull() 
+ void fromFutureSchedulerNull() 
+ void fromIterableNull() 
+ void fromIterableIteratorNull() 
+ void fromIterableValueNull() 
+ void fromPublisherNull() 
+ void generateConsumerNull() 
+ void generateConsumerEmitsNull() 
+ void generateStateConsumerInitialStateNull() 
+ void generateStateFunctionInitialStateNull() 
+ void generateStateConsumerNull() 
+ void generateConsumerStateNullAllowed() 
+ Integer call() 
+ void generateFunctionStateNullAllowed() 
+ Object apply(Object s, Emitter<Object> o) 
+ void generateConsumerDisposeNull() 
+ void generateFunctionDisposeNull() 
+ void intervalUnitNull() 
+ void intervalSchedulerNull() 
+ void intervalPeriodUnitNull() 
+ void intervalPeriodSchedulerNull() 
+ void intervalRangeUnitNull() 
+ void intervalRangeSchedulerNull() 
+ void justNull() 
+ void mergeIterableNull() 
+ void mergeIterableIteratorNull() 
+ void mergeIterableOneIsNull() 
+ void mergeArrayNull() 
+ void mergeArrayOneIsNull() 
+ void mergeDelayErrorIterableNull() 
+ void mergeDelayErrorIterableIteratorNull() 
+ void mergeDelayErrorIterableOneIsNull() 
+ void mergeDelayErrorArrayNull() 
+ void mergeDelayErrorArrayOneIsNull() 
+ void sequenceEqualFirstNull() 
+ void sequenceEqualSecondNull() 
+ void sequenceEqualComparatorNull() 
+ void switchOnNextNull() 
+ void timerUnitNull() 
+ void timerSchedulerNull() 
+ void usingResourceSupplierNull() 
+ void usingFlowableSupplierNull() 
+ void usingFlowableSupplierReturnsNull() 
+ Publisher<Object> apply(Object d) 
+ void usingDisposeNull() 
+ Publisher<Integer> apply(Object d) 
+ void zipIterableNull() 
+ void zipIterableIteratorNull() 
+ void zipIterableFunctionNull() 
+ void zipIterableFunctionReturnsNull() 
+ void zipPublisherNull() 
+ void zipPublisherFunctionNull() 
+ void zipPublisherFunctionReturnsNull() 
+ void zipIterable2Null() 
+ void zipIterable2IteratorNull() 
+ Object apply(Object[] a) 
+ void zipIterable2FunctionNull() 
+ void zipIterable2FunctionReturnsNull() 
+ void allPredicateNull() 
+ void ambWithNull() 
+ void anyPredicateNull() 
+ void bufferSupplierNull() 
+ void bufferSupplierReturnsNull() 
+ void bufferTimedUnitNull() 
+ void bufferTimedSchedulerNull() 
+ void bufferTimedSupplierNull() 
+ void bufferTimedSupplierReturnsNull() 
+ void bufferOpenCloseOpenNull() 
+ void bufferOpenCloseCloseNull() 
+ void bufferOpenCloseCloseReturnsNull() 
+ void bufferBoundaryNull() 
+ void bufferBoundarySupplierNull() 
+ void bufferBoundarySupplierReturnsNull() 
+ void bufferBoundarySupplier2Null() 
+ void bufferBoundarySupplier2ReturnsNull() 
+ void bufferBoundarySupplier2SupplierNull() 
+ void bufferBoundarySupplier2SupplierReturnsNull() 
+ Collection<Integer> call() 
+ void castNull() 
+ void collectInitialSupplierNull() 
+ void collectInitialSupplierReturnsNull() 
+ void accept(Object a, Integer b) 
+ void collectInitialCollectorNull() 
+ void collectIntoInitialNull() 
+ void collectIntoCollectorNull() 
+ void composeNull() 
+ void concatMapNull() 
+ void concatMapReturnsNull() 
+ void concatMapIterableNull() 
+ void concatMapIterableReturnNull() 
+ void concatMapIterableIteratorNull() 
+ void concatWithNull() 
+ void containsNull() 
+ void debounceFunctionNull() 
+ void debounceFunctionReturnsNull() 
+ void debounceTimedUnitNull() 
+ void debounceTimedSchedulerNull() 
+ void defaultIfEmptyNull() 
+ void delayWithFunctionNull() 
+ void delayWithFunctionReturnsNull() 
+ void delayTimedUnitNull() 
+ void delayTimedSchedulerNull() 
+ void delaySubscriptionTimedUnitNull() 
+ void delaySubscriptionTimedSchedulerNull() 
+ void delaySubscriptionSupplierNull() 
+ void delaySubscriptionFunctionNull() 
+ void delayBothInitialSupplierNull() 
+ void delayBothInitialSupplierReturnsNull() 
+ void delayBothItemSupplierNull() 
+ void delayBothItemSupplierReturnsNull() 
+ void distinctFunctionNull() 
+ void distinctSupplierNull() 
+ void distinctSupplierReturnsNull() 
+ Collection<Object> call() 
+ void distinctFunctionReturnsNull() 
+ void distinctUntilChangedFunctionNull() 
+ void distinctUntilChangedBiPredicateNull() 
+ void distinctUntilChangedFunctionReturnsNull() 
+ void doOnCancelNull() 
+ void doOnCompleteNull() 
+ void doOnEachSupplierNull() 
+ void doOnEachSubscriberNull() 
+ void doOnErrorNull() 
+ void doOnLifecycleOnSubscribeNull() 
+ void run() 
+ void doOnLifecycleOnRequestNull() 
+ void doOnLifecycleOnCancelNull() 
+ void accept(long v) 
+ void doOnNextNull() 
+ void doOnRequestNull() 
+ void doOnSubscribeNull() 
+ void doOnTerminatedNull() 
+ void elementAtNull() 
+ void filterNull() 
+ void doAfterTerminateNull() 
+ void firstNull() 
+ void flatMapNull() 
+ void flatMapFunctionReturnsNull() 
+ void flatMapNotificationOnNextNull() 
+ Publisher<Integer> call() 
+ void flatMapNotificationOnNextReturnsNull() 
+ Publisher<Integer> apply(Throwable e) 
+ void flatMapNotificationOnErrorNull() 
+ void flatMapNotificationOnErrorReturnsNull() 
+ void flatMapNotificationOnCompleteNull() 
+ void flatMapNotificationOnCompleteReturnsNull() 
+ void flatMapCombinerMapperNull() 
+ void flatMapCombinerMapperReturnsNull() 
+ Object apply(Integer a, Object b) 
+ void flatMapCombinerCombinerNull() 
+ void flatMapCombinerCombinerReturnsNull() 
+ Object apply(Integer a, Integer b) 
+ void flatMapIterableMapperNull() 
+ void flatMapIterableMapperReturnsNull() 
+ void flatMapIterableMapperIteratorNull() 
+ void flatMapIterableMapperIterableOneNull() 
+ void flatMapIterableCombinerNull() 
+ void flatMapIterableCombinerReturnsNull() 
+ void forEachNull() 
+ void forEachWhileNull() 
+ void forEachWhileOnErrorNull() 
+ void forEachWhileOnCompleteNull() 
+ void accept(Throwable e) 
+ void groupByNull() 
+ void groupByKeyNull() 
+ void groupByValueNull() 
+ void groupByValueReturnsNull() 
+ Object apply(Integer v) 
+ void lastNull() 
+ void liftNull() 
+ void liftReturnsNull() 
+ void mapNull() 
+ void mapReturnsNull() 
+ void mergeWithNull() 
+ void observeOnNull() 
+ void ofTypeNull() 
+ void onBackpressureBufferOverflowNull() 
+ void onBackpressureDropActionNull() 
+ void onErrorResumeNextFunctionNull() 
+ void onErrorResumeNextFunctionReturnsNull() 
+ void onErrorResumeNextPublisherNull() 
+ void onErrorReturnFunctionNull() 
+ void onErrorReturnValueNull() 
+ void onErrorReturnFunctionReturnsNull() 
+ void onExceptionResumeNext() 
+ void publishFunctionNull() 
+ void publishFunctionReturnsNull() 
+ void reduceFunctionNull() 
+ void reduceFunctionReturnsNull() 
+ void reduceSeedNull() 
+ void reduceSeedFunctionNull() 
+ void reduceSeedFunctionReturnsNull() 
+ void reduceWithSeedNull() 
+ void reduceWithSeedReturnsNull() 
+ Object apply(Object a, Integer b) 
+ void repeatUntilNull() 
+ void repeatWhenNull() 
+ void repeatWhenFunctionReturnsNull() 
+ void replaySelectorNull() 
+ void replaySelectorReturnsNull() 
+ void replayBoundedSelectorNull() 
+ void replayBoundedSelectorReturnsNull() 
+ void replaySchedulerNull() 
+ void replayBoundedUnitNull() 
+ void replayBoundedSchedulerNull() 
+ void replayTimeBoundedSelectorNull() 
+ void replayTimeBoundedSelectorReturnsNull() 
+ void replaySelectorTimeBoundedUnitNull() 
+ void replaySelectorTimeBoundedSchedulerNull() 
+ void replayTimeSizeBoundedUnitNull() 
+ void replayTimeSizeBoundedSchedulerNull() 
+ void replayBufferSchedulerNull() 
+ void replayTimeBoundedUnitNull() 
+ void replayTimeBoundedSchedulerNull() 
+ void retryFunctionNull() 
+ void retryCountFunctionNull() 
+ void retryPredicateNull() 
+ void retryWhenFunctionNull() 
+ void retryWhenFunctionReturnsNull() 
+ void retryUntil() 
+ void safeSubscribeNull() 
+ void sampleUnitNull() 
+ void sampleSchedulerNull() 
+ void samplePublisherNull() 
+ void scanFunctionNull() 
+ void scanFunctionReturnsNull() 
+ void scanSeedNull() 
+ void scanSeedFunctionNull() 
+ void scanSeedFunctionReturnsNull() 
+ void scanSeedSupplierNull() 
+ void scanSeedSupplierReturnsNull() 
+ void scanSeedSupplierFunctionNull() 
+ void scanSeedSupplierFunctionReturnsNull() 
+ void singleNull() 
+ void skipTimedUnitNull() 
+ void skipTimedSchedulerNull() 
+ void skipLastTimedUnitNull() 
+ void skipLastTimedSchedulerNull() 
+ void skipUntilNull() 
+ void skipWhileNull() 
+ void startWithIterableNull() 
+ void startWithIterableIteratorNull() 
+ void startWithIterableOneNull() 
+ void startWithSingleNull() 
+ void startWithPublisherNull() 
+ void startWithArrayNull() 
+ void startWithArrayOneNull() 
+ void subscribeOnNextNull() 
+ void subscribeOnErrorNull() 
+ void subscribeOnCompleteNull() 
+ void subscribeOnSubscribeNull() 
+ void subscribeNull() 
+ void subscribeNull2() 
+ void subscribeOnNull() 
+ void switchIfEmptyNull() 
+ void switchMapNull() 
+ void switchMapFunctionReturnsNull() 
+ void takeTimedUnitNull() 
+ void takeTimedSchedulerNull() 
+ void takeLastTimedUnitNull() 
+ void takeLastSizeTimedUnitNull() 
+ void takeLastTimedSchedulerNull() 
+ void takeLastSizeTimedSchedulerNull() 
+ void takeUntilPredicateNull() 
+ void takeUntilPublisherNull() 
+ void takeWhileNull() 
+ void throttleFirstUnitNull() 
+ void throttleFirstSchedulerNull() 
+ void throttleLastUnitNull() 
+ void throttleLastSchedulerNull() 
+ void throttleWithTimeoutUnitNull() 
+ void throttleWithTimeoutSchedulerNull() 
+ void timeIntervalUnitNull() 
+ void timeIntervalSchedulerNull() 
+ void timeoutSelectorNull() 
+ void timeoutSelectorReturnsNull() 
+ void timeoutSelectorOtherNull() 
+ void timeoutUnitNull() 
+ void timeouOtherNull() 
+ void timeouSchedulerNull() 
+ void timeoutFirstNull() 
+ void timeoutFirstItemNull() 
+ void timeoutFirstItemReturnsNull() 
+ void timestampUnitNull() 
+ void timestampSchedulerNull() 
+ void toNull() 
+ void toListNull() 
+ void toListSupplierReturnsNull() 
+ void toListSupplierReturnsNullSingle() 
+ void toSortedListNull() 
+ void toMapKeyNullAllowed() 
+ void toMapValueNull() 
+ void toMapValueSelectorReturnsNull() 
+ void toMapMapSupplierNull() 
+ void toMapMapSupplierReturnsNull() 
+ void toMultimapKeyNull() 
+ void toMultimapValueNull() 
+ void toMultiMapValueSelectorReturnsNullAllowed() 
+ void toMultimapMapMapSupplierNull() 
+ void toMultimapMapSupplierReturnsNull() 
+ void toMultimapMapMapCollectionSupplierNull() 
+ Integer apply(Integer v) 
+ void toMultimapMapCollectionSupplierReturnsNull() 
+ Collection<Integer> apply(Integer v) 
+ void unsubscribeOnNull() 
+ void windowTimedUnitNull() 
+ void windowSizeTimedUnitNull() 
+ void windowTimedSchedulerNull() 
+ void windowSizeTimedSchedulerNull() 
+ void windowBoundaryNull() 
+ void windowOpenCloseOpenNull() 
+ void windowOpenCloseCloseNull() 
+ void windowOpenCloseCloseReturnsNull() 
+ void windowBoundarySupplierNull() 
+ void windowBoundarySupplierReturnsNull() 
+ void withLatestFromOtherNull() 
+ void withLatestFromCombinerNull() 
+ void withLatestFromCombinerReturnsNull() 
+ void zipWithIterableNull() 
+ void zipWithIterableCombinerNull() 
+ void zipWithIterableCombinerReturnsNull() 
+ void zipWithIterableIteratorNull() 
+ void zipWithIterableOneIsNull() 
+ void zipWithPublisherNull() 
+ void zipWithCombinerNull() 
+ void zipWithCombinerReturnsNull() 
+ void asyncSubjectOnNextNull() 
+ void asyncSubjectOnErrorNull() 
+ void behaviorSubjectOnNextNull() 
+ void behaviorSubjectOnErrorNull() 
+ void publishSubjectOnNextNull() 
+ void publishSubjectOnErrorNull() 
+ void replaycSubjectOnNextNull() 
+ void replaySubjectOnErrorNull() 
+ void serializedcSubjectOnNextNull() 
+ void serializedSubjectOnErrorNull() 
+ void doOnLifecycleOnDisposeNull() 
+ void zipWithFlowableNull() 
+ void unsafeSubscribeNull() 
+ void combineLatestDelayErrorIterableFunctionReturnsNull() 
+ void combineLatestDelayErrorIterableFunctionNull() 
+ void combineLatestDelayErrorVarargsFunctionNull() 
+ void zipFlowableNull() 
+ void zipFlowableFunctionNull() 
+ void zipFlowableFunctionReturnsNull() 
+ void concatFlowableNull() 
+ void combineLatestDelayErrorVarargsNull() 
+ void combineLatestDelayErrorVarargsOneIsNull() 
+ void combineLatestDelayErrorIterableNull() 
+ void combineLatestDelayErrorIterableIteratorNull() 
+ void doOnDisposeNull() 
+ void combineLatestDelayErrorIterableOneIsNull() 
+ void takeUntilFlowableNull() 
+ void startWithFlowableNull() 
+ void delaySubscriptionOtherNull() 
+ void sampleFlowableNull() 
+ void onErrorResumeNextFlowableNull() 
+ void combineLatestDelayErrorVarargsFunctionReturnsNull() 
 
}
class io.reactivex.flowable.FlowableReduceTests {
 + void reduceIntsFlowable() 
+ void reduceWithObjectsFlowable() 
+ Movie apply(Movie t1, Movie t2) 
+ void reduceWithCovariantObjectsFlowable() 
+ void reduceInts() 
+ void reduceWithObjects() 
+ void reduceWithCovariantObjects() 
+ void reduceCovariance() 
+ void libraryFunctionActingOnMovieObservables(Flowable<Movie> obs) 
 
}
class io.reactivex.flowable.FlowableStartWithTests {
 + void startWith1() 
+ void startWithIterable() 
+ void startWithObservable() 
+ void startWithEmpty() 
 
}
class io.reactivex.flowable.FlowableSubscriberTest {
 + void testRequestFromFinalSubscribeWithRequestValue() 
+ void cancel() 
+ void testRequestFromFinalSubscribeWithoutRequestValue() 
+ void testRequestFromChainedOperator() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String t) 
+ void request(long n) 
+ void testRequestFromDecoupledOperator() 
+ void testRequestFromDecoupledOperatorThatRequestsN() 
# void onStart() 
+ void testRequestToFlowable() 
+ void testRequestThroughMap() 
+ void testRequestThroughTakeThatReducesRequest() 
+ void testRequestThroughTakeWhereRequestIsSmallerThanTake() 
+ void testOnStartCalledOnceViaSubscribe() 
+ void onNext(Integer t) 
+ void testOnStartCalledOnceViaUnsafeSubscribe() 
+ void testOnStartCalledOnceViaLift() 
+ void testNegativeRequestThrowsIllegalArgumentException() 
+ void testOnStartRequestsAreAdditive() 
+ void testOnStartRequestsAreAdditiveAndOverflowBecomesMaxValue() 
+ void forEachWhile() 
+ void doubleSubscribe() 
+ void suppressAfterCompleteEvents() 
+ void accept(Throwable e) 
+ void run() 
+ void onNextCrashes() 
+ void onErrorThrows() 
+ void onCompleteThrows() 
+ void subscribeConsumerConsumerWithError() 
+ void methodTestCancelled() 
+ void safeSubscriberAlreadySafe() 
+ void methodTestNoCancel() 
+ void subscribeConsumerConsumer() 
+ void pluginNull() 
# void subscribeActual(Subscriber<? super Integer> s) 
+ void subscribeActualThrows() 
 
}
class io.reactivex.flowable.FlowableTests {
 + boolean test(Integer v) 
+ void before() 
+ void fromArray() 
+ void fromIterable() 
+ void fromArityArgs3() 
+ void fromArityArgs1() 
+ void testCreate() 
+ void testCountAFewItemsFlowable() 
+ void testCountZeroItemsFlowable() 
+ void testCountErrorFlowable() 
+ void testCountAFewItems() 
+ void testCountZeroItems() 
+ void testCountError() 
+ void testTakeFirstWithPredicateOfSome() 
+ void testTakeFirstWithPredicateOfNoneMatchingThePredicate() 
+ void testTakeFirstOfSome() 
+ void testTakeFirstOfNone() 
+ void testFirstOfNoneFlowable() 
+ void testFirstWithPredicateOfNoneMatchingThePredicateFlowable() 
+ void testFirstOfNone() 
+ void testFirstWithPredicateOfNoneMatchingThePredicate() 
+ void testReduce() 
+ void testReduceWithEmptyObservable() 
+ void testReduceWithEmptyObservableAndSeed() 
+ void testReduceWithInitialValue() 
+ void testOnSubscribeFails() 
+ void testMaterializeDematerializeChaining() 
+ void testCustomObservableWithErrorInObserverAsynchronous() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void testCustomObservableWithErrorInObserverSynchronous() 
+ void testCustomObservableWithErrorInObservableSynchronous() 
+ void onComplete() 
+ void testPublishLast() 
+ void accept(String value) 
+ void testReplay() 
+ void accept(String v) 
+ void testCache() 
+ void testCacheWithCapacity() 
+ void testErrorThrownWithoutErrorHandlerSynchronous() 
+ void testErrorThrownWithoutErrorHandlerAsynchronous() 
+ void testTakeWithErrorInObserver() 
+ void testOfType() 
+ void testOfTypeWithPolymorphism() 
+ void testContainsFlowable() 
+ void testContainsWithInexistenceFlowable() 
+ void testContainsWithNullFlowable() 
+ void testContainsWithEmptyObservableFlowable() 
+ void testContains() 
+ void testContainsWithInexistence() 
+ void testContainsWithNull() 
+ void testContainsWithEmptyObservable() 
+ void testIgnoreElementsFlowable() 
+ void testIgnoreElements() 
+ void testJustWithScheduler() 
+ void testStartWithWithScheduler() 
+ void testRangeWithScheduler() 
+ void testMergeWith() 
+ void testConcatWith() 
+ void testAmbWith() 
+ void testSubscribeWithoutOnError() 
+ void testTakeWhileToList() 
+ void accept(List<Boolean> booleans) 
+ void testCompose() 
+ void testErrorThrownIssue1685() 
+ void testEmptyIdentity() 
+ void testEmptyIsEmpty() 
+ void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain() 
+ void testForEachWithError() 
+ void testForEachWithNull() 
+ void testExtend() 
+ void toObservableEmpty() 
+ void toObservableJust() 
+ void toObservableRange() 
+ void toObservableError() 
+ void zipIterableObject() 
+ void combineLatestObject() 
 
}
class io.reactivex.flowable.FlowableThrottleLastTests {
 + void testThrottle() 
 
}
class io.reactivex.flowable.FlowableThrottleWithTimeoutTests {
 + void testThrottle() 
+ void throttleFirstDefaultScheduler() 
 
}
class io.reactivex.flowable.FlowableWindowTests {
 + void testWindow() 
+ void accept(List<Integer> xs) 
 
}
class io.reactivex.flowable.FlowableZipTests {
 + void testZipObservableOfObservables() 
+ void accept(HashMap<String, String> v) 
+ void testCovarianceOfZip() 
+ void nonBlockingObservable() 
+ ExtendedResult apply(Media m, Rating r) 
+ void accept(Result t1) 
+ void accept(ExtendedResult t1) 
+ void zipWithDelayError() 
+ void zipWithDelayErrorBufferSize() 
 
}
class io.reactivex.internal.SubscribeWithTest {
 + void withFlowable() 
+ void withObservable() 
+ void onSubscribe(Disposable d) 
+ void onComplete() 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void withSingle() 
+ void withCompletable() 
 
}
class io.reactivex.internal.disposables.ArrayCompositeDisposable {
 + boolean setResource(int index, Disposable resource) 
+ Disposable replaceResource(int index, Disposable resource) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.disposables.ArrayCompositeDisposableTest {
 + void normal() 
+ void disposeRace() 
+ void replaceRace() 
+ void setRace() 
 
}
class io.reactivex.internal.disposables.CancellableDisposable {
 + boolean isDisposed() 
+ void dispose() 
 
}
class io.reactivex.internal.disposables.CancellableDisposableTest {
 + void normal() 
+ void cancelThrows() 
+ void disposeRace() 
+ void run() 
 
}
class io.reactivex.internal.disposables.DisposableHelper {
 + {static} boolean isDisposed(Disposable d) 
+ {static} boolean set(AtomicReference<Disposable> field, Disposable d) 
+ {static} boolean setOnce(AtomicReference<Disposable> field, Disposable d) 
+ {static} boolean replace(AtomicReference<Disposable> field, Disposable d) 
+ {static} boolean dispose(AtomicReference<Disposable> field) 
+ {static} boolean validate(Disposable current, Disposable next) 
+ {static} void reportDisposableSet() 
+ {static} boolean trySet(AtomicReference<Disposable> field, Disposable d) 
+ void dispose() 
+ boolean isDisposed() 
 
}Test
class io.reactivex.internal.disposables.EmptyDisposable {
 + void dispose() 
+ boolean isDisposed() 
+ {static} void complete(Observer<?> s) 
+ {static} void complete(MaybeObserver<?> s) 
+ {static} void error(Throwable e, Observer<?> s) 
+ {static} void complete(CompletableObserver s) 
+ {static} void error(Throwable e, CompletableObserver s) 
+ {static} void error(Throwable e, SingleObserver<?> s) 
+ {static} void error(Throwable e, MaybeObserver<?> s) 
+ boolean offer(Object value) 
+ boolean offer(Object v1, Object v2) 
+ Object poll() 
+ boolean isEmpty() 
+ void clear() 
+ int requestFusion(int mode) 
 
}Test
class io.reactivex.internal.disposables.FullArbiterPad1
class io.reactivex.internal.disposables.ListCompositeDisposable {
 + void dispose() 
+ boolean isDisposed() 
+ boolean add(Disposable d) 
+ boolean addAll(Disposable... ds) 
+ boolean remove(Disposable d) 
+ boolean delete(Disposable d) 
+ void clear() 
 
}
class io.reactivex.internal.disposables.ListCompositeDisposableTest {
 + void constructorAndAddVarargs() 
+ void constructorIterable() 
+ void empty() 
+ void afterDispose() 
+ void disposeThrows() 
+ boolean isDisposed() 
+ void remove() 
+ void disposeRace() 
+ void addRace() 
+ void addAllRace() 
+ void removeRace() 
+ void deleteRace() 
+ void clearRace() 
+ void addDisposeRace() 
+ void run() 
+ void addAllDisposeRace() 
+ void removeDisposeRace() 
+ void deleteDisposeRace() 
+ void clearDisposeRace() 
 
}
class io.reactivex.internal.disposables.ObserverFullArbiter {
 + void dispose() 
+ boolean isDisposed() 
+ boolean setDisposable(Disposable s) 
+ boolean onNext(T value, Disposable s) 
+ void onError(Throwable value, Disposable s) 
+ void onComplete(Disposable s) 
~    final SpscLinkedArrayQueue<Object> queue;
 
}
class io.reactivex.internal.disposables.ObserverFullArbiterTest {
 + void setSubscriptionAfterCancel() 
+ void cancelAfterPoll() 
+ void errorAfterCancel() 
+ void cancelAfterError() 
+ void offerDifferentSubscription() 
+ void dontEnterDrain() 
 
}
class io.reactivex.internal.disposables.SequentialDisposable {
 + boolean update(Disposable next) 
+ boolean replace(Disposable next) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.functions.Functions {
 + void run() 
+ {static} Action futureAction(Future<?> future) 
+ U call() 
+ U apply(T t) 
+ List<T> call() 
+ boolean test(T t) 
+ Set<Object> call() 
+ void accept(T v) 
+ void accept(Throwable v) 
+ void accept(T t) 
+ Timed<T> apply(T t) 
+ void accept(Map<K, T> m, T t) 
+ void accept(Map<K, V> m, T t) 
+ void accept(Map<K, Collection<V>> m, T t) 
+ int compare(Object o1, Object o2) 
+ List<T> apply(List<T> v) 
+ R apply(Object[] a) 
+ Object apply(Object v) 
+ String toString() 
+ void accept(Object v) 
+ void accept(Throwable error) 
+ void accept(long v) 
+ boolean test(Object o) 
+ Object call() 
+ int compare(Object a, Object b) 
+ void accept(Subscription t) 
~        final U value;
~        final Class<U> clazz;
~        final int capacity;
~        final T value;
~        final Action action;
~        final BooleanSupplier supplier;
~        final TimeUnit unit;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.functions.FunctionsTest {
 + void utilityClass() 
+ void hashSetCallableEnum() 
+ void naturalComparatorEnum() 
+ void booleanSupplierPredicateReverse() 
+ boolean getAsBoolean() 
+ void toFunction2() 
+ void toFunction3() 
+ void toFunction4() 
+ void toFunction5() 
+ void toFunction6() 
+ void toFunction7() 
+ void toFunction8() 
+ void toFunction9() 
+ void biFunctionFail() 
+ void function3Fail() 
+ void function4Fail() 
+ void function5Fail() 
+ void function6Fail() 
+ void function7Fail() 
+ void function8Fail() 
+ void function9Fail() 
+ void identityFunctionToString() 
+ void emptyActionToString() 
+ void emptyRunnableToString() 
+ void emptyConsumerToString() 
+ void errorConsumerEmpty() 
 
}
class io.reactivex.internal.functions.ObjectHelper {
 + {static} boolean equals(Object o1, Object o2) 
+ {static} int hashCode(Object o) 
+ {static} int compare(int v1, int v2) 
+ {static} int compare(long v1, long v2) 
+ {static} int verifyPositive(int value, String paramName) 
+ {static} long verifyPositive(long value, String paramName) 
+ boolean test(Object o1, Object o2) 
 
}
class io.reactivex.internal.functions.ObjectHelperTest {
 + void utilityClass() 
+ void hashCodeOf() 
+ void verifyPositiveInt() 
+ void verifyPositiveLong() 
+ void verifyPositiveIntFail() 
+ void verifyPositiveLongFail() 
+ void compare() 
 
}
class io.reactivex.internal.observers.BasicFuseableObserverTest {
 + void offer() 
+ int requestFusion(int mode) 
+ void onNext(Integer value) 
# boolean beforeDownstream() 
+ void offer2() 
 
}
class io.reactivex.internal.observers.BasicQueueDisposableTest {
 + boolean isDisposed() 
+ void dispose() 
+ Integer poll() 
+ boolean isEmpty() 
+ void clear() 
+ int requestFusion(int mode) 
+ void offer() 
+ void offer2() 
 
}
class io.reactivex.internal.observers.BiConsumerSingleObserver {
 + void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.observers.BlockingFirstObserver {
 + void onNext(T t) 
+ void onError(Throwable t) 
 
}
class io.reactivex.internal.observers.BlockingLastObserver {
 + void onNext(T t) 
+ void onError(Throwable t) 
 
}
class io.reactivex.internal.observers.BlockingMultiObserver {
 + void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ T blockingGet() 
+ T blockingGet(T defaultValue) 
+ Throwable blockingGetError() 
+ Throwable blockingGetError(long timeout, TimeUnit unit) 
+ boolean blockingAwait(long timeout, TimeUnit unit) 
 
}
class io.reactivex.internal.observers.BlockingObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Queue<Object> queue;
 
}
class io.reactivex.internal.observers.CallbackCompletableObserver {
 + void accept(Throwable e) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void dispose() 
+ boolean isDisposed() 
~    final Action onComplete;
 
}
class io.reactivex.internal.observers.ConsumerSingleObserver {
 + void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.observers.CountDownLatch
class io.reactivex.internal.observers.DeferredScalarDisposable {
 + final int requestFusion(int mode) 
+ final void complete(T value) 
+ final void error(Throwable t) 
+ final void complete() 
+ final T poll() 
+ final boolean isEmpty() 
+ final void clear() 
+ void dispose() 
+ final boolean tryDispose() 
+ final boolean isDisposed() 
    # T value;
 
}
class io.reactivex.internal.observers.DeferredScalarObserverTest {
 + void onNext(Integer value) 
+ void normal() 
+ void error() 
+ void complete() 
+ void dispose() 
+ void fused() 
+ void fusedReject() 
+ void nonfusedTerminateMore() 
+ void nonfusedError() 
+ void fusedTerminateMore() 
+ void fusedError() 
+ void disposed() 
+ void disposedAfterOnNext() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void fusedEmpty() 
+ void nonfusedEmpty() 
+ void customFusion() 
+ void customFusionClear() 
+ void offerThrow() 
+ void customFusionDontConsume() 
 
}
class io.reactivex.internal.observers.DisposableLambdaObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Action onDispose;
 
}
class io.reactivex.internal.observers.EmptyCompletableObserver {
 + void dispose() 
+ boolean isDisposed() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
 
}
class io.reactivex.internal.observers.ForEachWhileObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Action onComplete;
 
}
class io.reactivex.internal.observers.FullArbiterObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObserverFullArbiter<T> arbiter;
 
}
class io.reactivex.internal.observers.FutureObserver {
 + boolean cancel(boolean mayInterruptIfRunning) 
+ boolean isCancelled() 
+ boolean isDone() 
+ T get() 
+ T get(long timeout, TimeUnit unit) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<Disposable> s;
 
}
class io.reactivex.internal.observers.FutureObserverTest {
 + void before() 
+ void cancel2() 
+ void cancel() 
+ void onError() 
+ void onNext() 
+ void onSubscribe() 
+ void cancelRace() 
+ void await() 
+ void onErrorCancelRace() 
+ void run() 
+ void onCompleteCancelRace() 
+ void onErrorOnComplete() 
+ void onCompleteOnError() 
+ void cancelOnError() 
+ void cancelOnComplete() 
+ void onNextThenOnCompleteTwice() 
+ void getInterrupted() 
+ void completeAsync() 
 
}
class io.reactivex.internal.observers.FutureSingleObserver {
 + boolean cancel(boolean mayInterruptIfRunning) 
+ boolean isCancelled() 
+ boolean isDone() 
+ T get() 
+ T get(long timeout, TimeUnit unit) 
+ void onSubscribe(Disposable s) 
+ void onSuccess(T t) 
+ void onError(Throwable t) 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<Disposable> s;
 
}
class io.reactivex.internal.observers.FutureSingleObserverTest {
 + void cancel() 
+ void cancelRace() 
+ void timeout() 
+ void dispose() 
+ void errorGetWithTimeout() 
+ void normalGetWitHTimeout() 
+ void getAwait() 
+ void onSuccessCancelRace() 
+ void run() 
+ void onErrorCancelRace() 
 
}
class io.reactivex.internal.observers.InnerQueuedObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean isDone() 
+ void setDone() 
+ SimpleQueue<T> queue() 
+ int fusionMode() 
~    final InnerQueuedObserverSupport<T> parent;
~    final int prefetch;
 
}
class io.reactivex.internal.observers.LambdaObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Action onComplete;
 
}
class io.reactivex.internal.observers.LambdaObserverTest {
 + void onSubscribeThrows() 
+ void accept(Throwable e) 
+ void run() 
+ void accept(Disposable s) 
+ void onNextThrows() 
+ void onErrorThrows() 
+ void onCompleteThrows() 
+ void badSourceOnSubscribe() 
+ void accept(Object v) 
+ void badSourceEmitAfterDone() 
+ void onNextThrowsCancelsUpstream() 
+ void onSubscribeThrowsCancelsUpstream() 
 
}
class io.reactivex.internal.observers.QueueDrainSubscriberPad2
class io.reactivex.internal.observers.ResumeSingleObserver {
 + void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.observers.SubscriberCompletableObserver {
 + void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.completable.Completable
class io.reactivex.internal.operators.completable.CompletableAmb {
 + void subscribeActual(final CompletableObserver s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
    - final CompletableSource[] sources;
        - final AtomicBoolean once;
        - final CompositeDisposable set;
        - final CompletableObserver s;
 
}
class io.reactivex.internal.operators.completable.CompletableAmbTest {
 + void ambLots() 
+ void ambFirstDone() 
+ void dispose() 
+ void innerErrorRace() 
+ void run() 
+ void nullSourceSuccessRace() 
+ void ambWithOrder() 
+ void ambIterableOrder() 
+ void ambArrayOrder() 
 
}
class io.reactivex.internal.operators.completable.CompletableAndThenTest {
 + void andThenMaybeNull() 
+ void andThenMaybeCompleteValue() 
+ void andThenMaybeCompleteError() 
+ void andThenMaybeCompleteEmpty() 
+ void andThenMaybeError() 
 
}
class io.reactivex.internal.operators.completable.CompletableAwaitTest {
 + void awaitInterrupted() 
+ void awaitTimeoutInterrupted() 
+ void awaitTimeout() 
+ void blockingGet() 
+ void blockingGetTimeout() 
+ void blockingGetError() 
+ void blockingGetErrorTimeout() 
 
}
class io.reactivex.internal.operators.completable.CompletableCache {
 # void subscribeActual(CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
~    final CompletableSource source;
~    final AtomicReference<InnerCompletableCache[]> observers;
~    final AtomicBoolean once;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.completable.CompletableCacheTest {
 + void accept(Object t) 
+ void run() 
+ void normal() 
+ void error() 
+ void crossDispose() 
+ void crossDisposeOnError() 
+ void dispose() 
+ void subscribeRace() 
+ void subscribeDisposeRace() 
+ void doubleDispose() 
+ void onComplete() 
+ void onError(Throwable e) 
 
}
class io.reactivex.internal.operators.completable.CompletableConcat {
 + void subscribeActual(CompletableObserver s) 
+ void onSubscribe(Subscription s) 
+ void onNext(CompletableSource t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
~    final int prefetch;
~        final CompletableObserver actual;
~        final int prefetch;
~        final int limit;
~        final ConcatInnerObserver inner;
~        final AtomicBoolean once;
~            final CompletableConcatSubscriber parent;
 
}
class io.reactivex.internal.operators.completable.CompletableConcatArray {
 + void subscribeActual(CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final CompletableSource[] sources;
~        final CompletableObserver actual;
~        final CompletableSource[] sources;
~        final SequentialDisposable sd;
 
}
class io.reactivex.internal.operators.completable.CompletableConcatIterable {
 + void subscribeActual(CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final CompletableObserver actual;
~        final SequentialDisposable sd;
 
}
class io.reactivex.internal.operators.completable.CompletableConcatTest {
 + void overflowReported() 
+ void invalidPrefetch() 
+ void dispose() 
+ void errorRace() 
+ void run() 
+ void synchronousFusedCrash() 
+ void unboundedIn() 
+ void syncFusedUnboundedIn() 
+ void asyncFusedUnboundedIn() 
+ void arrayCancelled() 
+ void arrayFirstCancels() 
+ void iterableCancelled() 
+ void iterableFirstCancels() 
+ void arrayCancelRace() 
+ void iterableCancelRace() 
 
}
class io.reactivex.internal.operators.completable.CompletableCreate {
 # void subscribeActual(CompletableObserver s) 
+ void onComplete() 
+ void onError(Throwable t) 
+ boolean tryOnError(Throwable t) 
+ void setDisposable(Disposable d) 
+ void setCancellable(Cancellable c) 
+ void dispose() 
+ boolean isDisposed() 
~    final CompletableOnSubscribe source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.completable.CompletableCreateTest {
 + void nullArgument() 
+ void basic() 
+ void basicWithCancellable() 
+ void basicWithError() 
+ void callbackThrows() 
+ void onErrorNull() 
+ void dispose() 
+ void onErrorThrows() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onCompleteThrows() 
+ void onErrorThrows2() 
+ void onCompleteThrows2() 
+ void tryOnError() 
+ void subscribe(CompletableEmitter e) 
 
}
class io.reactivex.internal.operators.completable.CompletableDefer {
 # void subscribeActual(CompletableObserver s) 
 
}
class io.reactivex.internal.operators.completable.CompletableDelay {
 # void subscribeActual(final CompletableObserver s) 
+ void onComplete() 
+ void onError(final Throwable e) 
+ void onSubscribe(Disposable d) 
+ void run() 
~    final CompletableSource source;
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final boolean delayError;
        - final CompositeDisposable set;
~        final CompletableObserver s;
            - final Throwable e;
 
}
class io.reactivex.internal.operators.completable.CompletableDelayTest {
 + void delayCustomScheduler() 
+ void testOnErrorCalledOnScheduler() 
 
}
class io.reactivex.internal.operators.completable.CompletableDisposeOn {
 # void subscribeActual(final CompletableObserver s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(final Disposable d) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final CompletableSource source;
~    final Scheduler scheduler;
~        final CompletableObserver s;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.completable.CompletableDisposeOnTest {
 + void cancelDelayed() 
+ void dispose() 
+ void completeAfterCancel() 
+ void errorAfterCancel() 
+ void normal() 
+ void run() 
+ void error() 
 
}
class io.reactivex.internal.operators.completable.CompletableDoFinally {
 # void subscribeActual(CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final CompletableSource source;
~    final Action onFinally;
~        final CompletableObserver actual;
~        final Action onFinally;
 
}
class io.reactivex.internal.operators.completable.CompletableDoFinallyTest {
 + void run() 
+ void normalEmpty() 
+ void normalError() 
+ void doubleOnSubscribe() 
+ void nullAction() 
+ void actionThrows() 
+ void disposed() 
 
}
class io.reactivex.internal.operators.completable.CompletableDoOnEvent {
 # void subscribeActual(final CompletableObserver s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(final Disposable d) 
~    final CompletableSource source;
        - final CompletableObserver observer;
 
}
class io.reactivex.internal.operators.completable.CompletableDoOnTest {
 + void successAcceptThrows() 
+ void errorAcceptThrows() 
+ void doOnDisposeCalled() 
+ void onSubscribeCrash() 
+ void accept(Disposable s) 
 
}
class io.reactivex.internal.operators.completable.CompletableEmpty {
 + void subscribeActual(CompletableObserver s) 
 
}
class io.reactivex.internal.operators.completable.CompletableError {
 # void subscribeActual(CompletableObserver s) 
~    final Throwable error;
 
}
class io.reactivex.internal.operators.completable.CompletableErrorSupplier {
 # void subscribeActual(CompletableObserver s) 
 
}
class io.reactivex.internal.operators.completable.CompletableFromAction {
 # void subscribeActual(CompletableObserver s) 
~    final Action run;
 
}
class io.reactivex.internal.operators.completable.CompletableFromActionTest {
 + void fromActionNull() 
+ void fromAction() 
+ void fromActionTwice() 
+ void fromActionInvokesLazy() 
+ void fromActionThrows() 
 
}
class io.reactivex.internal.operators.completable.CompletableFromCallable {
 # void subscribeActual(CompletableObserver s) 
 
}
class io.reactivex.internal.operators.completable.CompletableFromCallableTest {
 + void fromCallableNull() 
+ void fromCallable() 
+ void fromCallableTwice() 
+ void fromCallableInvokesLazy() 
+ void fromCallableThrows() 
 
}
class io.reactivex.internal.operators.completable.CompletableFromObservable {
 # void subscribeActual(final CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final ObservableSource<T> observable;
~        final CompletableObserver co;
 
}
class io.reactivex.internal.operators.completable.CompletableFromObservableTest {
 + void fromObservableNull() 
+ void fromObservable() 
+ void fromObservableEmpty() 
+ void fromObservableError() 
 
}
class io.reactivex.internal.operators.completable.CompletableFromPublisher {
 # void subscribeActual(final CompletableObserver cs) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Publisher<T> flowable;
~        final CompletableObserver cs;
 
}
class io.reactivex.internal.operators.completable.CompletableFromPublisherTest {
 + void fromPublisherNull() 
+ void fromPublisher() 
+ void fromPublisherEmpty() 
+ void fromPublisherThrows() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.completable.CompletableFromRunnable {
 # void subscribeActual(CompletableObserver s) 
~    final Runnable runnable;
 
}
class io.reactivex.internal.operators.completable.CompletableFromRunnableTest {
 + void fromRunnableNull() 
+ void fromRunnable() 
+ void fromRunnableTwice() 
+ void fromRunnableInvokesLazy() 
+ void fromRunnableThrows() 
 
}
class io.reactivex.internal.operators.completable.CompletableFromSingle {
 # void subscribeActual(final CompletableObserver s) 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
~    final SingleSource<T> single;
~        final CompletableObserver co;
 
}
class io.reactivex.internal.operators.completable.CompletableFromSingleTest {
 + void fromSingleNull() 
+ void fromSingle() 
+ void fromSingleError() 
 
}
class io.reactivex.internal.operators.completable.CompletableFromUnsafeSource {
 # void subscribeActual(CompletableObserver observer) 
~    final CompletableSource source;
 
}
class io.reactivex.internal.operators.completable.CompletableHide {
 # void subscribeActual(CompletableObserver observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final CompletableSource source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.completable.CompletableHideTest {
 + void never() 
+ void complete() 
+ void error() 
+ void hidden() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.completable.CompletableLift {
 # void subscribeActual(CompletableObserver s) 
~    final CompletableSource source;
~    final CompletableOperator onLift;
 
}
class io.reactivex.internal.operators.completable.CompletableLiftTest {
 + void callbackThrows() 
 
}
class io.reactivex.internal.operators.completable.CompletableMerge {
 + void subscribeActual(CompletableObserver s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Subscription s) 
+ void onNext(CompletableSource t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
~    final int maxConcurrency;
~    final boolean delayErrors;
~        final CompletableObserver actual;
~        final int maxConcurrency;
~        final boolean delayErrors;
~        final AtomicThrowable error;
~        final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.completable.CompletableMergeArray {
 + void subscribeActual(final CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final CompletableSource[] sources;
~        final CompletableObserver actual;
~        final AtomicBoolean once;
~        final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.completable.CompletableMergeDelayErrorArray {
 + void subscribeActual(final CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final CompletableSource[] sources;
~        final CompletableObserver actual;
~        final CompositeDisposable set;
~        final AtomicThrowable error;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.completable.CompletableMergeDelayErrorArray.MergeInnerCompletableObserver
class io.reactivex.internal.operators.completable.CompletableMergeDelayErrorIterable {
 + void subscribeActual(final CompletableObserver s) 
 
}
class io.reactivex.internal.operators.completable.CompletableMergeIterable {
 + void subscribeActual(final CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final CompositeDisposable set;
~        final CompletableObserver actual;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.completable.CompletableMergeIterableTest {
 + void errorRace() 
+ void run() 
+ void cancelAfterHasNext() 
+ Completable next() 
+ void remove() 
+ void cancelAfterNext() 
 
}
class io.reactivex.internal.operators.completable.CompletableMergeTest {
 + void invalidPrefetch() 
+ void cancelAfterFirst() 
+ void cancelAfterFirstDelayError() 
+ void onErrorAfterComplete() 
# void subscribeActual(CompletableObserver s) 
+ void completeAfterMain() 
+ void completeAfterMainDelayError() 
+ void errorAfterMainDelayError() 
+ void dispose() 
+ void disposePropagates() 
+ void innerComplete() 
+ void innerError() 
+ void innerErrorDelayError() 
+ void mainErrorInnerErrorRace() 
+ void run() 
+ void mainErrorInnerErrorDelayedRace() 
+ void maxConcurrencyOne() 
+ void maxConcurrencyOneDelayError() 
+ void maxConcurrencyOneDelayErrorFirst() 
+ void maxConcurrencyOneDelayMainErrors() 
+ void mainDoubleOnError() 
+ void innerDoubleOnError() 
+ void innerIsDisposed() 
+ void mergeArrayInnerErrorRace() 
+ void delayErrorIterableCancel() 
+ void delayErrorIterableCancelAfterHasNext() 
+ Completable next() 
+ void remove() 
+ void delayErrorIterableCancelAfterNext() 
 
}
class io.reactivex.internal.operators.completable.CompletableNever {
 # void subscribeActual(CompletableObserver s) 
 
}
class io.reactivex.internal.operators.completable.CompletableObserveOn {
 # void subscribeActual(final CompletableObserver s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void run() 
~    final CompletableSource source;
~    final Scheduler scheduler;
~        final CompletableObserver actual;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.completable.CompletableObserveOnTest {
 + void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.completable.CompletableOnErrorComplete {
 # void subscribeActual(final CompletableObserver s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
~    final CompletableSource source;
        - final CompletableObserver s;
 
}
class io.reactivex.internal.operators.completable.CompletableOnErrorXTest {
 + void normalReturn() 
+ void normalResumeNext() 
+ CompletableSource apply(Throwable e) 
 
}
class io.reactivex.internal.operators.completable.CompletablePeek {
 # void subscribeActual(final CompletableObserver s) 
+ void onSubscribe(final Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final CompletableSource source;
~    final Action onComplete;
~    final Action onTerminate;
~    final Action onAfterTerminate;
~    final Action onDispose;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.completable.CompletablePeekTest {
 + void onAfterTerminateCrashes() 
+ void disposed() 
 
}
class io.reactivex.internal.operators.completable.CompletableRepeatWhenTest {
 + void whenCounted() 
+ void run() 
+ Publisher<Object> apply(Flowable<Object> f) 
+ boolean test(Object v) 
 
}
class io.reactivex.internal.operators.completable.CompletableResumeNext {
 # void subscribeActual(final CompletableObserver s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
~    final CompletableSource source;
~        final CompletableObserver s;
~        final SequentialDisposable sd;
 
}
class io.reactivex.internal.operators.completable.CompletableSubscribeOn {
 # void subscribeActual(final CompletableObserver s) 
+ void run() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final CompletableSource source;
~    final Scheduler scheduler;
~        final CompletableObserver actual;
~        final SequentialDisposable task;
~        final CompletableSource source;
 
}
class io.reactivex.internal.operators.completable.CompletableSubscribeOnTest {
 + void normal() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.completable.CompletableSubscribeTest {
 + void subscribeAlreadyCancelled() 
+ void methodTestNoCancel() 
 
}
class io.reactivex.internal.operators.completable.CompletableTimeout {
 + void subscribeActual(final CompletableObserver s) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void run() 
~    final CompletableSource source;
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final CompletableSource other;
        - final CompositeDisposable set;
        - final AtomicBoolean once;
        - final CompletableObserver s;
~        final CompositeDisposable set;
~        final CompletableObserver s;
 
}
class io.reactivex.internal.operators.completable.CompletableTimeoutTest {
 + void timeoutException() 
+ void timeoutContinueOther() 
+ void run() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnDispose() 
+ void otherErrors() 
+ void mainSuccess() 
+ void mainError() 
+ void errorTimeoutRace() 
 
}
class io.reactivex.internal.operators.completable.CompletableTimer {
 # void subscribeActual(final CompletableObserver s) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.completable.CompletableTimerTest {
 + void dispose() 
+ void timerInterruptible() 
+ void run() 
 
}
class io.reactivex.internal.operators.completable.CompletableToFlowable {
 # void subscribeActual(Subscriber<? super T> s) 
~    final CompletableSource source;
 
}
class io.reactivex.internal.operators.completable.CompletableToObservable {
 # void subscribeActual(Observer<? super T> observer) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
~    final CompletableSource source;
 
}
class io.reactivex.internal.operators.completable.CompletableToSingle {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
~    final CompletableSource source;
~    final T completionValue;
 
}
class io.reactivex.internal.operators.completable.CompletableUnsafeTest {
 + void unsafeCreateRejectsCompletable() 
+ void wrapAlreadyCompletable() 
+ void wrapCustomCompletable() 
+ void unsafeCreateThrowsNPE() 
+ void unsafeCreateThrowsIAE() 
 
}
class io.reactivex.internal.operators.completable.CompletableUsing {
 # void subscribeActual(CompletableObserver observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final Callable<R> resourceSupplier;
~    final boolean eager;
~        final CompletableObserver actual;
~        final boolean eager;
 
}
class io.reactivex.internal.operators.completable.CompletableUsingTest {
 + void resourceSupplierThrows() 
+ CompletableSource apply(Object v) 
+ void accept(Object d) 
+ void errorEager() 
+ void emptyEager() 
+ void errorNonEager() 
+ void emptyNonEager() 
+ void supplierCrashEager() 
+ void supplierCrashNonEager() 
+ void supplierAndDisposerCrashEager() 
+ void supplierAndDisposerCrashNonEager() 
+ void dispose() 
+ Object call() 
+ void disposeCrashes() 
+ void isDisposed() 
+ void justDisposerCrashes() 
+ void emptyDisposerCrashes() 
+ void errorDisposerCrash() 
+ void doubleOnSubscribe() 
+ void successDisposeRace() 
+ void run() 
+ void errorDisposeRace() 
+ void emptyDisposeRace() 
 
}
class io.reactivex.internal.operators.completable.Flowable
class io.reactivex.internal.operators.completable.Observable
class io.reactivex.internal.operators.completable.Single
class io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstreamTest {
 + void source() 
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableIterable {
 + Iterator<T> iterator() 
+ boolean hasNext() 
+ T next() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void run() 
+ void remove() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~    final int bufferSize;
~        final SpscArrayQueue<T> queue;
~        final long batchSize;
~        final long limit;
~        final Lock lock;
~        final Condition condition;
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableIterable.BlockingFlowableIterator
class io.reactivex.internal.operators.flowable.BlockingFlowableLatest {
 + Iterator<T> iterator() 
+ void onNext(Notification<T> args) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean hasNext() 
+ T next() 
+ void remove() 
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableLatestTest {
 + void testSimple() 
+ void testSameSourceMultipleIterators() 
+ void testEmpty() 
+ void testSimpleJustNext() 
+ void testHasNextThrows() 
+ void testNextThrows() 
+ void testFasterSource() 
public void constructorshouldbe-() 
+ void remove() 
+ void interrupted() 
+ void empty() 
+ void error() 
+ void error2() 
+ void onError() 
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent {
 + Iterator<T> iterator() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(T args) 
+ Iterator getIterable() 
+ boolean hasNext() 
+ T next() 
+ void remove() 
~    final Flowable<T> source;
~    final T initialValue;
            - Object buf;
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableMostRecentTest {
 + void testMostRecentNull() 
+ void testMostRecent() 
+ void testMostRecentWithException() 
+ void testSingleSourceManyIterators() 
public void constructorshouldbe-() 
+ void empty() 
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableNext {
 + Iterator<T> iterator() 
+ boolean hasNext() 
- boolean moveToNext() 
+ T next() 
+ void remove() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Notification<T> args) 
+ Notification<T> takeNext() 
        - final NextSubscriber<T> observer;
        - T next;
        - Throwable error;
        - boolean started;
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableNext.NextSubscriber
class io.reactivex.internal.operators.flowable.BlockingFlowableNextTest {
 - void fireOnNextInNewThread(final FlowableProcessor<String> o, final String value) 
- void fireOnErrorInNewThread(final FlowableProcessor<String> o) 
+ void testNext() 
+ void testNextWithError() 
+ void testNextWithEmpty() 
+ void testOnError() 
+ void testOnErrorInNewThread() 
- void assertErrorAfterObservableFail(Iterator<String> it) 
+ void testNextWithOnlyUsingNextMethod() 
+ void testNextWithCallingHasNextMultipleTimes() 
+ void testNoBufferingOrBlockingOfSequence() 
+ void testSingleSourceManyIterators() 
+ void testSynchronousNext() 
public void constructorshouldbe-() 
+ void remove() 
+ void interrupt() 
+ void nextObserverError() 
+ void nextObserverOnNext() 
+ void nextObserverOnCompleteOnNext() 
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableToFutureTest {
 + void constructorShouldBePrivate() 
+ void testToFuture() 
+ void testToFutureList() 
+ void testExceptionWithMoreThanOneElement() 
+ void testToFutureWithException() 
+ void testGetAfterCancel() 
+ void testGetWithTimeoutAfterCancel() 
+ void testGetWithEmptyFlowable() 
+ void testGetWithASingleNullItem() 
 
}
class io.reactivex.internal.operators.flowable.BlockingFlowableToIteratorTest {
 + void testToIterator() 
+ void testToIteratorWithException() 
+ void testExceptionThrownFromOnSubscribe() 
+ void constructorShouldBePrivate() 
+ void testIteratorExertBackpressure() 
+ boolean hasNext() 
+ Integer next() 
+ void remove() 
+ void dispose() 
+ void interruptWait() 
+ void emptyThrowsNoSuch() 
+ void overflowQueue() 
        + int count;
 
}
class io.reactivex.internal.operators.flowable.BufferUntilSubscriberTest {
 + void testIssue1677() 
+ Publisher<Object> apply(Flowable<Integer> integerObservable) 
+ void accept(List<Object> integers) 
 
}
class io.reactivex.internal.operators.flowable.Completable
class io.reactivex.internal.operators.flowable.Flowable
class io.reactivex.internal.operators.flowable.FlowableAll {
 # void subscribeActual(Subscriber<? super Boolean> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableAllSingle {
 # void subscribeActual(SingleObserver<? super Boolean> s) 
+ Flowable<Boolean> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableAllTest {
 + void testAll() 
+ void testNotAll() 
+ void testEmpty() 
+ void testError() 
+ void testFollowingFirst() 
+ void testIssue1935NoUnsubscribeDownstream() 
+ Publisher<Integer> apply(Boolean t1) 
+ void testBackpressureIfNoneRequestedNoneShouldBeDelivered() 
+ void testBackpressureIfOneRequestedOneShouldBeDelivered() 
+ void testPredicateThrowsExceptionAndValueInCauseMessage() 
+ void testAllFlowable() 
+ void testNotAllFlowable() 
+ void testEmptyFlowable() 
+ void testErrorFlowable() 
+ void testFollowingFirstFlowable() 
+ void testIssue1935NoUnsubscribeDownstreamFlowable() 
+ void testBackpressureIfNoneRequestedNoneShouldBeDeliveredFlowable() 
+ void testBackpressureIfOneRequestedOneShouldBeDeliveredFlowable() 
+ void testPredicateThrowsExceptionAndValueInCauseMessageFlowable() 
+ void dispose() 
+ void predicateThrows() 
+ boolean test(Integer v) 
+ void predicateThrowsObservable() 
+ void badSource() 
+ Object apply(Flowable<Integer> o) 
+ void doubleOnSubscribe() 
+ Single<Boolean> apply(Flowable<Object> o) 
 
}
class io.reactivex.internal.operators.flowable.FlowableAmb {
 + void subscribeActual(Subscriber<? super T> s) 
+ void subscribe(Publisher<? extends T>[] sources) 
+ void request(long n) 
+ boolean win(int index) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final AmbInnerSubscriber<T>[] subscribers;
~        final AmbCoordinator<T> parent;
~        final int index;
 
}
class io.reactivex.internal.operators.flowable.FlowableAmbTest {
 + void setUp() 
- Flowable<String> createFlowable(final String[] values,
            final long interval, final Throwable e) 
+ void cancel() 
+ void run() 
+ void testAmb() 
+ void testAmb2() 
+ void testAmb3() 
+ void testProducerRequestThroughAmb() 
+ void subscribe(Subscriber<? super Integer> s) 
+ void testBackpressure() 
+ void testSubscriptionOnlyHappensOnce() 
+ void testSecondaryRequestsPropagatedToChildren() 
+ void testSynchronousSources() 
+ void testAmbCancelsOthers() 
+ void testMultipleUse() 
+ void ambIterable() 
+ void ambIterable2() 
+ void ambMany() 
+ void ambManyError() 
+ void ambManyComplete() 
+ void ambArrayEmpty() 
+ void ambArraySingleElement() 
+ void disposed() 
+ void manySources() 
+ void emptyIterable() 
+ void singleIterable() 
+ void onNextRace() 
+ void onCompleteRace() 
+ void onErrorRace() 
+ void nullIterableElement() 
+ void iteratorThrows() 
+ Flowable<Integer> apply(Integer v) 
+ void ambWithOrder() 
+ void ambIterableOrder() 
+ void ambArrayOrder() 
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableAny {
 # void subscribeActual(Subscriber<? super Boolean> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableAnySingle {
 # void subscribeActual(SingleObserver<? super Boolean> s) 
+ Flowable<Boolean> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableAnyTest {
 + void testAnyWithTwoItems() 
+ void testIsEmptyWithTwoItems() 
+ void testAnyWithOneItem() 
+ void testIsEmptyWithOneItem() 
+ void testAnyWithEmpty() 
+ void testIsEmptyWithEmpty() 
+ void testAnyWithPredicate1() 
+ void testExists1() 
+ void testAnyWithPredicate2() 
+ void testAnyWithEmptyAndPredicate() 
+ void testWithFollowingFirst() 
+ void testIssue1935NoUnsubscribeDownstream() 
+ void testBackpressureIfNoneRequestedNoneShouldBeDelivered() 
+ void testBackpressureIfOneRequestedOneShouldBeDelivered() 
+ void testPredicateThrowsExceptionAndValueInCauseMessage() 
+ void testAnyWithTwoItemsFlowable() 
+ void testIsEmptyWithTwoItemsFlowable() 
+ void testAnyWithOneItemFlowable() 
+ void testIsEmptyWithOneItemFlowable() 
+ void testAnyWithEmptyFlowable() 
+ void testIsEmptyWithEmptyFlowable() 
+ void testAnyWithPredicate1Flowable() 
+ void testExists1Flowable() 
+ void testAnyWithPredicate2Flowable() 
+ void testAnyWithEmptyAndPredicateFlowable() 
+ void testWithFollowingFirstFlowable() 
+ void testIssue1935NoUnsubscribeDownstreamFlowable() 
+ void testBackpressureIfNoneRequestedNoneShouldBeDeliveredFlowable() 
+ void testBackpressureIfOneRequestedOneShouldBeDeliveredFlowable() 
+ void testPredicateThrowsExceptionAndValueInCauseMessageFlowable() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ Single<Boolean> apply(Flowable<Object> o) 
+ void predicateThrowsSuppressOthers() 
+ boolean test(Integer v) 
+ void badSourceSingle() 
 
}
class io.reactivex.internal.operators.flowable.FlowableAsObservableTest {
 + void testHiding() 
+ void testHidingError() 
 
}
class io.reactivex.internal.operators.flowable.FlowableAutoConnect {
 + void subscribeActual(Subscriber<? super T> child) 
~    final int numberOfSubscribers;
~    final AtomicInteger clients;
 
}
class io.reactivex.internal.operators.flowable.FlowableAutoConnectTest {
 + void autoConnectImmediately() 
 
}
class io.reactivex.internal.operators.flowable.FlowableBlockingSubscribe {
  
}
class io.reactivex.internal.operators.flowable.FlowableBlockingTest {
 + void blockingFirst() 
+ void blockingFirstDefault() 
+ void blockingSubscribeConsumer() 
+ void blockingSubscribeConsumerConsumer() 
+ void blockingSubscribeConsumerConsumerError() 
+ void blockingSubscribeConsumerConsumerAction() 
+ void run() 
+ void blockingSubscribeObserver() 
+ void onNext(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void blockingSubscribeObserverError() 
+ void blockingForEachThrows() 
+ void blockingFirstEmpty() 
+ void blockingLastEmpty() 
+ void blockingFirstNormal() 
+ void blockingLastNormal() 
+ void firstFgnoredCancelAndOnNext() 
+ void firstIgnoredCancelAndOnError() 
+ void firstOnError() 
+ void interrupt() 
+ void blockingSingleEmpty() 
+ void onCompleteDelayed() 
+ void utilityClass() 
+ void disposeUpFront() 
+ void delayed() 
# void subscribeActual(Subscriber<? super Integer> observer) 
+ void blockinsSubscribeCancelAsync() 
 
}
class io.reactivex.internal.operators.flowable.FlowableBuffer {
 + void subscribeActual(Subscriber<? super C> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean getAsBoolean() 
~    final int size;
~    final int skip;
~    final Callable<C> bufferSupplier;
~        final Callable<C> bufferSupplier;
~        final int size;
~        final int skip;
~        final ArrayDeque<C> buffers;
~        final AtomicBoolean once;
 
}
class io.reactivex.internal.operators.flowable.FlowableBufferBoundary {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void dispose() 
+ boolean isDisposed() 
+ void cancel() 
+ boolean accept(Subscriber<? super U> a, U v) 
+ void onNext(Open t) 
+ void onNext(Close t) 
~    final Callable<U> bufferSupplier;
~        final Callable<U> bufferSupplier;
~        final CompositeDisposable resources;
~        final List<U> buffers;
~        final U value;
 
}
class io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean accept(Subscriber<? super U> a, U v) 
+ void onNext(B t) 
~    final Callable<U> bufferSupplier;
~        final Callable<U> bufferSupplier;
 
}
class io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean accept(Subscriber<? super U> a, U v) 
+ void onNext(B t) 
~    final Publisher<B> boundary;
~    final Callable<U> bufferSupplier;
~        final Callable<U> bufferSupplier;
~        final Publisher<B> boundary;
 
}
class io.reactivex.internal.operators.flowable.FlowableBufferTest {
 + void before() 
+ void testComplete() 
+ void testSkipAndCountOverlappingBuffers() 
+ void testSkipAndCountGaplessBuffers() 
+ void testSkipAndCountBuffersWithGaps() 
+ void testTimedAndCount() 
+ void testTimed() 
+ void testFlowableBasedOpenerAndCloser() 
+ void subscribe(Subscriber<Object> observer) 
+ Flowable<Object> apply(Object opening) 
+ void testFlowableBasedCloser() 
+ Flowable<Object> call() 
+ void testLongTimeAction() 
+ void accept(List<Integer> t1) 
- List<String> list(String... args) 
+ void run() 
- void complete(final Subscriber<?> observer, int delay) 
+ void testBufferStopsWhenUnsubscribed1() 
+ void bufferWithBONormal1() 
+ void bufferWithBOEmptyLastViaBoundary() 
+ void bufferWithBOEmptyLastViaSource() 
+ void bufferWithBOEmptyLastViaBoth() 
+ void bufferWithBOSourceThrows() 
+ void bufferWithBOBoundaryThrows() 
+ void bufferWithSizeTake1() 
+ void bufferWithSizeSkipTake1() 
+ void bufferWithTimeTake1() 
+ void bufferWithTimeSkipTake2() 
+ void bufferWithBoundaryTake2() 
+ void bufferWithStartEndBoundaryTake2() 
+ void accept(List<Long> pv) 
+ void bufferWithSizeThrows() 
+ void bufferWithTimeThrows() 
+ void bufferWithTimeAndSize() 
+ void bufferWithStartEndStartThrows() 
+ void bufferWithStartEndEndFunctionThrows() 
+ void bufferWithStartEndEndThrows() 
+ void testProducerRequestThroughBufferWithSize1() 
+ void cancel() 
+ void testProducerRequestThroughBufferWithSize2() 
+ void testProducerRequestThroughBufferWithSize3() 
+ void testProducerRequestThroughBufferWithSize4() 
+ void testProducerRequestOverflowThroughBufferWithSize1() 
+ void testProducerRequestOverflowThroughBufferWithSize2() 
+ void testProducerRequestOverflowThroughBufferWithSize3() 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(List<Integer> t) 
+ void testBufferWithTimeDoesntUnsubscribeDownstream() 
+ void testPostCompleteBackpressure() 
+ void timeAndSkipOverlap() 
+ void timeAndSkipSkip() 
+ void timeAndSkipOverlapScheduler() 
+ void timeAndSkipSkipDefaultScheduler() 
+ void bufferBoundaryHint() 
~{static} HashSet<Integer> set(Integer... values) 
+ void bufferIntoCustomCollection() 
+ void bufferSkipIntoCustomCollection() 
+ void bufferTimeSkipDefault() 
+ void boundaryBufferSupplierThrows() 
+ void boundaryBoundarySupplierThrows() 
+ Collection<Object> call() 
+ void boundaryBufferSupplierThrows2() 
+ void boundaryBufferSupplierReturnsNull() 
+ void boundaryBoundarySupplierThrows2() 
+ void boundaryCancel() 
+ void boundaryBoundarySupplierReturnsNull() 
+ void boundaryBoundarySupplierReturnsNull2() 
+ void boundaryMainError() 
+ void boundaryBoundaryError() 
+ void dispose() 
+ void supplierReturnsNull() 
+ void supplierReturnsNull2() 
+ void supplierReturnsNull3() 
+ void supplierThrows() 
+ void supplierThrows2() 
+ void supplierThrows3() 
+ void supplierThrows4() 
+ void supplierThrows5() 
+ void supplierThrows6() 
+ void restartTimer() 
+ void bufferSkipError() 
+ void bufferSupplierCrash2() 
+ void bufferSkipSupplierCrash2() 
+ void bufferOverlapSupplierCrash2() 
+ void bufferSkipOverlap() 
+ void bufferTimedExactError() 
+ void bufferTimedSkipError() 
+ void bufferTimedOverlapError() 
+ void bufferTimedExactEmpty() 
+ void bufferTimedSkipEmpty() 
+ void bufferTimedOverlapEmpty() 
+ void bufferTimedExactSupplierCrash() 
+ void bufferTimedExactBoundedError() 
+ void badSource() 
+ Object apply(Flowable<Integer> f) 
+ void doubleOnSubscribe() 
+ Publisher<List<Object>> apply(Flowable<Object> f) 
+ void badRequest() 
+ void skipError() 
+ void skipSingleResult() 
+ void skipBackpressure() 
    - Subscriber<List<String>> observer;
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableBufferTimed {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void run() 
+ boolean accept(Subscriber<? super U> a, U v) 
+ void dispose() 
+ boolean isDisposed() 
~    final long timespan;
~    final long timeskip;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final Callable<U> bufferSupplier;
~    final int maxSize;
~    final boolean restartTimerOnMaxSize;
~        final Callable<U> bufferSupplier;
~        final long timespan;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final long timeskip;
~        final Worker w;
~        final List<U> buffers;
~            final U b;
            - final U buffer;
~        final int maxSize;
~        final boolean restartTimerOnMaxSize;
 
}
class io.reactivex.internal.operators.flowable.FlowableCache {
 # void subscribeActual(Subscriber<? super T> t) 
+ void addChild(ReplaySubscription<T> p) 
+ void removeChild(ReplaySubscription<T> p) 
+ void onSubscribe(Subscription s) 
+ void connect() 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void replay() 
~    final CacheState<T> state;
~    final AtomicBoolean once;
~        final Flowable<T> source;
~        final AtomicReference<ReplaySubscription<T>[]> subscribers;
~        final CacheState<T> state;
~        final AtomicLong requested;
 
}
class io.reactivex.internal.operators.flowable.FlowableCacheTest {
 + void testColdReplayNoBackpressure() 
+ void testColdReplayBackpressure() 
+ void testCache() 
+ void accept(String v) 
+ void testUnsubscribeSource() 
+ void testTake() 
+ void testAsync() 
+ void testAsyncComeAndGo() 
+ void testNoMissingBackpressureException() 
+ void testValuesAndThenError() 
+ void unsafeChildThrows() 
+ void onNext(Integer t) 
+ void take() 
+ void dispose() 
+ void disposeOnArrival2() 
+ void subscribeEmitRace() 
+ void run() 
+ void observers() 
+ void disposeOnArrival() 
+ void badSource() 
+ void badRequest() 
+ void take1() 
+ void empty() 
+ void error() 
 
}
class io.reactivex.internal.operators.flowable.FlowableCastTest {
 + void testCast() 
+ void testCastWithWrongType() 
+ void castCrashUnsubscribes() 
 
}
class io.reactivex.internal.operators.flowable.FlowableCollect {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
~        final U u;
 
}
class io.reactivex.internal.operators.flowable.FlowableCollectSingle {
 # void subscribeActual(SingleObserver<? super U> s) 
+ Flowable<U> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~        final U u;
 
}
class io.reactivex.internal.operators.flowable.FlowableCombineLatest {
 + void subscribeActual(Subscriber<? super R> s) 
+ void request(long n) 
+ void cancel() 
+ int requestFusion(int requestedMode) 
+ R poll() 
+ void clear() 
+ boolean isEmpty() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void requestOne() 
+ R apply(T t) 
~    final int bufferSize;
~    final boolean delayErrors;
~        final CombineLatestInnerSubscriber<T>[] subscribers;
~        final SpscLinkedArrayQueue<Object> queue;
~        final Object[] latest;
~        final boolean delayErrors;
~        final AtomicLong requested;
~        final AtomicReference<Throwable> error;
~        final int index;
~        final int prefetch;
~        final int limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableCombineLatestTest {
 + void testCombineLatestWithFunctionThatThrowsAnException() 
+ void testCombineLatestDifferentLengthFlowableSequences1() 
+ void testCombineLatestDifferentLengthFlowableSequences2() 
+ void testCombineLatestWithInterleavingSequences() 
+ void testCombineLatest2Types() 
+ void testCombineLatest3TypesA() 
+ void testCombineLatest3TypesB() 
+ String apply(String a1, String a2, String a3) 
+ String apply(String s, Integer i) 
+ String apply(String s, Integer i, int[] iArray) 
- {static} String getStringValue(Object o) 
+ Integer apply(Integer t1, Integer t2) 
+ void combineSimple() 
+ void combineMultipleObservers() 
+ void testFirstNeverProduces() 
+ void testSecondNeverProduces() 
+ void test0Sources() 
+ void test1ToNSources() 
+ void test1ToNSourcesScheduled() 
+ void onNext(List<Object> t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void test2SourcesOverload() 
+ void test3SourcesOverload() 
+ void test4SourcesOverload() 
+ void test5SourcesOverload() 
+ void test6SourcesOverload() 
+ void test7SourcesOverload() 
+ void test8SourcesOverload() 
+ void test9SourcesOverload() 
+ void testZeroSources() 
+ void testBackpressureLoop() 
+ void testBackpressure() 
+ void testWithCombineLatestIssue1717() 
+ Long apply(Long t1, Integer t2) 
+ void testCombineLatestRequestOverflow() 
+ void onStart() 
+ void onNext(Integer t) 
+ Integer apply(Object[] args) 
+ void testNonFatalExceptionThrownByCombinatorForSingleSourceIsNotReportedByUpstreamOperator() 
+ void testCombineManyNulls() 
+ void combineLatestIterable() 
+ void testCombineMany() 
+ String apply(Object[] args) 
+ void firstJustError() 
+ void secondJustError() 
+ void oneErrors() 
+ void twoErrors() 
+ void bothError() 
+ void combineLatestNArguments() 
+ void combineLatestNSources() 
+ List<Object> apply(Object[] t) 
+ void combineLatestArrayOfSources() 
+ Object apply(Object[] a) 
+ void combineLatestDelayErrorArrayOfSources() 
+ void combineLatestDelayErrorArrayOfSourcesWithError() 
+ void combineLatestDelayErrorIterableOfSources() 
+ void combineLatestDelayErrorIterableOfSourcesWithError() 
+ void combineLatestEmpty() 
+ void combineLatestDelayErrorEmpty() 
+ void error() 
+ void disposed() 
+ void cancelWhileSubscribing() 
+ Object apply(Object a, Object b) 
+ void onErrorRace() 
+ void run() 
+ void combineAsync() 
+ void errorDelayed() 
+ void errorDelayed2() 
+ void dontSubscribeIfDone() 
+ void accept(Subscription d) 
+ void dontSubscribeIfDone2() 
+ void combine2Flowable2Errors() 
+ Object apply(Long aLong) 
+ void accept(Notification<Integer> integerNotification) 
+ void accept(Notification<Object> integerNotification) 
+ Object apply(Object[] objects) 
+ void eagerDispose() 
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatArray {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final boolean delayError;
~        final boolean delayError;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatDelayErrorTest {
 + void mainCompletes() 
+ void mainErrors() 
+ void innerErrors() 
+ void singleInnerErrors() 
+ void innerNull() 
+ void innerThrows() 
+ void innerWithEmpty() 
+ void innerWithScalar() 
+ void backpressure() 
+ void concatDelayErrorFlowable() 
+ void concatDelayErrorFlowableError() 
+ void concatDelayErrorIterable() 
+ void concatDelayErrorIterableError() 
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatMap {
 # void subscribeActual(Subscriber<? super R> s) 
+ final void onSubscribe(Subscription s) 
~{abstract} void drain()
+ final void onComplete() 
+ final void innerComplete() 
+ void onError(Throwable t) 
+ void innerNext(R value) 
+ void innerError(Throwable e) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(R t) 
+ void onComplete() 
~    final int prefetch;
~    final ErrorMode errorMode;
~        final ConcatMapInner<R> inner;
~        final int prefetch;
~        final int limit;
~        final AtomicThrowable errors;
~        final AtomicInteger wip;
~        final T value;
~        final boolean veryEnd;
~        final ConcatMapSupport<R> parent;
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatMapEager {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
+ void innerNext(InnerQueuedSubscriber<R> inner, R value) 
+ void innerError(InnerQueuedSubscriber<R> inner, Throwable e) 
+ void innerComplete(InnerQueuedSubscriber<R> inner) 
+ void drain() 
~    final int maxConcurrency;
~    final int prefetch;
~    final ErrorMode errorMode;
~        final int maxConcurrency;
~        final int prefetch;
~        final ErrorMode errorMode;
~        final AtomicThrowable errors;
~        final AtomicLong requested;
~        final SpscLinkedArrayQueue<InnerQueuedSubscriber<R>> subscribers;
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatMapEager.ConcatMapEagerDelayErrorSubscriber
class io.reactivex.internal.operators.flowable.FlowableConcatMapEagerPublisher {
 # void subscribeActual(Subscriber<? super R> s) 
~    final Publisher<T> source;
~    final int maxConcurrency;
~    final int prefetch;
~    final ErrorMode errorMode;
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatMapEagerTest {
 + void normal() 
+ void normalBackpressured() 
+ void normalDelayBoundary() 
+ void normalDelayBoundaryBackpressured() 
+ void normalDelayEnd() 
+ void normalDelayEndBackpressured() 
+ void mainErrorsDelayBoundary() 
+ void mainErrorsDelayEnd() 
+ void mainErrorsImmediate() 
+ void longEager() 
+ Flowable<Integer> apply(Integer t) 
+ void before() 
+ void testSimple() 
+ void testSimple2() 
+ void testEagerness2() 
+ void testEagerness3() 
+ void testEagerness4() 
+ void testEagerness5() 
+ void testEagerness6() 
+ void testEagerness7() 
+ void testEagerness8() 
+ void testEagerness9() 
+ void testMainError() 
+ void testInnerError() 
+ void testInnerEmpty() 
+ void testMapperThrows() 
+ void testInvalidMaxConcurrent() 
+ void testInvalidCapacityHint() 
+ void testBackpressure() 
+ void testAsynchronousRun() 
+ void testReentrantWork() 
+ void accept(Integer t) 
+ void testPrefetchIsBounded() 
+ void testInnerNull() 
+ void testMaxConcurrent5() 
+ void many() 
+ void capacityHint() 
+ void flowable() 
+ void flowableCapacityHint() 
+ void badCapacityHint() 
+ void mappingBadCapacityHint() 
+ void concatEagerZero() 
+ void concatEagerOne() 
+ void concatEagerTwo() 
+ void Flowable() 
+ void ObservableCapacityHint() 
+ void concatEagerIterable() 
+ void empty() 
+ void dispose() 
+ void innerError() 
+ void innerOuterRace() 
+ void run() 
+ void innerErrorMaxConcurrency() 
+ void innerCallableThrows() 
+ void innerErrorAfterPoll() 
+ Flowable<Integer> apply(Integer v) 
+ void nextCancelRace() 
+ void mapperCancels() 
+ void innerErrorFused() 
+ void fuseAndTake() 
+ void doubleOnSubscribe() 
+ void doubleOnError() 
# void subscribeActual(Subscriber<? super Integer> s) 
+ void innerOverflow() 
+ void unboundedIn() 
+ void drainCancelRaceOnEmpty() 
+ void innerLong() 
+ void oneDelayed() 
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatMapPublisher {
 # void subscribeActual(Subscriber<? super R> s) 
~    final Publisher<T> source;
~    final int prefetch;
~    final ErrorMode errorMode;
 
}
class io.reactivex.internal.operators.flowable.FlowableConcatTest {
 + void testConcat() 
+ void testConcatWithList() 
+ void testConcatObservableOfObservables() 
+ void subscribe(Subscriber<? super Flowable<String>> observer) 
+ void testSimpleAsyncConcat() 
+ void testNestedAsyncConcatLoop() 
+ void testNestedAsyncConcat() 
+ void cancel() 
+ void run() 
+ void testBlockedObservableOfObservables() 
+ void testConcatConcurrentWithInfinity() 
+ void testConcatNonBlockingObservables() 
+ void testConcatUnsubscribe() 
+ void testConcatUnsubscribeConcurrent() 
+ void request(long n) 
+ void subscribe(final Subscriber<? super T> observer) 
+ void testMultipleObservers() 
+ void concatVeryLongObservableOfObservables() 
+ void concatVeryLongObservableOfObservablesTakeHalf() 
+ void testConcatOuterBackpressure() 
+ void testInnerBackpressureWithAlignedBoundaries() 
+ void testInnerBackpressureWithoutAlignedBoundaries() 
+ void testConcatWithNonCompliantSourceDoubleOnComplete() 
+ void testIssue2890NoStackoverflow() 
+ void onNext(Integer t) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void testRequestOverflowDoesNotStallStream() 
+ void concatMapRangeAsyncLoopIssue2876() 
+ Flowable<Integer> apply(Integer t) 
+ void arrayDelayError() 
+ void scalarAndRangeBackpressured() 
+ void scalarAndEmptyBackpressured() 
+ void rangeAndEmptyBackpressured() 
+ void emptyAndScalarBackpressured() 
+ void concatMany() 
+ void concatMapJustJust() 
+ void concatMapJustRange() 
+ void concatMapDelayErrorJustJust() 
+ void concatMapDelayErrorJustRange() 
+ void startWith() 
+ boolean hasNext() 
+ Integer next() 
+ void remove() 
+ Iterator<Integer> iterator() 
+ void veryLongTake() 
+ void concat3() 
+ void concat4() 
+ void concatArrayDelayError() 
+ void concatArrayDelayErrorWithError() 
+ void concatIterableDelayError() 
+ void concatIterableDelayErrorWithError() 
+ void concatObservableDelayError() 
+ void concatObservableDelayErrorWithError() 
+ void concatObservableDelayErrorBoundary() 
+ void concatObservableDelayErrorTillEnd() 
+ void concatMapDelayError() 
+ void concatMapDelayErrorWithError() 
+ void concatMapIterableBufferSize() 
+ void emptyArray() 
+ void singleElementArray() 
+ void concatMapDelayErrorEmptySource() 
+ void concatMapDelayErrorJustSource() 
+ void concatArrayEmpty() 
+ void concatArraySingleElement() 
+ void concatMapErrorEmptySource() 
+ void concatMapJustSource() 
+ void concatMapJustSourceDelayError() 
+ void concatMapScalarBackpressured() 
+ void concatMapScalarBackpressuredDelayError() 
+ void concatMapEmpty() 
+ void concatMapEmptyDelayError() 
+ void ignoreBackpressure() 
+ void doubleOnSubscribe() 
+ Publisher<Integer> apply(Flowable<Object> f) 
+ void immediateInnerNextOuterError() 
+ void immediateInnerNextOuterError2() 
+ void concatMapInnerError() 
+ void concatMapInnerErrorDelayError() 
+ void badSource() 
+ void badInnerSource() 
# void subscribeActual(Subscriber<? super Integer> s) 
+ void badInnerSourceDelayError() 
+ void badSourceDelayError() 
+ void fusedCrash() 
+ void fusedCrashDelayError() 
+ void callableCrash() 
+ void callableCrashDelayError() 
+ void dispose() 
+ void notVeryEnd() 
+ void error() 
+ void mapperThrows() 
+ void noSubsequentSubscription() 
+ void subscribe(FlowableEmitter<Integer> s) 
+ void noSubsequentSubscriptionDelayError() 
+ void noSubsequentSubscriptionIterable() 
+ void noSubsequentSubscriptionDelayErrorIterable() 
        - final List<T> values;
        - Thread t;
        - int count;
        - final CountDownLatch once;
        - final CountDownLatch okToContinue;
        - final T seed;
        - final int size;
 
}
class io.reactivex.internal.operators.flowable.FlowableCount {
 # void subscribeActual(Subscriber<? super Long> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableCountSingle {
 # void subscribeActual(SingleObserver<? super Long> s) 
+ Flowable<Long> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableCountTest {
 + void simpleFlowable() 
+ void simple() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ SingleSource<Long> apply(Flowable<Object> o) 
 
}
class io.reactivex.internal.operators.flowable.FlowableCreate {
 + void subscribeActual(Subscriber<? super T> t) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ boolean tryOnError(Throwable t) 
+ void onComplete() 
+ void setDisposable(Disposable s) 
+ void setCancellable(Cancellable c) 
+ long requested() 
+ boolean isCancelled() 
+ FlowableEmitter<T> serialize() 
# void complete() 
+ final void onError(Throwable e) 
+ boolean tryOnError(Throwable e) 
# boolean error(Throwable e) 
+ final void cancel() 
+ final boolean isCancelled() 
+ final void request(long n) 
+ final void setDisposable(Disposable s) 
+ final void setCancellable(Cancellable c) 
+ final long requested() 
+ final FlowableEmitter<T> serialize() 
+ final void onNext(T t) 
~{abstract} void onOverflow()
~    final FlowableOnSubscribe<T> source;
~    final BackpressureStrategy backpressure;
~        final BaseEmitter<T> emitter;
~        final AtomicThrowable error;
~        final SimplePlainQueue<T> queue;
~        final SequentialDisposable serial;
~        final SpscLinkedArrayQueue<T> queue;
~        final AtomicInteger wip;
~        final AtomicReference<T> queue;
 
}
class io.reactivex.internal.operators.flowable.FlowableCreateTest {
 + void sourceNull() 
+ void modeNull() 
+ void basic() 
+ void basicWithCancellable() 
+ void basicWithError() 
+ void basicSerialized() 
+ void basicWithErrorSerialized() 
+ void wrap() 
+ void unsafe() 
+ void unsafeWithFlowable() 
+ void createNullValueBuffer() 
+ void subscribe(FlowableEmitter<Integer> e) 
+ void createNullValueLatest() 
+ void createNullValueError() 
+ void createNullValueDrop() 
+ void createNullValueMissing() 
+ void createNullValueBufferSerialized() 
+ void createNullValueLatestSerialized() 
+ void createNullValueErrorSerialized() 
+ void createNullValueDropSerialized() 
+ void createNullValueMissingSerialized() 
+ void onErrorRace() 
+ void run() 
+ void onCompleteRace() 
+ void nullValue() 
+ void nullThrowable() 
+ void serializedConcurrentOnNextOnError() 
+ void callbackThrows() 
+ void nullValueSync() 
+ void createNullValue() 
+ void nullArgument() 
+ void onErrorCrash() 
+ void onSubscribe(Subscription d) 
+ void onNext(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onCompleteCrash() 
+ void createNullValueSerialized() 
+ void nullThrowableSync() 
+ void serializedConcurrentOnNext() 
+ void serializedConcurrentOnNextOnComplete() 
+ void serialized() 
+ void cancel() 
+ void tryOnError() 
+ void subscribe(FlowableEmitter<Object> e) 
+ void tryOnErrorSerialized() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDebounce {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(U t) 
~            final long index;
~            final T value;
 
}
class io.reactivex.internal.operators.flowable.FlowableDebounceTest {
 + void before() 
+ void testDebounceWithCompleted() 
+ void testDebounceNeverEmits() 
+ void testDebounceWithError() 
+ void run() 
+ void debounceSelectorNormal1() 
+ void debounceSelectorFuncThrows() 
+ void debounceSelectorFlowableThrows() 
+ void debounceTimedLastIsNotLost() 
+ void debounceSelectorLastIsNotLost() 
+ void debounceWithTimeBackpressure() 
+ void debounceDefaultScheduler() 
+ void debounceDefault() 
+ void dispose() 
+ void badSource() 
+ void badSourceSelector() 
+ Object apply(final Flowable<Integer> o) 
+ void debounceWithEmpty() 
+ void backpressureNoRequest() 
+ void backpressureNoRequestTimed() 
    - TestScheduler scheduler;
    - Subscriber<String> observer;
 
}
class io.reactivex.internal.operators.flowable.FlowableDebounceTimed {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
+ void setResource(Disposable d) 
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long timeout;
~        final TimeUnit unit;
~        final T value;
~        final long idx;
~        final DebounceTimedSubscriber<T> parent;
 
}
class io.reactivex.internal.operators.flowable.FlowableDefaultIfEmptyTest {
 + void testDefaultIfEmpty() 
+ void testDefaultIfEmptyWithEmpty() 
+ void testEmptyButClientThrows() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testBackpressureEmpty() 
+ void testBackpressureNonEmpty() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDefer {
 + void subscribeActual(Subscriber<? super T> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableDeferTest {
 + void testDefer() 
+ void testDeferFunctionThrows() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDelay {
 # void subscribeActual(Subscriber<? super T> t) 
+ void onSubscribe(Subscription s) 
+ void onNext(final T t) 
+ void onError(final Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void run() 
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final boolean delayError;
~        final long delay;
~        final TimeUnit unit;
~        final boolean delayError;
            - final T t;
            - final Throwable t;
 
}
class io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther {
 + void subscribeActual(final Subscriber<? super T> child) 
+ void onSubscribe(final Subscription s) 
+ void onNext(U t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
~    final Publisher<U> other;
~        final SubscriptionArbiter serial;
            - final Subscription s;
 
}
class io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOtherTest {
 + void testNoPrematureSubscription() 
+ void testNoMultipleSubscriptions() 
+ void testCompleteTriggersSubscription() 
+ void testNoPrematureSubscriptionToError() 
+ void testNoSubscriptionIfOtherErrors() 
+ void testBackpressurePassesThrough() 
+ void unsubscriptionPropagatesBeforeSubscribe() 
+ void unsubscriptionPropagatesAfterSubscribe() 
+ void delayAndTakeUntilNeverSubscribeToSource() 
+ void otherNull() 
+ void badSourceOther() 
+ void afterDelayNoInterrupt() 
+ void subscribe(FlowableEmitter<Boolean> emitter) 
 
}
class io.reactivex.internal.operators.flowable.FlowableDelayTest {
 + void before() 
+ void testDelay() 
+ void testLongDelay() 
+ void testDelayWithError() 
+ void testDelayWithMultipleSubscriptions() 
+ void testDelaySubscription() 
+ void testDelaySubscriptionCancelBeforeTime() 
+ void testDelayWithFlowableNormal1() 
+ Flowable<Integer> apply(Integer t1) 
+ void testDelayWithFlowableSingleSend1() 
+ void testDelayWithFlowableSourceThrows() 
+ void testDelayWithFlowableDelayFunctionThrows() 
+ void testDelayWithFlowableDelayThrows() 
+ void testDelayWithFlowableSubscriptionNormal() 
+ void testDelayWithFlowableSubscriptionFunctionThrows() 
+ void testDelayWithFlowableSubscriptionThrows() 
+ void testDelayWithFlowableEmptyDelayer() 
+ void testDelayWithFlowableSubscriptionRunCompletion() 
+ void testDelayWithFlowableAsTimed() 
+ void testDelayWithFlowableReorder() 
+ void testDelayEmitsEverything() 
+ void testBackpressureWithTimedDelay() 
+ void testBackpressureWithSubscriptionTimedDelay() 
+ void testBackpressureWithSelectorDelay() 
+ Integer apply(Integer t) 
+ void testBackpressureWithSelectorDelayAndSubscriptionDelay() 
+ Flowable<Long> apply(Integer i) 
+ void testErrorRunsBeforeOnNext() 
+ void testDelaySupplierSimple() 
+ void testDelaySupplierCompletes() 
+ void testDelaySupplierErrors() 
+ void delayAndTakeUntilNeverSubscribeToSource() 
+ void delayWithTimeDelayError() 
+ void testDelaySubscriptionDisposeBeforeTime() 
+ void testOnErrorCalledOnScheduler() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ Flowable<Object> apply(Flowable<Object> o) 
+ void onCompleteFinal() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onErrorFinal() 
    - Subscriber<Long> observer;
    - Subscriber<Long> observer2;
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableDematerialize {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(Notification<T> t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDematerializeTest {
 + void testDematerialize1() 
+ void testDematerialize2() 
+ void testDematerialize3() 
+ void testErrorPassThru() 
+ void testCompletePassThru() 
+ void testHonorsContractWhenCompleted() 
+ void testHonorsContractWhenThrows() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void eventsAfterDematerializedTerminal() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDetach {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDetachTest {
 + void just() 
+ void error() 
+ void empty() 
+ void range() 
+ void backpressured() 
+ void justUnsubscribed() 
+ void deferredUpstreamProducer() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDistinct {
 # void subscribeActual(Subscriber<? super T> observer) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ int requestFusion(int mode) 
+ T poll() 
+ void clear() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDistinctTest {
 + String apply(String s) 
+ void before() 
+ void testDistinctOfNone() 
+ void testDistinctOfNoneWithKeySelector() 
+ void testDistinctOfNormalSource() 
+ void testDistinctOfNormalSourceWithKeySelector() 
+ void testDistinctOfSourceWithNulls() 
+ void testDistinctOfSourceWithExceptionsFromKeySelector() 
+ void error() 
+ void fusedSync() 
+ void fusedAsync() 
+ void fusedClear() 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void collectionSupplierThrows() 
+ void collectionSupplierIsNull() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onNext(T t) 
+ boolean tryOnNext(T t) 
+ int requestFusion(int mode) 
+ T poll() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDistinctUntilChangedTest {
 + String apply(String s) 
+ void before() 
+ void testDistinctUntilChangedOfNone() 
+ void testDistinctUntilChangedOfNoneWithKeySelector() 
+ void testDistinctUntilChangedOfNormalSource() 
+ void testDistinctUntilChangedOfNormalSourceWithKeySelector() 
+ void testDistinctUntilChangedOfSourceWithNulls() 
+ void testDistinctUntilChangedOfSourceWithExceptionsFromKeySelector() 
+ void directComparer() 
+ void directComparerConditional() 
+ boolean test(Integer v) 
+ void directComparerFused() 
+ void directComparerConditionalFused() 
+ void testDistinctUntilChangedWhenNonFatalExceptionThrownByKeySelectorIsNotReportedByUpstream() 
+ void customComparator() 
+ void customComparatorThrows() 
+ void fused() 
+ void fusedAsync() 
+ void ignoreCancel() 
+ boolean test(Integer a, Integer b) 
+ void mutableWithSelector() 
+ void conditionalNormal() 
+ void conditionalNormal2() 
+ void conditionalNormal3() 
+ void conditionalSelectorCrash() 
+ void conditionalFused() 
+ void conditionalAsyncFused() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoAfterNext {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onNext(T t) 
+ int requestFusion(int mode) 
+ T poll() 
+ boolean tryOnNext(T t) 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoAfterNextTest {
 + void accept(Integer e) 
+ void onNext(Integer t) 
+ void just() 
+ void range() 
+ void error() 
+ void empty() 
+ void syncFused() 
+ void asyncFusedRejected() 
+ void asyncFused() 
+ void consumerNull() 
+ void justConditional() 
+ void rangeConditional() 
+ void errorConditional() 
+ void emptyConditional() 
+ void syncFusedConditional() 
+ void asyncFusedRejectedConditional() 
+ void asyncFusedConditional() 
+ void consumerThrows() 
+ void consumerThrowsConditional() 
+ void consumerThrowsConditional2() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoAfterTerminateTest {
 + void before() 
- void checkActionCalled(Flowable<String> input) 
+ void testDoAfterTerminateCalledOnComplete() 
+ void testDoAfterTerminateCalledOnError() 
+ void nullActionShouldBeCheckedInConstructor() 
+ void nullFinallyActionShouldBeCheckedASAP() 
+ void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() 
    - Action aAction0;
    - Subscriber<String> observer;
 
}
class io.reactivex.internal.operators.flowable.FlowableDoFinally {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
+ T poll() 
+ boolean tryOnNext(T t) 
~    final Action onFinally;
~        final Action onFinally;
 
}
class io.reactivex.internal.operators.flowable.FlowableDoFinallyTest {
 + void run() 
+ void normalJust() 
+ void normalEmpty() 
+ void normalError() 
+ void normalTake() 
+ void doubleOnSubscribe() 
+ Publisher<Object> apply(Flowable<Object> f) 
+ void syncFused() 
+ void syncFusedBoundary() 
+ void asyncFused() 
+ void asyncFusedBoundary() 
+ void normalJustConditional() 
+ void normalEmptyConditional() 
+ void normalErrorConditional() 
+ void normalTakeConditional() 
+ void syncFusedConditional() 
+ void nonFused() 
+ void nonFusedConditional() 
+ void syncFusedBoundaryConditional() 
+ void asyncFusedConditional() 
+ void asyncFusedBoundaryConditional() 
+ void nullAction() 
+ void actionThrows() 
+ void actionThrowsConditional() 
+ void clearIsEmpty() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void clearIsEmptyConditional() 
+ void eventOrdering() 
+ void accept(Object v) 
+ void accept(Throwable e) 
+ void eventOrdering2() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnEach {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ int requestFusion(int mode) 
+ T poll() 
+ boolean tryOnNext(T t) 
~    final Action onComplete;
~    final Action onAfterTerminate;
~        final Action onComplete;
~        final Action onAfterTerminate;
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnEachTest {
 + void before() 
+ void testDoOnEach() 
+ void testDoOnEachWithError() 
+ void testDoOnEachWithErrorInCallback() 
+ void testIssue1451Case1() 
+ void accept(List<Boolean> booleans) 
+ void testIssue1451Case2() 
+ void testFatalError() 
+ void accept(Object o) 
+ void onErrorThrows() 
+ void ignoreCancel() 
+ void accept(Object e) 
+ void onErrorAfterCrash() 
+ void run() 
+ void onCompleteAfterCrash() 
+ void onCompleteCrash() 
+ void ignoreCancelConditional() 
+ void ignoreCancelConditional2() 
+ void onErrorAfterCrashConditional() 
+ void onCompleteAfter() 
+ void onCompleteAfterCrashConditional() 
+ void onCompleteCrashConditional() 
+ void onErrorOnErrorCrashConditional() 
+ void fused() 
+ void accept(Integer v) 
+ void fusedOnErrorCrash() 
+ void fusedConditional() 
+ void fusedOnErrorCrashConditional() 
+ void fusedAsync() 
+ void fusedAsyncConditional() 
+ void fusedAsyncConditional2() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
    - final LongConsumer onRequest;
    - final Action onCancel;
~        final LongConsumer onRequest;
~        final Action onCancel;
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnLifecycleTest {
 + void onSubscribeCrashed() 
+ void doubleOnSubscribe() 
+ Publisher<Object> apply(Flowable<Object> o) 
+ void run() 
+ void dispose() 
+ void accept(Subscription s) 
+ void requestCrashed() 
+ void cancelCrashed() 
+ void onSubscribeCrash() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnRequestTest {
 + void testUnsubscribeHappensAgainstParent() 
+ void accept(long n) 
+ void testDoRequest() 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void dontRequestIfDownstreamRequestsLate() 
+ void onNext(Object t) 
+ void setProducer(Producer p) 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnSubscribeTest {
 + void testDoOnSubscribe() 
+ void testDoOnSubscribe2() 
+ void accept(Subscription s) 
+ void testDoOnUnSubscribeWorksWithRefCount() 
 
}
class io.reactivex.internal.operators.flowable.FlowableDoOnUnsubscribeTest {
 + void testDoOnUnsubscribe() 
+ void accept(Long aLong) 
+ void run() 
+ void testDoOnUnSubscribeWorksWithRefCount() 
 
}
class io.reactivex.internal.operators.flowable.FlowableElementAt {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
~    final long index;
~    final T defaultValue;
~    final boolean errorOnFewer;
~        final long index;
~        final T defaultValue;
~        final boolean errorOnFewer;
 
}
class io.reactivex.internal.operators.flowable.FlowableElementAtMaybe {
 # void subscribeActual(MaybeObserver<? super T> s) 
+ Flowable<T> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~    final long index;
~        final long index;
 
}
class io.reactivex.internal.operators.flowable.FlowableElementAtSingle {
 # void subscribeActual(SingleObserver<? super T> s) 
+ Flowable<T> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~    final long index;
~    final T defaultValue;
~        final long index;
~        final T defaultValue;
 
}
class io.reactivex.internal.operators.flowable.FlowableElementAtTest {
 + void testElementAtFlowable() 
+ void testElementAtWithMinusIndexFlowable() 
+ void testElementAtWithIndexOutOfBoundsFlowable() 
+ void testElementAtOrDefaultFlowable() 
+ void testElementAtOrDefaultWithIndexOutOfBoundsFlowable() 
+ void testElementAtOrDefaultWithMinusIndexFlowable() 
+ void testElementAt() 
+ void testElementAtWithMinusIndex() 
+ void testElementAtWithIndexOutOfBounds() 
+ void testElementAtOrDefault() 
+ void testElementAtOrDefaultWithIndexOutOfBounds() 
+ void testElementAtOrDefaultWithMinusIndex() 
+ void elementAtOrErrorNegativeIndex() 
+ void elementAtOrErrorNoElement() 
+ void elementAtOrErrorOneElement() 
+ void elementAtOrErrorMultipleElements() 
+ void elementAtOrErrorInvalidIndex() 
+ void elementAtOrErrorError() 
+ void elementAtIndex0OnEmptySource() 
+ void elementAtIndex0WithDefaultOnEmptySource() 
+ void elementAtIndex1OnEmptySource() 
+ void elementAtIndex1WithDefaultOnEmptySource() 
+ void elementAtOrErrorIndex1OnEmptySource() 
+ void doubleOnSubscribe() 
+ Maybe<Object> apply(Flowable<Object> o) 
+ Single<Object> apply(Flowable<Object> o) 
+ void elementAtIndex1WithDefaultOnEmptySourceObservable() 
+ void errorFlowable() 
+ void error() 
+ void badSource() 
+ Object apply(Flowable<Integer> f) 
+ void dispose() 
+ void badSourceObservable() 
+ void badSource2() 
 
}
class io.reactivex.internal.operators.flowable.FlowableEmpty {
 + void subscribeActual(Subscriber<? super Object> s) 
+ Object call() 
 
}
class io.reactivex.internal.operators.flowable.FlowableError {
 + void subscribeActual(Subscriber<? super T> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableFilter {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onNext(T t) 
+ boolean tryOnNext(T t) 
+ int requestFusion(int mode) 
+ T poll() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFilterTest {
 + void testFilter() 
+ void testWithBackpressure() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String t) 
+ void testWithBackpressure2() 
+ void onNext(Integer t) 
+ void testFatalError() 
+ void accept(Integer t) 
+ void functionCrashUnsubscribes() 
+ void doesntRequestOnItsOwn() 
+ void conditional() 
+ void conditionalNone() 
+ void conditionalNone2() 
+ void conditionalFusedSync() 
+ void conditionalFusedSync2() 
+ void conditionalFusedAsync() 
+ void conditionalFusedNoneAsync() 
+ void conditionalFusedNoneAsync2() 
+ void sourceIgnoresCancelConditional() 
+ boolean test(Integer v) 
+ void mapCrashesBeforeFilter() 
+ Integer apply(Integer v) 
+ void syncFused() 
+ void syncNoneFused() 
+ void syncNoneFused2() 
+ void sourceIgnoresCancel() 
+ void sourceIgnoresCancel2() 
+ void sourceIgnoresCancelConditional2() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void fusedSync() 
+ void fusedAsync() 
+ void fusedReject() 
+ void filterThrows() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFirstTest {
 + boolean test(String value) 
+ void before() 
+ void testFirstOrElseOfNoneFlowable() 
+ void testFirstOrElseOfSomeFlowable() 
+ void testFirstOrElseWithPredicateOfNoneMatchingThePredicateFlowable() 
+ void testFirstOrElseWithPredicateOfSomeFlowable() 
+ void testFirstFlowable() 
+ void testFirstWithOneElementFlowable() 
+ void testFirstWithEmptyFlowable() 
+ void testFirstWithPredicateFlowable() 
+ void testFirstWithPredicateAndOneElementFlowable() 
+ void testFirstWithPredicateAndEmptyFlowable() 
+ void testFirstOrDefaultFlowable() 
+ void testFirstOrDefaultWithOneElementFlowable() 
+ void testFirstOrDefaultWithEmptyFlowable() 
+ void testFirstOrDefaultWithPredicateFlowable() 
+ void testFirstOrDefaultWithPredicateAndOneElementFlowable() 
+ void testFirstOrDefaultWithPredicateAndEmptyFlowable() 
+ void testFirstOrElseOfNone() 
+ void testFirstOrElseOfSome() 
+ void testFirstOrElseWithPredicateOfNoneMatchingThePredicate() 
+ void testFirstOrElseWithPredicateOfSome() 
+ void testFirst() 
+ void testFirstWithOneElement() 
+ void testFirstWithEmpty() 
+ void testFirstWithPredicate() 
+ void testFirstWithPredicateAndOneElement() 
+ void testFirstWithPredicateAndEmpty() 
+ void testFirstOrDefault() 
+ void testFirstOrDefaultWithOneElement() 
+ void testFirstOrDefaultWithEmpty() 
+ void testFirstOrDefaultWithPredicate() 
+ void testFirstOrDefaultWithPredicateAndOneElement() 
+ void testFirstOrDefaultWithPredicateAndEmpty() 
+ void firstOrErrorNoElement() 
+ void firstOrErrorOneElement() 
+ void firstOrErrorMultipleElements() 
+ void firstOrErrorError() 
+ void firstOrErrorNoElementFlowable() 
+ void firstOrErrorOneElementFlowable() 
+ void firstOrErrorMultipleElementsFlowable() 
+ void firstOrErrorErrorFlowable() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMap {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(U t) 
+ void dispose() 
+ boolean isDisposed() 
~    final boolean delayErrors;
~    final int maxConcurrency;
~    final int bufferSize;
~        final boolean delayErrors;
~        final int maxConcurrency;
~        final int bufferSize;
~        final int scalarLimit;
~        final long id;
~        final int limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable {
 # void subscribeActual(Subscriber<? super T> observer) 
+ void onSubscribe(Subscription s) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ int requestFusion(int mode) 
+ void onSubscribe(Disposable d) 
+ void dispose() 
+ boolean isDisposed() 
~    final int maxConcurrency;
~    final boolean delayErrors;
~        final AtomicThrowable errors;
~        final boolean delayErrors;
~        final CompositeDisposable set;
~        final int maxConcurrency;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable {
 # void subscribeActual(CompletableObserver observer) 
+ Flowable<T> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
~    final Flowable<T> source;
~    final int maxConcurrency;
~    final boolean delayErrors;
~        final CompletableObserver actual;
~        final AtomicThrowable errors;
~        final boolean delayErrors;
~        final CompositeDisposable set;
~        final int maxConcurrency;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableTest {
 + void normalFlowable() 
+ void mapperThrowsFlowable() 
+ void mapperReturnsNullFlowable() 
+ void normalDelayErrorFlowable() 
+ void normalAsyncFlowable() 
+ void normalAsyncFlowableMaxConcurrency() 
+ void normalDelayErrorAllFlowable() 
+ void normalDelayInnerErrorAllFlowable() 
+ void normalNonDelayErrorOuterFlowable() 
+ void fusedFlowable() 
+ void normal() 
+ void mapperThrows() 
+ void mapperReturnsNull() 
+ void normalDelayError() 
+ void normalAsync() 
+ void normalDelayErrorAll() 
+ void normalDelayInnerErrorAll() 
+ void normalNonDelayErrorOuter() 
+ void fused() 
+ void disposed() 
+ void normalAsyncMaxConcurrency() 
+ void disposedFlowable() 
+ void badSource() 
+ void fusedInternalsFlowable() 
+ void onSubscribe(Subscription d) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void innerObserverFlowable() 
+ void badSourceFlowable() 
+ void innerObserver() 
+ void delayErrorMaxConcurrency() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(R value) 
+ void onError(Throwable e) 
+ boolean isDisposed() 
+ void dispose() 
~    final boolean delayErrors;
~    final int maxConcurrency;
~        final boolean delayErrors;
~        final int maxConcurrency;
~        final AtomicLong requested;
~        final CompositeDisposable set;
~        final AtomicInteger active;
~        final AtomicThrowable errors;
~        final AtomicReference<SpscLinkedArrayQueue<R>> queue;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapMaybeTest {
 + void normal() 
+ void normalEmpty() 
+ void normalDelayError() 
+ void normalAsync() 
+ void normalAsyncMaxConcurrency() 
+ void normalAsyncMaxConcurrency1() 
+ void mapperThrowsFlowable() 
+ void mapperReturnsNullFlowable() 
+ void normalDelayErrorAll() 
+ void normalBackpressured() 
+ void normalMaxConcurrent1Backpressured() 
+ void normalMaxConcurrent2Backpressured() 
+ void takeAsync() 
+ void take() 
+ void middleError() 
+ MaybeSource<Integer> apply(final String s) 
+ void disposed() 
+ void asyncFlatten() 
+ void asyncFlattenNone() 
+ void asyncFlattenNoneMaxConcurrency() 
+ void asyncFlattenErrorMaxConcurrency() 
+ void successError() 
+ void completeError() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void badInnerSource() 
+ void emissionQueueTrigger() 
+ MaybeSource<Integer> apply(PublishProcessor<Integer> v) 
+ void emissionQueueTrigger2() 
+ void disposeInner() 
+ void innerSuccessCompletesAfterMain() 
+ void backpressure() 
+ void error() 
+ void errorDelayed() 
+ void requestCancelRace() 
+ void run() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapPublisher {
 # void subscribeActual(Subscriber<? super U> s) 
~    final Publisher<T> source;
~    final boolean delayErrors;
~    final int maxConcurrency;
~    final int bufferSize;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapSingle {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(R value) 
+ void onError(Throwable e) 
+ boolean isDisposed() 
+ void dispose() 
~    final boolean delayErrors;
~    final int maxConcurrency;
~        final boolean delayErrors;
~        final int maxConcurrency;
~        final AtomicLong requested;
~        final CompositeDisposable set;
~        final AtomicInteger active;
~        final AtomicThrowable errors;
~        final AtomicReference<SpscLinkedArrayQueue<R>> queue;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapSingleTest {
 + void normal() 
+ void normalDelayError() 
+ void normalAsync() 
+ void normalAsyncMaxConcurrency() 
+ void normalAsyncMaxConcurrency1() 
+ void mapperThrowsFlowable() 
+ void mapperReturnsNullFlowable() 
+ void normalDelayErrorAll() 
+ void normalBackpressured() 
+ void normalMaxConcurrent1Backpressured() 
+ void normalMaxConcurrent2Backpressured() 
+ void takeAsync() 
+ void take() 
+ void middleError() 
+ SingleSource<Integer> apply(final String s) 
+ void asyncFlatten() 
+ void successError() 
+ void disposed() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void badInnerSource() 
+ void emissionQueueTrigger() 
+ SingleSource<Integer> apply(PublishProcessor<Integer> v) 
+ void disposeInner() 
+ void innerSuccessCompletesAfterMain() 
+ void backpressure() 
+ void error() 
+ void errorDelayed() 
+ void requestCancelRace() 
+ void run() 
+ void asyncFlattenErrorMaxConcurrency() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFlatMapTest {
 + void testNormal() 
+ Integer apply(Integer t1, Integer t2) 
+ void testCollectionFunctionThrows() 
+ void testResultFunctionThrows() 
+ void testMergeError() 
+ R apply(T t1) 
+ R call() 
+ void testFlatMapTransformsNormal() 
+ void testFlatMapTransformsException() 
+ R apply(T t) 
+ void testFlatMapTransformsOnNextFuncThrows() 
+ void testFlatMapTransformsOnErrorFuncThrows() 
+ void testFlatMapTransformsOnCompletedFuncThrows() 
+ void testFlatMapTransformsMergeException() 
+ void accept(Subscription s) 
+ void run() 
+ void testFlatMapMaxConcurrent() 
+ void testFlatMapSelectorMaxConcurrent() 
+ void testFlatMapTransformsMaxConcurrentNormalLoop() 
+ void testFlatMapTransformsMaxConcurrentNormal() 
+ void flatMapRangeAsyncLoop() 
+ Flowable<Integer> apply(Integer t) 
+ void flatMapRangeMixedAsyncLoop() 
+ void flatMapIntPassthruAsync() 
+ void flatMapTwoNestedSync() 
+ void justEmptyMixture() 
+ void rangeEmptyMixture() 
+ void justEmptyMixtureMaxConcurrent() 
+ void rangeEmptyMixtureMaxConcurrent() 
+ void castCrashUnsubscribes() 
+ void flatMapBiMapper() 
+ Integer apply(Integer a, Integer b) 
+ void flatMapBiMapperWithError() 
+ void flatMapBiMapperMaxConcurrency() 
+ void flatMapEmpty() 
+ void mergeScalar() 
+ void mergeScalar2() 
+ void mergeScalarEmpty() 
+ void mergeScalarError() 
+ void scalarReentrant() 
+ void scalarReentrant2() 
+ void innerCompleteCancelRace() 
+ void fusedInnerThrows() 
+ void fusedInnerThrows2() 
+ void scalarXMap() 
+ void noCrossBoundaryFusion() 
+ Object apply(Integer v) 
+ void cancelScalarDrainRace() 
+ void cancelDrainRace() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFlattenIterable {
 + void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void clear() 
+ boolean isEmpty() 
+ R poll() 
+ int requestFusion(int requestedMode) 
~    final int prefetch;
~        final int prefetch;
~        final int limit;
~        final AtomicLong requested;
~        final AtomicReference<Throwable> error;
 
}
class io.reactivex.internal.operators.flowable.FlowableFlattenIterableTest {
 + void normal0() 
+ Iterable<Integer> apply(Integer v) 
+ void normal() 
+ void normalViaFlatMap() 
+ void normalBackpressured() 
+ void longRunning() 
+ void asIntermediate() 
+ void just() 
+ void justHidden() 
+ void empty() 
+ void error() 
+ void iteratorHasNextThrowsImmediately() 
+ Integer next() 
+ void remove() 
+ void iteratorHasNextThrowsImmediatelyJust() 
+ void iteratorHasNextThrowsSecondCall() 
+ void iteratorNextThrows() 
+ void iteratorNextThrowsAndUnsubscribes() 
+ void mixture() 
+ void emptyInnerThenSingleBackpressured() 
+ void manyEmptyInnerThenSingleBackpressured() 
+ void hasNextIsNotCalledAfterChildUnsubscribedOnNext() 
+ void normalPrefetchViaFlatMap() 
+ void withResultSelectorMaxConcurrent() 
+ Integer apply(Integer a, Integer b) 
+ void flatMapIterablePrefetch() 
+ void dispose() 
+ void badSource() 
+ void callableThrows() 
+ void fusionMethods() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void smallPrefetch() 
+ void smallPrefetch2() 
+ void mixedInnerSource() 
+ void mixedInnerSource2() 
+ void fusionRejected() 
+ void fusedIsEmptyWithEmptySource() 
+ void onSubscribe(Subscription s) 
+ void fusedSourceCrash() 
+ void take() 
+ void overflowSource() 
+ void oneByOne() 
+ void cancelAfterHasNext() 
+ void doubleShare() 
+ void multiShare() 
+ void multiShareHidden() 
 
}
class io.reactivex.internal.operators.flowable.FlowableForEachTest {
 + void forEachWile() 
+ boolean test(Integer v) 
+ void forEachWileWithError() 
+ void accept(Throwable e) 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromArray {
 + void subscribeActual(Subscriber<? super T> s) 
+ final int requestFusion(int mode) 
+ final T poll() 
+ final boolean isEmpty() 
+ final void clear() 
+ final void request(long n) 
+ final void cancel() 
~{abstract} void fastPath()
~    final T[] array;
~        final T[] array;
 
}
class io.reactivex.internal.operators.flowable.FlowableFromArrayTest {
 + void simple() 
+ void backpressure() 
+ void conditionalBackpressure() 
+ void empty() 
+ void just() 
+ void just10Arguments() 
+ void badRequest() 
+ void conditionalOneIsNull() 
+ void conditionalOneIsNullSlowPath() 
+ void conditionalOneByOne() 
+ void conditionalFiltered() 
+ boolean test(Integer v) 
+ void conditionalSlowPathCancel() 
+ void onNext(Integer t) 
+ void conditionalSlowPathSkipCancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromCallable {
 + void subscribeActual(Subscriber<? super T> s) 
+ T call() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromCallableTest {
 + void shouldNotInvokeFuncUntilSubscription() 
+ void shouldCallOnNextAndOnCompleted() 
+ void shouldCallOnError() 
+ void shouldNotDeliverResultIfSubscriberUnsubscribedBeforeEmission() 
+ void shouldAllowToThrowCheckedException() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromFuture {
 + void subscribeActual(Subscriber<? super T> s) 
~    final long timeout;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.flowable.FlowableFromIterable {
 + void subscribeActual(Subscriber<? super T> s) 
+ final int requestFusion(int mode) 
+ final T poll() 
+ final boolean isEmpty() 
+ final void clear() 
+ final void request(long n) 
+ final void cancel() 
~{abstract} void fastPath()
 
}
class io.reactivex.internal.operators.flowable.FlowableFromIterableTest {
 + void testNull() 
+ void testListIterable() 
+ void testRawIterable() 
+ String next() 
+ void remove() 
+ void testObservableFromIterable() 
+ void testBackpressureViaRequest() 
+ void testNoBackpressure() 
+ void testSubscribeMultipleTimes() 
+ void testFromIterableRequestOverflow() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testFromEmptyIterableWhenZeroRequestedShouldStillEmitOnCompletedEagerly() 
+ void onNext(Object t) 
+ void testDoesNotCallIteratorHasNextMoreThanRequiredWithBackpressure() 
+ boolean hasNext() 
+ Integer next() 
+ void testDoesNotCallIteratorHasNextMoreThanRequiredFastPath() 
+ void getIteratorThrows() 
+ void hasNextThrowsImmediately() 
+ void hasNextThrowsSecondTimeFastpath() 
+ void hasNextThrowsSecondTimeSlowpath() 
+ void nextThrowsFastpath() 
+ void nextThrowsSlowpath() 
+ void deadOnArrival() 
+ void fusionWithConcatMap() 
+ void fusedAPICalls() 
+ void onError(Throwable t) 
+ void normalConditional() 
+ void normalConditionalBackpressured() 
+ void normalConditionalBackpressured2() 
+ void emptyConditional() 
+ void nullConditional() 
+ void nullConditionalBackpressured() 
+ void normalConditionalCrash() 
+ void normalConditionalCrash2() 
+ void normalConditionalCrashBackpressured() 
+ void normalConditionalCrashBackpressured2() 
+ void normalConditionalLong() 
+ void normalConditionalLong2() 
+ void requestRaceConditional() 
+ void requestRaceConditional2() 
+ void requestCancelConditionalRace() 
+ void run() 
+ void requestCancelConditionalRace2() 
+ void requestCancelRace() 
+ void requestCancelRace2() 
+ void fusionRejected() 
+ void fusionClear() 
+ void onNext(Integer value) 
+ void iteratorThrows() 
+ void hasNext2Throws() 
+ void hasNextCancels() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromObservable {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(T value) 
+ void onSubscribe(Disposable d) 
+ void cancel() 
+ void request(long n) 
    - final Observable<T> upstream;
        - Disposable d;
 
}
class io.reactivex.internal.operators.flowable.FlowableFromObservableTest {
 + void dispose() 
+ void error() 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromPublisher {
 # void subscribeActual(Subscriber<? super T> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableFromSourceTest {
 + void before() 
+ void normalBuffered() 
+ void normalDrop() 
+ void normalLatest() 
+ void normalMissing() 
+ void normalMissingRequested() 
+ void normalError() 
+ void errorBuffered() 
+ void errorLatest() 
+ void errorMissing() 
+ void unsubscribedBuffer() 
+ void unsubscribedLatest() 
+ void unsubscribedError() 
+ void unsubscribedDrop() 
+ void unsubscribedMissing() 
+ void unsubscribedNoCancelBuffer() 
+ void unsubscribedNoCancelLatest() 
+ void unsubscribedNoCancelError() 
+ void unsubscribedNoCancelDrop() 
+ void unsubscribedNoCancelMissing() 
+ void deferredRequest() 
+ void take() 
+ void takeOne() 
+ void requestExact() 
+ void takeNoCancel() 
+ void takeOneNoCancel() 
+ void unsubscribeNoCancel() 
+ void unsubscribeInline() 
+ void completeInline() 
+ void errorInline() 
+ void requestInline() 
+ void unsubscribeInlineLatest() 
+ void unsubscribeInlineExactLatest() 
+ void completeInlineLatest() 
+ void completeInlineExactLatest() 
+ void errorInlineLatest() 
+ void requestInlineLatest() 
+ void subscribe(final FlowableEmitter<Integer> t) 
+ void onError(Throwable e) 
+ void onNext(Integer v) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(Integer t) 
+ void onComplete() 
~        final PublishProcessor<Integer> subject;
 
}
class io.reactivex.internal.operators.flowable.FlowableGenerate {
 + void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
- void dispose(S s) 
+ void cancel() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Callable<S> stateSupplier;
 
}
class io.reactivex.internal.operators.flowable.FlowableGenerateTest {
 + void statefulBiconsumer() 
+ void accept(Object s, Emitter<Object> e) 
+ void accept(Object d) 
+ void stateSupplierThrows() 
+ void generatorThrows() 
+ void disposerThrows() 
+ void dispose() 
+ void nullError() 
+ void accept(Integer s, Emitter<Object> e) 
+ void badRequest() 
+ void rebatchAndTake() 
+ void backpressure() 
+ void requestRace() 
+ void run() 
+ void multipleOnNext() 
+ void multipleOnError() 
+ void multipleOnComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableGroupBy {
 # void subscribeActual(Subscriber<? super GroupedFlowable<K, V>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void cancel(K key) 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
# void subscribeActual(Subscriber<? super T> s) 
+ void onError(Throwable e) 
+ void subscribe(Subscriber<? super T> s) 
+ T poll() 
~    final int bufferSize;
~    final boolean delayError;
~        final int bufferSize;
~        final boolean delayError;
~        final K key;
~        final SpscLinkedArrayQueue<T> queue;
 
}
class io.reactivex.internal.operators.flowable.FlowableGroupByTest {
 + Integer apply(String s) 
+ void testGroupBy() 
+ void testGroupByWithElementSelector() 
+ void testGroupByWithElementSelector2() 
+ void testEmpty() 
+ void testError() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void accept(final GroupedFlowable<K, V> o) 
+ void testGroupedEventStream() 
+ Integer apply(Event e) 
+ Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) 
+ void onNext(String outputMessage) 
+ void testUnsubscribeOnNestedTakeAndSyncInfiniteStream() 
+ void testUnsubscribeOnNestedTakeAndAsyncInfiniteStream() 
- void doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(Flowable<Event> es, AtomicInteger subscribeCounter) 
+ void testUnsubscribeViaTakeOnGroupThenMergeAndTake() 
+ void accept(String s) 
+ void testUnsubscribeViaTakeOnGroupThenTakeOnInner() 
+ String apply(Event event) 
+ void testStaggeredCompletion() 
+ Flowable<Integer> apply(GroupedFlowable<Integer, Integer> group) 
+ void onNext(Integer s) 
+ void testCompletionIfInnerNotSubscribed() 
+ void onNext(GroupedFlowable<Integer, Integer> s) 
+ void testIgnoringGroups() 
+ void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete() 
+ Integer apply(Integer t) 
+ Flowable<String> apply(final GroupedFlowable<Integer, Integer> group) 
+ void run() 
+ String apply(Integer t1) 
+ void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes() 
+ void accept(Notification<String> t1) 
+ void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenObservesOnAndDelaysAndThenCompletes() 
+ void testGroupsWithNestedSubscribeOn() 
+ void testGroupsWithNestedObserveOn() 
+ String toString() 
+ void subscribe(final Subscriber<? super Event> op) 
+ void testGroupByOnAsynchronousSourceAcceptsMultipleSubscriptions() 
+ Boolean apply(Long n) 
+ Boolean apply(Integer n) 
+ void testGroupByBackpressure() 
+ R apply(T t1) 
+ T apply(Integer t1) 
+ Integer apply(Integer t1) 
+ Integer apply(Integer v) 
+ void normalBehavior() 
+ String apply(String t1) 
+ Publisher<String> apply(final GroupedFlowable<String, String> g) 
+ void keySelectorThrows() 
+ void valueSelectorThrows() 
+ void innerEscapeCompleted() 
+ void testExceptionIfSubscribeToChildMoreThanOnce() 
+ void testError2() 
+ void testgroupByBackpressure() 
+ String apply(Integer l) 
+ void testgroupByBackpressure2() 
+ Flowable<String> apply(final GroupedFlowable<Boolean, Integer> g) 
+ Flowable<Integer> apply(GroupedFlowable<Integer, Integer> t) 
+ void testGroupByWithNullKey() 
+ String apply(String value) 
+ void accept(GroupedFlowable<String, String> groupedFlowable) 
+ void testGroupByUnsubscribe() 
+ Integer apply(Integer integer) 
+ void testGroupByShouldPropagateError() 
+ void onNext(GroupedFlowable<Integer, Integer> o) 
+ void subscribe(Subscriber<? super Integer> subscriber) 
+ Integer apply(Integer i) 
+ void testRequestOverflow() 
+ Flowable<Integer> apply(GroupedFlowable<Integer, Integer> g) 
+ void onStart() 
+ void onNext(Integer t) 
+ void testBackpressureObserveOnOuter() 
+ void testBackpressureInnerDoesntOverflowOuter() 
+ void accept(GroupedFlowable<Integer, Integer> g) 
+ void testOneGroupInnerRequestsTwiceBuffer() 
+ void accept(GroupedFlowable<Object, Integer> g) 
+ void outerInnerFusion() 
+ void keySelectorAndDelayError() 
+ void keyAndValueSelectorAndDelayError() 
+ void dispose() 
+ void reentrantComplete() 
+ void reentrantCompleteCancel() 
+ void delayErrorSimpleComplete() 
+ void mainFusionRejected() 
+ void badSource() 
+ void badRequest() 
+ void doubleOnSubscribe() 
+ void nullKeyTakeInner() 
+ Publisher<Integer> apply(GroupedFlowable<Object, Integer> g) 
+ void errorFused() 
+ void errorFusedDelayed() 
+ void groupError() 
+ void groupComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableGroupJoin {
 # void subscribeActual(Subscriber<? super R> s) 
+ void request(long n) 
+ void cancel() 
+ void innerError(Throwable ex) 
+ void innerComplete(LeftRightSubscriber sender) 
+ void innerValue(boolean isLeft, Object o) 
+ void innerClose(boolean isLeft, LeftRightEndSubscriber index) 
+ void innerCloseError(Throwable ex) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final AtomicLong requested;
~        final SpscLinkedArrayQueue<Object> queue;
~        final CompositeDisposable disposables;
~        final AtomicReference<Throwable> error;
~        final AtomicInteger active;
~        final JoinSupport parent;
~        final boolean isLeft;
~        final int index;
 
}
class io.reactivex.internal.operators.flowable.FlowableGroupJoinTest {
 + Integer apply(Integer t1, Integer t2) 
+ Flowable<T> apply(Integer t1) 
+ Flowable<R> apply(T t1) 
+ Flowable<Integer> apply(final Integer leftValue, Flowable<Integer> rightValues) 
+ void before() 
+ void behaveAsJoin() 
+ void normal1() 
+ void onNext(final PPF ppf) 
+ void accept(PersonFruit t1) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(Subscription s) 
+ void leftThrows() 
+ void rightThrows() 
+ void leftDurationThrows() 
+ void rightDurationThrows() 
+ void leftDurationSelectorThrows() 
+ void rightDurationSelectorThrows() 
+ void resultSelectorThrows() 
+ void dispose() 
+ Flowable<Object> apply(Integer right) 
+ Object apply(Integer r, Flowable<Integer> l) 
+ void innerCompleteLeft() 
+ Flowable<Integer> apply(Integer r, Flowable<Integer> l) 
+ void innerErrorLeft() 
+ void innerCompleteRight() 
+ void innerErrorRight() 
+ void innerErrorRace() 
+ void run() 
+ void outerErrorRace() 
+ Flowable<Object> apply(Object right) 
+ Flowable<Object> apply(Object r, Flowable<Object> l) 
+ void rightEmission() 
~        final int id;
~        final String name;
~        final int personId;
~        final String fruit;
~        final Person person;
~        final Flowable<PersonFruit> fruits;
 
}
class io.reactivex.internal.operators.flowable.FlowableHide {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableIgnoreElements {
 # void subscribeActual(final Subscriber<? super T> t) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean offer(T e) 
+ boolean offer(T v1, T v2) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ void request(long n) 
+ void cancel() 
+ int requestFusion(int mode) 
 
}
class io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable {
 # void subscribeActual(final CompletableObserver t) 
+ Flowable<T> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.flowable.FlowableIgnoreElementsTest {
 + void testWithEmptyFlowable() 
+ void testWithNonEmptyFlowable() 
+ void testUpstreamIsProcessedButIgnoredFlowable() 
+ void testCompletedOkFlowable() 
+ void testErrorReceivedFlowable() 
+ void testUnsubscribesFromUpstreamFlowable() 
+ void testDoesNotHangAndProcessesAllUsingBackpressureFlowable() 
+ void accept(Integer t) 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testWithEmpty() 
+ void testWithNonEmpty() 
+ void testUpstreamIsProcessedButIgnored() 
+ void testCompletedOk() 
+ void testErrorReceived() 
+ void testUnsubscribesFromUpstream() 
+ void testDoesNotHangAndProcessesAllUsingBackpressure() 
+ void cancel() 
+ void fused() 
+ void fusedAPICalls() 
+ void onError(Throwable t) 
+ void dispose() 
 
}
class io.reactivex.internal.operators.flowable.FlowableInternalHelper {
 + S apply(S t1, Emitter<T> t2) 
+ Publisher<T> apply(final T v) 
+ void accept(T v) 
+ void accept(Throwable v) 
+ void run() 
+ R apply(U w) 
+ Publisher<R> apply(final T t) 
+ Publisher<U> apply(T t) 
+ void accept(Subscription t) 
+ ConnectableFlowable<T> call() 
+ Publisher<R> apply(Flowable<T> t) 
~        final Consumer<Emitter<T>> consumer;
~        final Subscriber<T> subscriber;
        - final T t;
        - final Flowable<T> parent;
        - final int bufferSize;
        - final long time;
        - final TimeUnit unit;
        - final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableInternalHelperTest {
 + void utilityClass() 
+ void requestMaxEnum() 
 
}
class io.reactivex.internal.operators.flowable.FlowableInterval {
 + void subscribeActual(Subscriber<? super Long> s) 
+ void request(long n) 
+ void cancel() 
+ void run() 
+ void setResource(Disposable d) 
~    final Scheduler scheduler;
~    final long initialDelay;
~    final long period;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.flowable.FlowableIntervalRange {
 + void subscribeActual(Subscriber<? super Long> s) 
+ void request(long n) 
+ void cancel() 
+ void run() 
+ void setResource(Disposable d) 
~    final Scheduler scheduler;
~    final long start;
~    final long end;
~    final long initialDelay;
~    final long period;
~    final TimeUnit unit;
~        final long end;
 
}
class io.reactivex.internal.operators.flowable.FlowableIntervalRangeTest {
 + void simple() 
+ void customScheduler() 
+ void countZero() 
+ void countNegative() 
+ void longOverflow() 
+ void dispose() 
+ void backpressureBounded() 
+ void backpressureOverflow() 
+ void badRequest() 
+ void take() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableIntervalTest {
 + void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableJoin {
 # void subscribeActual(Subscriber<? super R> s) 
+ void request(long n) 
+ void cancel() 
+ void innerError(Throwable ex) 
+ void innerComplete(LeftRightSubscriber sender) 
+ void innerValue(boolean isLeft, Object o) 
+ void innerClose(boolean isLeft, LeftRightEndSubscriber index) 
+ void innerCloseError(Throwable ex) 
~        final AtomicLong requested;
~        final SpscLinkedArrayQueue<Object> queue;
~        final CompositeDisposable disposables;
~        final AtomicReference<Throwable> error;
~        final AtomicInteger active;
 
}
class io.reactivex.internal.operators.flowable.FlowableJoinTest {
 + Integer apply(Integer t1, Integer t2) 
+ Flowable<T> apply(Integer t1) 
+ void before() 
+ void normal1() 
+ void normal1WithDuration() 
+ void normal2() 
+ void leftThrows() 
+ void rightThrows() 
+ void leftDurationThrows() 
+ void rightDurationThrows() 
+ void leftDurationSelectorThrows() 
+ void rightDurationSelectorThrows() 
+ void resultSelectorThrows() 
+ void dispose() 
+ void take() 
+ void rightClose() 
+ void resultSelectorThrows2() 
+ void badOuterSource() 
+ Integer apply(Integer a, Integer b) 
+ void badEndSource() 
# void subscribeActual(Subscriber<? super Integer> observer) 
+ void backpressureOverflowRight() 
+ void backpressureOverflowLeft() 
 
}
class io.reactivex.internal.operators.flowable.FlowableJust {
 # void subscribeActual(Subscriber<? super T> s) 
+ T call() 
    - final T value;
 
}
class io.reactivex.internal.operators.flowable.FlowableLastMaybe {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Publisher<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableLastSingle {
 # void subscribeActual(SingleObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Publisher<T> source;
~    final T defaultItem;
~        final T defaultItem;
 
}
class io.reactivex.internal.operators.flowable.FlowableLastTest {
 + void testLastWithElements() 
+ void testLastWithNoElements() 
+ void testLastMultiSubscribe() 
+ void testLastViaFlowable() 
+ void testLast() 
+ void testLastWithOneElement() 
+ void testLastWithEmpty() 
+ void testLastWithPredicate() 
+ void testLastWithPredicateAndOneElement() 
+ void testLastWithPredicateAndEmpty() 
+ void testLastOrDefault() 
+ void testLastOrDefaultWithOneElement() 
+ void testLastOrDefaultWithEmpty() 
+ void testLastOrDefaultWithPredicate() 
+ void testLastOrDefaultWithPredicateAndOneElement() 
+ void testLastOrDefaultWithPredicateAndEmpty() 
+ void lastOrErrorNoElement() 
+ void lastOrErrorOneElement() 
+ void lastOrErrorMultipleElements() 
+ void lastOrErrorError() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ Flowable<Object> apply(Flowable<Object> o) 
+ SingleSource<Object> apply(Flowable<Object> o) 
+ void error() 
+ void errorLastOrErrorFlowable() 
+ void emptyLastOrErrorFlowable() 
 
}
class io.reactivex.internal.operators.flowable.FlowableLift {
 + void subscribeActual(Subscriber<? super R> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableLiftTest {
 + void callbackCrash() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMap {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onNext(T t) 
+ int requestFusion(int mode) 
+ U poll() 
+ boolean tryOnNext(T t) 
 
}
class io.reactivex.internal.operators.flowable.FlowableMap.MapSubscriber
class io.reactivex.internal.operators.flowable.FlowableMapNotification {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMapNotification.MapNotificationSubscriber
class io.reactivex.internal.operators.flowable.FlowableMapNotificationTest {
 + void testJust() 
+ Flowable<Object> apply(Throwable e) 
+ Flowable<Object> call() 
+ void backpressure() 
+ Integer apply(Throwable e) 
+ Integer call() 
+ void noBackpressure() 
+ void dispose() 
# void subscribeActual(Subscriber<? super Integer> observer) 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMapPublisher {
 # void subscribeActual(Subscriber<? super U> s) 
~    final Publisher<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableMapTest {
 + String apply(String value, Integer index) 
+ void before() 
+ void testMap() 
+ void testMapMany() 
+ String apply(Map<String, String> map) 
+ void testMapMany2() 
+ void testMapWithError() 
+ void accept(Throwable t1) 
+ void testMapWithIssue417() 
+ void testMapWithErrorInFuncAndThreadPoolScheduler() 
+ void testErrorPassesThruMap() 
+ void testErrorPassesThruMap2() 
+ void testMapWithErrorInFunc() 
+ void verifyExceptionIsThrownIfThereIsNoExceptionHandler() 
+ Flowable<Object> apply(Object object) 
+ Object apply(Object object) 
+ void accept(Object object) 
+ void testShouldNotSwallowOnErrorNotImplementedException() 
+ Flowable<String> apply(String s) 
+ void accept(String s) 
+ Flowable<Object> call(Object object) 
+ Object call(Object object) 
+ void call(Object object) 
+ void functionCrashUnsubscribes() 
+ void mapFilter() 
+ boolean test(Integer v) 
+ void mapFilterMapperCrash() 
+ void mapFilterHidden() 
+ void mapFilterFused() 
+ void mapFilterFusedHidden() 
+ void sourceIgnoresCancel() 
+ Object apply(Integer v) 
+ void mapFilterMapperCrashFused() 
+ void sourceIgnoresCancelFilter() 
+ Integer apply(Integer v) 
+ void mapFilterFused2() 
+ void sourceIgnoresCancelConditional() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void fusedSync() 
+ void fusedAsync() 
+ void fusedReject() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMaterialize {
 # void subscribeActual(Subscriber<? super Notification<T>> s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
# void onDrop(Notification<T> n) 
 
}
class io.reactivex.internal.operators.flowable.FlowableMaterializeTest {
 + void testMaterialize1() 
+ void testMaterialize2() 
+ void testMultipleSubscribes() 
+ void testBackpressureOnEmptyStream() 
+ void testBackpressureNoError() 
+ void testBackpressureNoErrorAsync() 
+ void testBackpressureWithError() 
+ void testBackpressureWithEmissionThenError() 
+ void testWithCompletionCausingError() 
+ void testUnsubscribeJustBeforeCompletionNotificationShouldPreventThatNotificationArriving() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Notification<String> value) 
+ void subscribe(final Subscriber<? super String> observer) 
+ void backpressure() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void badRequest() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMergeDelayErrorTest {
 + void before() 
+ void testErrorDelayed1() 
+ void testErrorDelayed2() 
+ void testErrorDelayed3() 
+ void testErrorDelayed4() 
+ void testErrorDelayed4WithThreading() 
+ void testCompositeErrorDelayed1() 
+ void testCompositeErrorDelayed2() 
+ void testMergeFlowableOfFlowables() 
+ void testMergeArray() 
+ void testMergeList() 
+ void testMergeArrayWithThreading() 
+ void testSynchronousError() 
+ void onError(Throwable e) 
+ void onNext(String s) 
+ void subscribe(Subscriber<? super String> observer) 
+ void subscribe(final Subscriber<? super String> observer) 
+ void onComplete() 
+ void onNext(String args) 
+ void testMergeSourceWhichDoesntPropagateExceptionBack() 
+ void onNext(Integer t) 
+ void testErrorInParentFlowable() 
+ void testErrorInParentFlowableDelayed() 
+ void testDelayErrorMaxConcurrent() 
+ void mergeIterable() 
+ void iterableMaxConcurrent() 
+ void iterableMaxConcurrentError() 
+ void mergeMany() 
+ void mergeManyError() 
+ void array() 
+ void mergeArrayDelayError() 
+ void mergeIterableDelayErrorWithError() 
+ void mergeDelayError() 
+ void mergeDelayErrorWithError() 
+ void mergeDelayErrorMaxConcurrency() 
+ void mergeDelayErrorWithErrorMaxConcurrency() 
+ void mergeIterableDelayErrorMaxConcurrency() 
+ void mergeIterableDelayErrorWithErrorMaxConcurrency() 
+ void mergeDelayError3() 
+ void mergeDelayError3WithError() 
+ void mergeIterableDelayError() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMergeMaxConcurrentTest {
 + void before() 
+ void testWhenMaxConcurrentIsOne() 
+ void testMaxConcurrent() 
+ void subscribe(final Subscriber<? super String> t1) 
+ void testMergeALotOfSourcesOneByOneSynchronously() 
+ void testMergeALotOfSourcesOneByOneSynchronouslyTakeHalf() 
+ void testSimple() 
+ void testSimpleOneLess() 
+ void testSimpleAsyncLoop() 
+ void testSimpleAsync() 
+ void testSimpleOneLessAsyncLoop() 
+ void testSimpleOneLessAsync() 
+ void testBackpressureHonored() 
+ void testTake() 
        - final AtomicInteger subscriptionCount;
        - final int maxConcurrent;
 
}
class io.reactivex.internal.operators.flowable.FlowableMergeTest {
 + void before() 
+ void after() 
+ void testMergeFlowableOfFlowables() 
+ void testMergeArray() 
+ void testMergeList() 
+ void testUnSubscribeFlowableOfFlowables() 
+ void cancel() 
+ void run() 
+ void accept(Long v) 
+ void testMergeArrayWithThreading() 
+ void testSynchronizationOfMultipleSequencesLoop() 
+ void testSynchronizationOfMultipleSequences() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void testError1() 
+ void testError2() 
+ void testThrownErrorHandling() 
+ void subscribe(Subscriber<? super String> observer) 
+ void subscribe(final Subscriber<? super String> observer) 
+ void testUnsubscribeAsFlowablesComplete() 
+ void testEarlyUnsubscribe() 
- Flowable<Long> createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(final Scheduler scheduler, final AtomicBoolean unsubscribed) 
+ void onNext(Long t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void testConcurrency() 
+ void testConcurrencyWithSleeping() 
+ void testConcurrencyWithBrokenOnCompleteContract() 
+ void testBackpressureUpstream() 
+ void testBackpressureUpstream2InLoop() 
+ void testBackpressureUpstream2() 
+ void testBackpressureDownstreamWithConcurrentStreams() 
+ void testBackpressureBothUpstreamAndDownstreamWithSynchronousScalarFlowables() 
+ void onNext(Integer t) 
+ void testBackpressureBothUpstreamAndDownstreamWithRegularFlowables() 
+ void mergeWithNullValues() 
+ void mergeWithTerminalEventAfterUnsubscribe() 
+ void mergingNullFlowable() 
+ void merge1AsyncStreamOf1() 
+ void merge1AsyncStreamOf1000() 
+ void merge10AsyncStreamOf1000() 
+ void merge1000AsyncStreamOf1000() 
+ void merge2000AsyncStreamOf100() 
+ void merge100AsyncStreamOf1() 
- Flowable<Integer> mergeNAsyncStreamsOfN(final int outerSize, final int innerSize) 
+ void merge1SyncStreamOf1() 
+ void merge1SyncStreamOf1000000() 
+ void merge1000SyncStreamOf1000() 
+ void merge10000SyncStreamOf10() 
+ void merge1000000SyncStreamOf1() 
- Flowable<Integer> mergeNSyncStreamsOfN(final int outerSize, final int innerSize) 
- Flowable<Integer> createInfiniteFlowable(final AtomicInteger generated) 
+ Integer next() 
+ boolean hasNext() 
+ void mergeManyAsyncSingle() 
+ void shouldCompleteAfterApplyingBackpressure_NormalPath() 
+ void shouldCompleteAfterApplyingBackpressure_FastPath() 
+ void shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes() 
+ void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_NormalPath() 
+ void delayedErrorsShouldBeEmittedWhenCompleteAfterApplyingBackpressure_FastPath() 
+ void shouldNotCompleteWhileThereAreStillScalarSynchronousEmissionsInTheQueue() 
+ void shouldNotReceivedDelayedErrorWhileThereAreStillScalarSynchronousEmissionsInTheQueue() 
+ void shouldNotReceivedDelayedErrorWhileThereAreStillNormalEmissionsInTheQueue() 
+ void testMergeKeepsRequesting() 
+ void accept(long n) 
+ void testMergeRequestOverflow() 
- {static} Consumer<Integer> printCount() 
- {static} Consumer<Integer> pauseForMs(final long time) 
+ Flowable<Integer> apply(Integer v) 
+ Flowable<Integer> apply(Integer t) 
+ void testFastMergeFullScalar() 
+ void testFastMergeHiddenScalar() 
+ void testSlowMergeFullScalar() 
+ void testSlowMergeHiddenScalar() 
+ void negativeMaxConcurrent() 
+ void zeroMaxConcurrent() 
+ void mergeJustNull() 
+ void mergeConcurrentJustJust() 
+ void mergeConcurrentJustRange() 
+ void mergeMany() 
+ void mergeArrayMaxConcurrent() 
+ void flatMapJustJust() 
+ void flatMapJustRange() 
+ void flatMapMaxConcurrentJustJust() 
+ void flatMapMaxConcurrentJustRange() 
+ void noInnerReordering() 
+ void noOuterScalarReordering() 
+ void array() 
+ void mergeArray() 
+ void mergeErrors() 
 
}
class io.reactivex.internal.operators.flowable.FlowableMulticastTest {
 + void testMulticast() 
+ void testMulticastConnectTwice() 
+ void testMulticastDisconnect() 
 
}
class io.reactivex.internal.operators.flowable.FlowableNever {
 + void subscribeActual(Subscriber<? super Object> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableObserveOn {
 + void subscribeActual(Subscriber<? super T> s) 
+ final void onNext(T t) 
+ final void onError(Throwable t) 
+ final void onComplete() 
+ final void request(long n) 
+ final void cancel() 
~final void trySchedule() 
+ final void run() 
~{abstract} void runBackfused()
+ final int requestFusion(int requestedMode) 
+ final void clear() 
+ final boolean isEmpty() 
+ void onSubscribe(Subscription s) 
+ T poll() 
~final Scheduler scheduler;
~    final boolean delayError;
~    final int prefetch;
~        final Worker worker;
~        final boolean delayError;
~        final int prefetch;
~        final int limit;
~        final AtomicLong requested;
 
}
class io.reactivex.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber
class io.reactivex.internal.operators.flowable.FlowableObserveOnTest {
 + void testObserveOn() 
+ void testOrdering() 
+ void testThreadName() 
+ void accept(String t1) 
+ void run() 
+ void observeOnTheSameSchedulerTwice() 
+ void observeSameOnMultipleSchedulers() 
+ void testObserveOnWithNewThreadScheduler() 
+ void accept(Integer t1) 
+ void testObserveOnWithThreadPoolScheduler() 
+ void testObserveOnOrderingConcurrency() 
+ void testNonBlockingOuterWhileBlockingOnNext() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
- {static} int randomIntFrom0to100() 
+ void testDelayedErrorDeliveryWhenSafeSubscriberUnsubscribes() 
+ void testAfterUnsubscribeCalledThenObserverOnNextNeverCalled() 
+ void testBackpressureWithTakeAfter() 
+ Integer next() 
+ boolean hasNext() 
+ void testBackpressureWithTakeAfterAndMultipleBatches() 
+ void testBackpressureWithTakeBefore() 
+ void testQueueFullEmitsError() 
+ void onComplete() 
+ void testAsyncChild() 
+ void testOnErrorCutsAheadOfOnNext() 
+ void onNext(Long t) 
+ void testHotOperatorBackpressure() 
+ void testErrorPropagatesWhenNoOutstandingRequests() 
+ void accept(Notification<Long> n) 
+ Long apply(Long t1, Integer t2) 
+ void testRequestOverflow() 
+ void testNoMoreRequestsAfterUnsubscribe() 
+ void onStart() 
+ void testErrorDelayed() 
+ void testErrorDelayedAsync() 
+ void requestExactCompletesImmediately() 
+ void fixedReplenishPattern() 
+ void bufferSizesWork() 
+ void synchronousRebatching() 
+ void rebatchRequestsArgumentCheck() 
+ void delayError() 
+ void conditionalConsumer() 
+ void take() 
+ void cancelCleanup() 
+ void conditionalConsumerFused() 
+ void conditionalConsumerFusedReject() 
+ void requestOne() 
+ void requestOneConditional() 
+ void conditionalConsumerFusedAsync() 
+ void conditionalConsumerHidden() 
+ void conditionalConsumerBarrier() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void inputSyncFused() 
+ void inputAsyncFused() 
+ void inputAsyncFusedError() 
+ void inputAsyncFusedErrorDelayed() 
+ void outputFused() 
+ void outputFusedReject() 
+ void inputOutputAsyncFusedError() 
+ void inputOutputAsyncFusedErrorDelayed() 
+ void outputFusedCancelReentrant() 
+ void onNext(Integer value) 
+ void nonFusedPollThrows() 
+ boolean offer(Integer v1, Integer v2) 
+ Integer poll() 
+ boolean isEmpty() 
+ void clear() 
+ void conditionalNonFusedPollThrows() 
+ void asycFusedPollThrows() 
+ void conditionalAsyncFusedPollThrows() 
+ void trampolineScheduler() 
+ void conditionalNormal() 
+ void syncFusedCancelAfterRequest() 
+ void syncFusedCancelAfterRequest2() 
+ void syncFusedCancelAfterRequestConditional() 
+ void syncFusedCancelAfterRequestConditional2() 
+ void nonFusedCancelAfterRequestConditional2() 
+ void doubleObserveOn() 
+ void doubleObserveOnError() 
+ void doubleObserveOnConditional() 
+ void doubleObserveOnErrorConditional() 
+ void request1Conditional() 
+ void backFusedConditional() 
+ void backFusedErrorConditional() 
+ void backFusedCancelConditional() 
+ void syncFusedRequestOneByOneConditional() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ int requestFusion(int mode) 
+ T poll() 
+ void clear() 
+ boolean isEmpty() 
~    final int bufferSize;
~    final boolean unbounded;
~    final boolean delayError;
~    final Action onOverflow;
~        final SimplePlainQueue<T> queue;
~        final boolean delayError;
~        final Action onOverflow;
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategy {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final long bufferSize;
~    final Action onOverflow;
~    final BackpressureOverflowStrategy strategy;
~        final Action onOverflow;
~        final BackpressureOverflowStrategy strategy;
~        final long bufferSize;
~        final AtomicLong requested;
~        final Deque<T> deque;
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategyTest {
 + void backpressureWithBufferDropOldest() 
- TestSubscriber<Long> createTestSubscriber() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long t) 
+ void backpressureWithBufferDropLatest() 
+ void subscribe(Subscriber<? super Long> s) 
+ void backpressureBufferNegativeCapacity() 
+ void backpressureBufferZeroCapacity() 
+ void dispose() 
+ void error() 
+ void overflowError() 
+ void badSource() 
+ void doubleOnSubscribe() 
+ void overflowCrashes() 
+ void badRequest() 
+ void empty() 
+ void justTake() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferTest {
 + void testNoBackpressureSupport() 
+ void testFixBackpressureWithBuffer() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long t) 
+ void testFixBackpressureBufferNegativeCapacity() 
+ void testFixBackpressureBufferZeroCapacity() 
+ void testFixBackpressureBoundedBuffer() 
+ void run() 
+ void subscribe(Subscriber<? super Long> s) 
+ void nonFatalExceptionThrownByOnOverflowIsNotReportedByUpstream() 
+ void maxSize() 
+ void fixBackpressureBufferNegativeCapacity() 
+ void fixBackpressureBufferZeroCapacity() 
+ void fixBackpressureBufferNullStrategy() 
+ void noDelayError() 
+ void delayError() 
+ void delayErrorBuffer() 
+ void fusedNormal() 
+ void fusedError() 
+ void fusedPreconsume() 
+ void emptyDelayError() 
+ void fusionRejected() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop {
 + void accept(T t) 
# void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureDropTest {
 + void testNoBackpressureSupport() 
+ void testWithObserveOn() 
+ void testFixBackpressureWithBuffer() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long t) 
+ void testRequestOverflow() 
+ void subscribe(Subscriber<? super Long> s) 
- {static} Flowable<Long> range(final long n) 
+ void accept(Long n) 
+ void testNonFatalExceptionFromOverflowActionIsNotReportedFromUpstreamOperator() 
+ void badSource() 
+ void doubleOnSubscribe() 
+ void badRequest() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureError {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureErrorTest {
 + void dispose() 
+ void badRequest() 
+ void doubleOnSubscribe() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatestTest {
 + void testSimple() 
+ void testSimpleError() 
+ void testSimpleBackpressure() 
+ void testSynchronousDrop() 
+ void testAsynchronousDrop() 
+ void doubleOnSubscribe() 
+ void take() 
+ void dispose() 
+ void badRequest() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnErrorNext {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final boolean allowFatal;
~        final boolean allowFatal;
~        final SubscriptionArbiter arbiter;
 
}
class io.reactivex.internal.operators.flowable.FlowableOnErrorResumeNextViaFlowableTest {
 + void testResumeNext() 
+ void testMapResumeAsyncNext() 
+ void testResumeNextWithFailureOnSubscribe() 
+ void testResumeNextWithFailureOnSubscribeAsync() 
+ void subscribe(final Subscriber<? super String> observer) 
+ void testBackpressure() 
+ void normalBackpressure() 
~        final Subscription s;
~        final String[] values;
 
}
class io.reactivex.internal.operators.flowable.FlowableOnErrorResumeNextViaFunctionTest {
 + void testResumeNextWithSynchronousExecution() 
+ Flowable<String> apply(Throwable t1) 
+ void testResumeNextWithAsyncExecution() 
+ void testFunctionThrowsError() 
+ void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator() 
+ void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperatorOnNext() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testMapResumeAsyncNext() 
+ void subscribe(final Subscriber<? super String> observer) 
+ void testBackpressure() 
+ Integer apply(Integer t1) 
+ void normalBackpressure() 
+ void badOtherSource() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.flowable.FlowableOnErrorReturn {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableOnErrorReturnTest {
 + void testResumeNext() 
+ void testFunctionThrowsError() 
+ void testMapResumeAsyncNext() 
+ String apply(Throwable t1) 
+ void testBackpressure() 
+ Integer apply(Integer t1) 
+ void subscribe(final Subscriber<? super String> subscriber) 
+ void normalBackpressure() 
+ void returnItem() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void doubleOnError() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.flowable.FlowableOnExceptionResumeNextViaFlowableTest {
 + void testResumeNextWithException() 
+ void testResumeNextWithRuntimeException() 
+ void testThrowablePassesThru() 
+ void testErrorPassesThru() 
+ void testMapResumeAsyncNext() 
+ void testBackpressure() 
+ void subscribe(final Subscriber<? super String> observer) 
+ void normalBackpressure() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.flowable.FlowablePublish {
 + Publisher<T> source() 
# void subscribeActual(Subscriber<? super T> s) 
+ void connect(Consumer<? super Disposable> connection) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void request(long n) 
+ long produced(long n) 
+ void cancel() 
+ void subscribe(Subscriber<? super T> child) 
~    final Flowable<T> source;
~    final AtomicReference<PublishSubscriber<T>> current;
~    final int bufferSize;
~    final Publisher<T> onSubscribe;
~        final AtomicReference<PublishSubscriber<T>> current;
~        final int bufferSize;
~        final AtomicReference<InnerSubscriber[]> subscribers;
~        final AtomicBoolean shouldConnect;
        - final AtomicReference<PublishSubscriber<T>> curr;
        - final int bufferSize;
 
}
class io.reactivex.internal.operators.flowable.FlowablePublishFunctionTest {
 + void concatTakeFirstLastCompletes() 
+ void concatTakeFirstLastBackpressureCompletes() 
+ void canBeCancelled() 
+ void invalidPrefetch() 
+ void takeCompletes() 
+ void oneStartOnly() 
+ Flowable<Integer> apply(Flowable<Integer> o) 
+ void takeCompletesUnsafe() 
+ void directCompletesUnsafe() 
+ void overflowMissingBackpressureException() 
+ void overflowMissingBackpressureExceptionDelayed() 
+ void emptyIdentityMapped() 
+ void independentlyMapped() 
+ void badSource() 
+ void frontOverflow() 
+ void errorResubscribe() 
+ void fusedInputCrash() 
+ void error() 
+ void backpressuredEmpty() 
+ void oneByOne() 
+ void completeCancelRaceNoRequest() 
+ void inputOutputSubscribeRace() 
+ void inputOutputSubscribeRace2() 
+ void sourceSubscriptionDelayed() 
+ void run() 
+ void longFlow() 
+ boolean test(Integer w) 
+ void longFlow2() 
+ void longFlowHidden() 
 
}
class io.reactivex.internal.operators.flowable.FlowablePublishMulticast {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(R t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
# void subscribeActual(Subscriber<? super T> s) 
+ boolean isCancelled() 
~    final int prefetch;
~    final boolean delayError;
~        final AtomicInteger wip;
~        final AtomicReference<MulticastSubscription<T>[]> subscribers;
~        final int prefetch;
~        final int limit;
~        final boolean delayError;
~        final AtomicReference<Subscription> s;
~        final MulticastProcessor<T> parent;
 
}
class io.reactivex.internal.operators.flowable.FlowablePublishTest {
 + void testPublish() 
+ void accept(String v) 
+ void testBackpressureFastSlow() 
+ Integer apply(Integer i) 
+ void run() 
+ void testTakeUntilWithPublishedStreamUsingSelector() 
+ Flowable<Integer> apply(Flowable<Integer> xs) 
+ void testTakeUntilWithPublishedStream() 
+ void testBackpressureTwoConsumers() 
+ void onNext(Integer t) 
+ void testConnectWithNoSubscriber() 
+ void testSubscribeAfterDisconnectThenConnect() 
+ void testNoSubscriberRetentionOnCompleted() 
+ void testNonNullConnection() 
+ void testNoDisconnectSomeoneElse() 
~{static} boolean checkPublishDisposed(Disposable d) 
+ void testZeroRequested() 
+ void testConnectIsIdempotent() 
+ void syncFusedObserveOn() 
+ void syncFusedObserveOn2() 
+ void asyncFusedObserveOn() 
+ void testObserveOn() 
+ void source() 
+ void connectThrows() 
+ void addRemoveRace() 
+ void disposeOnArrival() 
+ void disposeOnArrival2() 
+ void dispose() 
+ void empty() 
+ void take() 
+ void just() 
+ void nextCancelRace() 
+ void badSource() 
+ void noErrorLoss() 
+ void subscribeDisconnectRace() 
+ void selectorDisconnectsIndependentSource() 
+ void selectorLatecommer() 
+ void mainError() 
+ void selectorInnerError() 
+ void preNextConnect() 
+ void connectRace() 
+ void selectorCrash() 
+ void pollThrows() 
+ void dryRunCrash() 
+ Object apply(Integer v) 
+ void overflowQueue() 
+ void delayedUpstreamOnSubscribe() 
# void subscribeActual(Subscriber<? super Integer> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableRange {
 + void subscribeActual(Subscriber<? super Integer> s) 
+ final int requestFusion(int mode) 
+ final Integer poll() 
+ final boolean isEmpty() 
+ final void clear() 
+ final void request(long n) 
+ final void cancel() 
~{abstract} void fastPath()
~    final int start;
~    final int end;
~        final int end;
 
}
class io.reactivex.internal.operators.flowable.FlowableRangeLong {
 + void subscribeActual(Subscriber<? super Long> s) 
+ final int requestFusion(int mode) 
+ final Long poll() 
+ final boolean isEmpty() 
+ final void clear() 
+ final void request(long n) 
+ final void cancel() 
~{abstract} void fastPath()
~    final long start;
~    final long end;
~        final long end;
 
}
class io.reactivex.internal.operators.flowable.FlowableRangeLongTest {
 + void testRangeStartAt2Count3() 
+ void testRangeUnsubscribe() 
+ void testRangeWithZero() 
+ void testRangeWithOverflow2() 
+ void testRangeWithOverflow3() 
+ void testRangeWithOverflow4() 
+ void testRangeWithOverflow5() 
+ void testBackpressureViaRequest() 
+ void testNoBackpressure() 
+ void testWithBackpressure1() 
+ void testWithBackpressureAllAtOnce() 
+ void testWithBackpressureRequestWayMore() 
+ void testRequestOverflow() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long t) 
+ void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() 
+ void testNearMaxValueWithoutBackpressure() 
+ void testNearMaxValueWithBackpressure() 
+ void negativeCount() 
+ void countOne() 
+ void fused() 
+ void fusedReject() 
+ void disposed() 
+ void fusedClearIsEmpty() 
+ void noOverflow() 
+ void conditionalNormal() 
+ void badRequest() 
+ void conditionalNormalSlowpath() 
+ void conditionalSlowPathTakeExact() 
+ void slowPathTakeExact() 
+ void conditionalSlowPathRebatch() 
+ void slowPathRebatch() 
+ void slowPathCancel() 
+ void fastPathCancel() 
+ void conditionalSlowPathCancel() 
+ void conditionalFastPathCancel() 
+ void conditionalRequestOneByOne() 
+ boolean test(Long v) 
+ void conditionalRequestOneByOne2() 
+ void fastPathCancelExact() 
+ void conditionalFastPathCancelExact() 
 
}
class io.reactivex.internal.operators.flowable.FlowableRangeTest {
 + void testRangeStartAt2Count3() 
+ void testRangeUnsubscribe() 
+ void testRangeWithZero() 
+ void testRangeWithOverflow2() 
+ void testRangeWithOverflow3() 
+ void testRangeWithOverflow4() 
+ void testRangeWithOverflow5() 
+ void testBackpressureViaRequest() 
+ void testNoBackpressure() 
+ void testWithBackpressure1() 
+ void testWithBackpressureAllAtOnce() 
+ void testWithBackpressureRequestWayMore() 
+ void testRequestOverflow() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() 
+ void testNearMaxValueWithoutBackpressure() 
+ void testNearMaxValueWithBackpressure() 
+ void negativeCount() 
+ void requestWrongFusion() 
+ void countOne() 
+ void fused() 
+ void fusedReject() 
+ void disposed() 
+ void fusedClearIsEmpty() 
+ void noOverflow() 
+ void conditionalNormal() 
+ void badRequest() 
+ void conditionalNormalSlowpath() 
+ void conditionalSlowPathTakeExact() 
+ void slowPathTakeExact() 
+ void conditionalSlowPathRebatch() 
+ void slowPathRebatch() 
+ void slowPathCancel() 
+ void fastPathCancel() 
+ void conditionalSlowPathCancel() 
+ void conditionalFastPathCancel() 
+ void conditionalRequestOneByOne() 
+ boolean test(Integer v) 
+ void conditionalRequestOneByOne2() 
+ void fastPathCancelExact() 
+ void conditionalFastPathCancelExact() 
+ void conditionalCancel1() 
+ void conditionalCancel2() 
 
}
class io.reactivex.internal.operators.flowable.FlowableReduce {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableReduceMaybe {
 + Publisher<T> source() 
+ Flowable<T> fuseToFlowable() 
# void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Flowable<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle {
 # void subscribeActual(SingleObserver<? super R> observer) 
+ void onSubscribe(Subscription s) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Publisher<T> source;
~    final R seed;
 
}
class io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle.ReduceSeedObserver
class io.reactivex.internal.operators.flowable.FlowableReduceTest {
 + void before() 
+ Integer apply(Integer t1, Integer t2) 
+ void testAggregateAsIntSumFlowable() 
+ void testAggregateAsIntSumSourceThrowsFlowable() 
+ void testAggregateAsIntSumAccumulatorThrowsFlowable() 
+ Integer apply(Integer v) 
+ void testAggregateAsIntSumResultSelectorThrowsFlowable() 
+ void testBackpressureWithInitialValueFlowable() 
+ void testAggregateAsIntSum() 
+ void testAggregateAsIntSumSourceThrows() 
+ void testAggregateAsIntSumAccumulatorThrows() 
+ void testAggregateAsIntSumResultSelectorThrows() 
+ void testBackpressureWithNoInitialValue() 
+ void testBackpressureWithInitialValue() 
+ void reducerCrashSuppressOnError() 
+ Integer apply(Integer a, Integer b) 
+ void cancel() 
+ void testBackpressureWithNoInitialValueObservable() 
+ void source() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
+ void errorFlowable() 
+ void empty() 
+ void emptyFlowable() 
+ void badSource() 
+ void badSourceFlowable() 
+ void reducerThrows() 
+ void shouldReduceTo10Events() 
+ String apply(String l, String r) 
+ void accept(String s) 
+ void shouldReduceTo10EventsFlowable() 
~{static} String blockingOp(Integer x, Integer y) 
 
}
class io.reactivex.internal.operators.flowable.FlowableReduceWithSingle {
 # void subscribeActual(SingleObserver<? super R> observer) 
~    final Publisher<T> source;
~    final Callable<R> seedSupplier;
 
}
class io.reactivex.internal.operators.flowable.FlowableReduceWithSingleTest {
 + void normal() 
+ void disposed() 
 
}
class io.reactivex.internal.operators.flowable.FlowableRefCount {
 + void onSubscribe(Subscription s) 
+ void onError(Throwable e) 
+ void onNext(T t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void subscribeActual(final Subscriber<? super T> subscriber) 
- Consumer<Disposable> onSubscribe(final Subscriber<? super T> subscriber,
            final AtomicBoolean writeLocked) 
- Disposable disconnect(final CompositeDisposable current) 
+ void accept(Disposable subscription) 
+ void run() 
~    final ConnectableFlowable<T> source;
~        final CompositeDisposable currentBase;
~        final Disposable resource;
~        final AtomicLong requested;
        - final AtomicBoolean writeLocked;
        - final CompositeDisposable current;
 
}
class io.reactivex.internal.operators.flowable.FlowableRefCountTest {
 + void testRefCountAsync() 
+ void accept(Long l) 
+ void testRefCountSynchronous() 
+ void accept(Integer l) 
+ void testRefCountSynchronousTake() 
+ void testRepeat() 
+ void run() 
+ void testConnectUnsubscribe() 
+ void testConnectUnsubscribeRaceConditionLoop() 
+ void testConnectUnsubscribeRaceCondition() 
+ void accept(Subscription s) 
- Flowable<Long> synchronousInterval() 
+ void cancel() 
+ void onlyFirstShouldSubscribeAndLastUnsubscribe() 
+ void testRefCount() 
+ void accept(Long t1) 
+ void testAlreadyUnsubscribedClient() 
+ void testAlreadyUnsubscribedInterleavesWithClient() 
+ void testConnectDisconnectConnectAndSubjectState() 
+ void testUpstreamErrorAllowsRetry() 
+ Publisher<String> apply(Long t1) 
+ Publisher<String> apply(Throwable t1) 
+ void accept(Throwable t1) 
+ void accept(String t1) 
+ void onSubscribe(Subscription s) 
+ void onNext(Integer o) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void disposed() 
+ void noOpConnect() 
+ void connect(Consumer<? super Disposable> connection) 
# void subscribeActual(Subscriber<? super Integer> observer) 
+ void replayNoLeak() 
+ void replayNoLeak2() 
+ void publishNoLeak() 
+ void publishNoLeak2() 
+ void replayIsUnsubscribed() 
        + final Object data;
 
}
class io.reactivex.internal.operators.flowable.FlowableRepeat {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final long count;
~        final SubscriptionArbiter sa;
 
}
class io.reactivex.internal.operators.flowable.FlowableRepeatTest {
 + void testRepetition() 
+ void testRepeatTake() 
+ void testNoStackOverFlow() 
+ void testRepeatTakeWithSubscribeOn() 
+ Integer apply(Integer t1) 
+ void testRepeatAndTake() 
+ void testRepeatLimited() 
+ void testRepeatError() 
+ void testRepeatZero() 
+ void testRepeatOne() 
+ void testRepeatAndDistinctUnbounded() 
+ void testRepeatRetarget() 
+ void repeatScheduled() 
+ void repeatWhenDefaultScheduler() 
+ void repeatWhenTrampolineScheduler() 
+ void repeatUntil() 
+ void repeatLongPredicateInvalid() 
+ void repeatUntilError() 
+ void repeatUntilFalse() 
+ void repeatUntilSupplierCrash() 
+ void shouldDisposeInnerObservable() 
+ void testRepeatWhen() 
+ void whenTake() 
 
}
class io.reactivex.internal.operators.flowable.FlowableRepeatUntil {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final BooleanSupplier until;
~        final SubscriptionArbiter sa;
~        final BooleanSupplier stop;
 
}
class io.reactivex.internal.operators.flowable.FlowableRepeatWhen {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ final void onSubscribe(Subscription s) 
+ final void onNext(T t) 
# final void again(U signal) 
+ final void cancel() 
~        final Publisher<T> source;
~        final AtomicReference<Subscription> subscription;
~        final AtomicLong requested;
        # final FlowableProcessor<U> processor;
        # final Subscription receiver;
        - long produced;
 
}
class io.reactivex.internal.operators.flowable.FlowableReplay {
 + Publisher<T> source() 
# void subscribeActual(Subscriber<? super T> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void connect(Consumer<? super Disposable> connection) 
+ void onSubscribe(Subscription p) 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void request(long n) 
+ long produced(long n) 
+ void cancel() 
+ void next(T value) 
+ void error(Throwable e) 
+ void complete() 
+ void replay(InnerSubscription<T> output) 
~final void addLast(Node n) 
~final void removeFirst() 
~final void removeSome(int n) 
~final void setFirst(Node n) 
+ final void next(T value) 
+ final void error(Throwable e) 
+ final void complete() 
+ final void replay(InnerSubscription<T> output) 
+ void subscribe(Subscriber<? super R> child) 
+ void accept(Disposable r) 
+ ReplayBuffer<T> call() 
+ void subscribe(Subscriber<? super T> child) 
+ Object call() 
~    final Flowable<T> source;
~    final AtomicReference<ReplaySubscriber<T>> current;
~    final Publisher<T> onSubscribe;
~        final ReplayBuffer<T> buffer;
~        final AtomicReference<InnerSubscription<T>[]> subscribers;
~        final AtomicBoolean shouldConnect;
~        final AtomicInteger management;
~        final ReplaySubscriber<T> parent;
~        final AtomicLong totalRequested;
~        final Object value;
~        final long index;
~        final int limit;
~        final Scheduler scheduler;
~        final long maxAge;
~        final TimeUnit unit;
            - final SubscriberResourceWrapper<R> srw;
        - final ConnectableFlowable<T> co;
        - final Flowable<T> observable;
        - final int bufferSize;
        - final long maxAge;
        - final TimeUnit unit;
        - final Scheduler scheduler;
        - final AtomicReference<ReplaySubscriber<T>> curr;
 
}
class io.reactivex.internal.operators.flowable.FlowableReplayTest {
 + void testBufferedReplay() 
+ void testBufferedWindowReplay() 
+ void testWindowedReplay() 
+ void testReplaySelector() 
+ Flowable<Integer> apply(Flowable<Integer> t1) 
+ void testBufferedReplaySelector() 
+ void testWindowedReplaySelector() 
+ void testBufferedReplayError() 
+ void testWindowedReplayError() 
+ void testSynchronousDisconnect() 
+ Flowable<Integer> apply(Flowable<Integer> o) 
+ void accept(Integer t1) 
+ void accept(Throwable t1) 
+ void run() 
+ void testIssue2191_UnsubscribeSource() 
+ void testIssue2191_SchedulerUnsubscribe() 
+ void testIssue2191_SchedulerUnsubscribeOnError() 
- {static} void verifyObserverMock(Subscriber<Integer> mock, int numSubscriptions, int numItemsExpected) 
- {static} void verifyObserver(Subscriber<Integer> mock, int numSubscriptions, int numItemsExpected, Throwable error) 
+ {static} Worker workerSpy(final Disposable mockDisposable) 
+ Disposable schedule(@NonNull Runnable action) 
+ Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) 
+ void dispose() 
+ boolean isDisposed() 
+ void testBoundedReplayBuffer() 
+ void testTimedAndSizedTruncation() 
+ void testBackpressure() 
+ void testBackpressureBounded() 
+ void testColdReplayNoBackpressure() 
+ void testColdReplayBackpressure() 
+ void testCache() 
+ void accept(String v) 
+ void testUnsubscribeSource() 
+ void testTake() 
+ void testAsync() 
+ void testAsyncComeAndGo() 
+ void testNoMissingBackpressureException() 
+ void testValuesAndThenError() 
+ void unsafeChildThrows() 
+ void onNext(Integer t) 
+ void unboundedLeavesEarly() 
+ void testSubscribersComeAndGoAtRequestBoundaries() 
+ void testSubscribersComeAndGoAtRequestBoundaries2() 
+ void replayScheduler() 
+ void replayTime() 
+ void replaySizeScheduler() 
+ void replaySizeAndTime() 
+ void replaySelectorSizeScheduler() 
+ void replaySelectorScheduler() 
+ void replaySelectorTime() 
+ void source() 
+ void connectRace() 
+ void subscribeRace() 
+ void addRemoveRace() 
+ void cancelOnArrival() 
+ void cancelOnArrival2() 
+ void connectConsumerThrows() 
+ void badSource() 
+ void subscribeOnNextRace() 
+ void unsubscribeOnNextRace() 
+ void unsubscribeReplayRace() 
+ void reentrantOnNext() 
+ void reentrantOnNextBound() 
+ void reentrantOnNextCancel() 
+ void reentrantOnNextCancelBounded() 
+ void replayMaxInt() 
+ void testTimedAndSizedTruncationError() 
+ void testSizedTruncation() 
+ void delayedUpstreamOnSubscribe() 
# void subscribeActual(Subscriber<? super Integer> s) 
+ void timedNoOutdatedData() 
        - final Disposable mockDisposable;
        + boolean unsubscribed;
 
}
class io.reactivex.internal.operators.flowable.FlowableRetryBiPredicate {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final SubscriptionArbiter sa;
 
}
class io.reactivex.internal.operators.flowable.FlowableRetryPredicate {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final long count;
~        final SubscriptionArbiter sa;
 
}
class io.reactivex.internal.operators.flowable.FlowableRetryTest {
 + void iterativeBackoff() 
+ Flowable<Object> apply(Flowable<? extends Throwable> attempts) 
+ Tuple apply(Tuple t, Tuple n) 
+ Flowable<Object> apply(Tuple t) 
+ void testRetryIndefinitely() 
+ void testSchedulingNotificationHandler() 
+ void accept(Throwable e) 
+ void testOnNextFromNotificationHandler() 
+ void testOnCompletedFromNotificationHandler() 
+ void testOnErrorFromNotificationHandler() 
+ void testSingleSubscriptionOnFirst() 
+ Flowable<Object> apply(Flowable<? extends Throwable> attempt) 
+ void testOriginFails() 
+ void testRetryFail() 
+ void testRetrySuccess() 
+ void testInfiniteRetry() 
+ void testRetrySubscribesAgainAfterError() 
+ void subscribe(final Subscriber<? super String> o) 
+ void cancel() 
+ void testUnsubscribeFromRetry() 
+ void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubscribed() 
+ void testSourceObservableCallsUnsubscribe() 
+ void testSourceObservableRetry1() 
+ void testSourceObservableRetry0() 
+ void subscribe(final Subscriber<? super Long> subscriber) 
+ void run() 
+ void await() 
+ void onComplete() 
+ void onError(Throwable t) 
+ void onNext(T v) 
+ void testUnsubscribeAfterError() 
+ void testTimeoutWithRetry() 
+ void testRetryWithBackpressure() 
+ void testRetryWithBackpressureParallel() 
+ void testIssue1900() 
+ String apply(String t1) 
+ Flowable<String> apply(GroupedFlowable<String, String> t1) 
+ void testIssue1900SourceNotSupportingBackpressure() 
+ void retryWhenDefaultScheduler() 
+ void retryWhenTrampolineScheduler() 
+ void retryPredicate() 
+ void retryLongPredicateInvalid() 
+ void retryUntil() 
+ void shouldDisposeInnerObservable() 
        - final int numFailures;
~        final AtomicInteger nextBeforeFailure;
        - final int emitDelay;
        # Subscriber<T> target;
 
}
class io.reactivex.internal.operators.flowable.FlowableRetryWhen {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.flowable.FlowableRetryWithPredicateTest {
 + boolean test(Integer t1, Throwable t2) 
+ void testWithNothingToRetry() 
+ void testRetryTwice() 
+ void testRetryTwiceAndGiveUp() 
+ void testRetryOnSpecificException() 
+ void testRetryOnSpecificExceptionAndNotOther() 
+ void testUnsubscribeFromRetry() 
+ void testUnsubscribeAfterError() 
+ void testTimeoutWithRetry() 
+ void testIssue2826() 
+ void testJustAndRetry() 
+ void testIssue3008RetryWithPredicate() 
+ void accept(Long t) 
+ void testIssue3008RetryInfinite() 
+ void testBackpressure() 
+ void predicateThrows() 
+ void dontRetry() 
+ void retryDisposeRace() 
+ void run() 
+ void bipredicateThrows() 
+ void retryBiPredicateDisposeRace() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSamplePublisher {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void error(Throwable e) 
+ void complete() 
~{abstract} void completeMain()
+ void onNext(Object t) 
~    final Publisher<T> source;
~    final boolean emitLast;
~        final SamplePublisherSubscriber<T> parent;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.flowable.FlowableSampleTest {
 + void before() 
+ void testSample() 
+ void run() 
+ void sampleWithSamplerNormal() 
+ void sampleWithSamplerNoDuplicates() 
+ void sampleWithSamplerTerminatingEarly() 
+ void sampleWithSamplerEmitAndTerminate() 
+ void sampleWithSamplerEmptySource() 
+ void sampleWithSamplerSourceThrows() 
+ void sampleWithSamplerThrows() 
+ void testSampleUnsubscribe() 
+ void dispose() 
+ void error() 
+ void backpressureOverflow() 
+ void backpressureOverflowWithOtherPublisher() 
+ void emitLastTimed() 
+ void emitLastTimedEmpty() 
+ void emitLastTimedCustomScheduler() 
+ void emitLastTimedRunCompleteRace() 
+ void emitLastOther() 
+ void emitLastOtherEmpty() 
+ void emitLastOtherRunCompleteRace() 
+ void emitLastOtherCompleteCompleteRace() 
    - TestScheduler scheduler;
    - Subscriber<Long> observer;
    - Subscriber<Object> observer2;
 
}
class io.reactivex.internal.operators.flowable.FlowableSampleTimed {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~{abstract} void complete()
+ void run() 
~    final long period;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final boolean emitLast;
~        final long period;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.flowable.FlowableScalarXMap {
 + void subscribeActual(Subscriber<? super R> s) 
~        final T value;
 
}
class io.reactivex.internal.operators.flowable.FlowableScalarXMapTest {
 + void utilityClass() 
+ void subscribe(Subscriber<? super Integer> s) 
+ Integer call() 
+ void tryScalarXMap() 
+ void emptyXMap() 
+ void mapperCrashes() 
+ void mapperToJust() 
+ void mapperToEmpty() 
+ void mapperToCrashingCallable() 
+ void scalarMapToEmpty() 
+ void scalarMapToCrashingCallable() 
+ void scalarDisposableStateCheck() 
+ void scalarDisposableRunDisposeRace() 
+ void run() 
+ void cancelled() 
 
}
class io.reactivex.internal.operators.flowable.FlowableScan {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableScanSeed {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
~    final Callable<R> seedSupplier;
~        final SimplePlainQueue<R> queue;
~        final AtomicLong requested;
~        final int prefetch;
~        final int limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableScanTest {
 + void testScanIntegersWithInitialValue() 
+ void testScanIntegersWithoutInitialValue() 
+ void testScanIntegersWithoutInitialValueAndOnlyOneValue() 
+ void shouldNotEmitUntilAfterSubscription() 
+ boolean test(Integer t1) 
+ void testBackpressureWithInitialValue() 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testBackpressureWithoutInitialValue() 
+ void testNoBackpressureWithInitialValue() 
+ void testSeedFactory() 
+ void accept(List<Integer> list, Integer t2) 
+ void testSeedFactoryFlowable() 
+ void testScanWithRequestOne() 
+ void testScanShouldNotRequestZero() 
+ void cancel() 
+ Integer apply(Integer t1, Integer t2) 
+ void onNext(Integer integer) 
+ void testInitialValueEmittedNoProducer() 
+ void testInitialValueEmittedWithProducer() 
+ void dispose() 
+ Integer apply(Integer a, Integer b) 
+ void doubleOnSubscribe() 
+ Flowable<Object> apply(Flowable<Object> o) 
+ void error() 
+ void neverSource() 
+ void testUnsubscribeScan() 
+ void accept(HashMap<String, String> v) 
+ void testScanWithSeedDoesNotEmitErrorTwiceIfScanFunctionThrows() 
+ void testScanWithSeedDoesNotEmitTerminalEventTwiceIfScanFunctionThrows() 
+ void testScanWithSeedDoesNotProcessOnNextAfterTerminalEventIfScanFunctionThrows() 
+ void testScanWithSeedCompletesNormally() 
+ void testScanWithSeedWhenScanSeedProviderThrows() 
+ void testScanNoSeed() 
+ void testScanNoSeedDoesNotEmitErrorTwiceIfScanFunctionThrows() 
+ void testScanNoSeedDoesNotEmitTerminalEventTwiceIfScanFunctionThrows() 
+ void testScanNoSeedDoesNotProcessOnNextAfterTerminalEventIfScanFunctionThrows() 
+ Integer apply(Integer n1, Integer n2) 
- {static} Callable<Integer> throwingCallable(final RuntimeException e) 
+ void scanEmptyBackpressured() 
+ void scanErrorBackpressured() 
+ void scanTake() 
+ void scanLong() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSequenceEqual {
 + void subscribeActual(Subscriber<? super Boolean> s) 
+ void cancel() 
+ void drain() 
+ void innerError(Throwable t) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request() 
~    final int prefetch;
~        final EqualSubscriber<T> first;
~        final EqualSubscriber<T> second;
~        final AtomicThrowable error;
~        final AtomicInteger wip;
~        final EqualCoordinatorHelper parent;
~        final int prefetch;
~        final int limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle {
 + void subscribeActual(SingleObserver<? super Boolean> s) 
+ Flowable<Boolean> fuseToFlowable() 
+ void dispose() 
+ boolean isDisposed() 
+ void drain() 
+ void innerError(Throwable t) 
~    final int prefetch;
~        final EqualSubscriber<T> first;
~        final EqualSubscriber<T> second;
~        final AtomicThrowable error;
 
}
class io.reactivex.internal.operators.flowable.FlowableSequenceEqualTest {
 + void test1Flowable() 
+ void test2Flowable() 
+ void test3Flowable() 
+ void testWithError1Flowable() 
+ void testWithError2Flowable() 
+ void testWithError3Flowable() 
+ void testWithEmpty1Flowable() 
+ void testWithEmpty2Flowable() 
+ void testWithEmpty3Flowable() 
+ void testWithNull1Flowable() 
+ void testWithNull2Flowable() 
+ void testWithEqualityErrorFlowable() 
+ void test1() 
+ void test2() 
+ void test3() 
+ void testWithError1() 
+ void testWithError2() 
+ void testWithError3() 
+ void testWithEmpty1() 
+ void testWithEmpty2() 
+ void testWithEmpty3() 
+ void testWithNull1() 
+ void testWithNull2() 
+ void testWithEqualityError() 
- void verifyResult(Flowable<Boolean> observable, boolean result) 
- void verifyResult(Single<Boolean> observable, boolean result) 
- void verifyError(Flowable<Boolean> observable) 
- void verifyError(Single<Boolean> observable) 
+ void prefetch() 
+ void disposed() 
+ void simpleInequal() 
+ void simpleInequalObservable() 
+ void onNextCancelRace() 
+ void run() 
+ void onNextCancelRaceObservable() 
+ void disposedFlowable() 
+ void prefetchFlowable() 
+ void longSequenceEqualsFlowable() 
+ void syncFusedCrashFlowable() 
+ void cancelAndDrainRaceFlowable() 
+ void sourceOverflowsFlowable() 
+ void doubleErrorFlowable() 
+ void longSequenceEquals() 
+ void syncFusedCrash() 
+ void cancelAndDrainRace() 
+ void sourceOverflows() 
+ void doubleError() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSerializeTest {
 + void before() 
+ void testSingleThreadedBasic() 
+ void testMultiThreadedBasic() 
+ void testMultiThreadedWithNPE() 
+ void testMultiThreadedWithNPEinMiddle() 
+ void run() 
+ void subscribe(final Subscriber<? super String> observer) 
+ void waitToFinish() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String args) 
        - final DefaultSubscriber<String> observer;
        - final int numStringsToSend;
        - final TestConcurrencyobserverEvent event;
~        final String[] values;
        - Thread t;
 
}
class io.reactivex.internal.operators.flowable.FlowableSerialized {
 # void subscribeActual(Subscriber<? super T> s) 
 
}
class io.reactivex.internal.operators.flowable.FlowableSingle {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
~    final T defaultValue;
~        final T defaultValue;
 
}
class io.reactivex.internal.operators.flowable.FlowableSingleMaybe {
 # void subscribeActual(MaybeObserver<? super T> s) 
+ Flowable<T> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
 
}
class io.reactivex.internal.operators.flowable.FlowableSingleSingle {
 # void subscribeActual(SingleObserver<? super T> s) 
+ Flowable<T> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~    final T defaultValue;
~        final T defaultValue;
 
}
class io.reactivex.internal.operators.flowable.FlowableSingleTest {
 + void testSingleFlowable() 
+ void testSingleWithTooManyElementsFlowable() 
+ void testSingleWithEmptyFlowable() 
+ void testSingleDoesNotRequestMoreThanItNeedsIf1Then2RequestedFlowable() 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testSingleDoesNotRequestMoreThanItNeedsIf3RequestedFlowable() 
+ void testSingleRequestsExactlyWhatItNeedsIf1RequestedFlowable() 
+ void testSingleWithPredicateFlowable() 
+ void testSingleWithPredicateAndTooManyElementsFlowable() 
+ void testSingleWithPredicateAndEmptyFlowable() 
+ void testSingleOrDefaultFlowable() 
+ void testSingleOrDefaultWithTooManyElementsFlowable() 
+ void testSingleOrDefaultWithEmptyFlowable() 
+ void testSingleOrDefaultWithPredicateFlowable() 
+ void testSingleOrDefaultWithPredicateAndTooManyElementsFlowable() 
+ void testSingleOrDefaultWithPredicateAndEmptyFlowable() 
+ void testSingleWithBackpressureFlowable() 
+ void onNext(Integer integer) 
+ void testSingle() 
+ void testSingleWithTooManyElements() 
+ void testSingleWithEmpty() 
+ void testSingleDoesNotRequestMoreThanItNeedsToEmitItem() 
+ void testSingleDoesNotRequestMoreThanItNeedsToEmitErrorFromEmpty() 
+ void testSingleDoesNotRequestMoreThanItNeedsToEmitErrorFromMoreThanOne() 
+ void testSingleWithPredicate() 
+ void testSingleWithPredicateAndTooManyElements() 
+ void testSingleWithPredicateAndEmpty() 
+ void testSingleOrDefault() 
+ void testSingleOrDefaultWithTooManyElements() 
+ void testSingleOrDefaultWithEmpty() 
+ void testSingleOrDefaultWithPredicate() 
+ void testSingleOrDefaultWithPredicateAndTooManyElements() 
+ void testSingleOrDefaultWithPredicateAndEmpty() 
+ void testIssue1527() 
+ void singleOrErrorNoElement() 
+ void singleOrErrorOneElement() 
+ void singleOrErrorMultipleElements() 
+ void singleOrErrorError() 
+ void testIssue1527Flowable() 
+ void singleElementOperatorDoNotSwallowExceptionWhenDone() 
+ void subscribe(final Subscriber<? super Integer> observer) 
+ void badSource() 
+ Object apply(Flowable<Object> o) 
+ void doubleOnSubscribe() 
+ MaybeSource<Object> apply(Flowable<Object> o) 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkip {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final long n;
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipLast {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final int skip;
~        final int skip;
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipLastTest {
 + void testSkipLastEmpty() 
+ void testSkipLast1() 
+ void testSkipLast2() 
+ void testSkipLastWithZeroCount() 
+ void testSkipLastWithNull() 
+ void testSkipLastWithBackpressure() 
+ void testSkipLastWithNegativeCount() 
+ void dispose() 
+ void error() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipLastTimed {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final long time;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final int bufferSize;
~    final boolean delayError;
~        final long time;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final SpscLinkedArrayQueue<Object> queue;
~        final boolean delayError;
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipLastTimedTest {
 + void testSkipLastTimed() 
+ void testSkipLastTimedErrorBeforeTime() 
+ void testSkipLastTimedCompleteBeforeTime() 
+ void testSkipLastTimedWhenAllElementsAreValid() 
+ void skipLastTimedDefaultScheduler() 
+ void skipLastTimedDefaultSchedulerDelayError() 
+ void skipLastTimedCustomSchedulerDelayError() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void onNextDisposeRace() 
+ void run() 
+ void errorDelayed() 
+ void take() 
+ void observeOn() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipTest {
 + void testSkipNegativeElements() 
+ void testSkipZeroElements() 
+ void testSkipOneElement() 
+ void testSkipTwoElements() 
+ void testSkipEmptyStream() 
+ void testSkipMultipleObservers() 
+ void testSkipError() 
+ void testBackpressureMultipleSmallAsyncRequests() 
+ void testRequestOverflowDoesNotOccur() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipTimedTest {
 + void testSkipTimed() 
+ void testSkipTimedFinishBeforeTime() 
+ void testSkipTimedErrorBeforeTime() 
+ void testSkipTimedErrorAfterTime() 
+ void skipTimedDefaultScheduler() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipUntil {
 # void subscribeActual(Subscriber<? super T> child) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ boolean tryOnNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(Object t) 
~    final Publisher<U> other;
~        final AtomicReference<Subscription> s;
~        final AtomicLong requested;
~        final OtherSubscriber other;
~        final AtomicThrowable error;
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipUntilTest {
 + void before() 
+ void normal1() 
+ void otherNeverFires() 
+ void otherEmpty() 
+ void otherFiresAndCompletes() 
+ void sourceThrows() 
+ void otherThrowsImmediately() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ Flowable<Object> apply(Flowable<Object> o) 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipWhile {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSkipWhileTest {
 + boolean test(Integer v) 
+ boolean test(Integer value) 
+ void testSkipWithIndex() 
+ void testSkipEmpty() 
+ void testSkipEverything() 
+ void testSkipNothing() 
+ void testSkipSome() 
+ void testSkipError() 
+ void testSkipManySubscribers() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSubscribeOn {
 + void subscribeActual(final Subscriber<? super T> s) 
+ void run() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(final long n) 
+ void cancel() 
~    final Scheduler scheduler;
~    final boolean nonScheduledRequests;
~        final AtomicReference<Subscription> s;
~        final AtomicLong requested;
~        final boolean nonScheduledRequests;
            - final Subscription s;
            - final long n;
 
}
class io.reactivex.internal.operators.flowable.FlowableSubscribeOn.SubscribeOnSubscriber
class io.reactivex.internal.operators.flowable.FlowableSubscribeOnTest {
 + void testIssue813() 
+ void testThrownErrorHandling() 
+ void testOnError() 
+ Worker createWorker() 
+ void dispose() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull final Runnable action) 
+ Disposable schedule(@NonNull final Runnable action, final long delayTime, @NonNull final TimeUnit delayUnit) 
+ void testUnsubscribeInfiniteStream() 
+ void testBackpressureReschedulesCorrectly() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testSetProducerSynchronousRequest() 
+ void cancel() 
+ void onComplete() 
+ void cancelBeforeActualSubscribe() 
+ void deferredRequestRace() 
+ void run() 
+ void nonScheduledRequests() 
+ void scheduledRequests() 
~        final Scheduler actual;
~        final long delay;
~        final TimeUnit unit;
 
}
class io.reactivex.internal.operators.flowable.FlowableSwitchIfEmpty {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final SubscriptionArbiter arbiter;
 
}
class io.reactivex.internal.operators.flowable.FlowableSwitchIfEmptyTest {
 + void testSwitchWhenNotEmpty() 
+ void testSwitchWhenEmpty() 
+ void testSwitchWithProducer() 
+ void cancel() 
+ void testSwitchTriggerUnsubscribe() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long aLong) 
+ void testSwitchShouldTriggerUnsubscribe() 
+ void testSwitchRequestAlternativeObservableWithBackpressure() 
+ void testBackpressureNoRequest() 
+ void testBackpressureOnFirstObservable() 
+ void testRequestsNotLost() 
 
}
class io.reactivex.internal.operators.flowable.FlowableSwitchMap {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(R t) 
~    final int bufferSize;
~    final boolean delayErrors;
~        final int bufferSize;
~        final boolean delayErrors;
~        final AtomicThrowable error;
~        final long index;
 
}
class io.reactivex.internal.operators.flowable.FlowableSwitchTest {
 + void before() 
+ void testSwitchWhenOuterCompleteBeforeInner() 
+ void testSwitchWhenInnerCompleteBeforeOuter() 
+ void subscribe(Subscriber<? super String> observer) 
+ void testSwitchWithComplete() 
+ void subscribe(final Subscriber<? super String> observer) 
+ void testSwitchWithError() 
+ void testSwitchWithSubsequenceComplete() 
+ void testSwitchWithSubsequenceError() 
+ void run() 
+ void testSwitchIssue737() 
+ void testBackpressure() 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String s) 
+ void testUnsubscribe() 
+ void testIssue2654() 
+ void onNext(String t) 
+ void testInitialRequestsAreAdditive() 
+ void testInitialRequestsDontOverflow() 
+ void testSecondaryRequestsDontOverflow() 
+ void testSecondaryRequestsAdditivelyAreMoreThanLongMaxValueInducesMaxValueRequestFromUpstream()
            
+ void delayErrors() 
+ void switchOnNextPrefetch() 
+ void switchOnNextDelayError() 
+ void switchOnNextDelayErrorPrefetch() 
+ void switchOnNextDelayErrorWithError() 
+ void switchOnNextDelayErrorBufferSize() 
+ void switchMapDelayErrorEmptySource() 
+ void switchMapDelayErrorJustSource() 
+ void switchMapErrorEmptySource() 
+ void switchMapJustSource() 
+ void switchMapInnerCancelled() 
+ void dispose() 
+ void nextSourceErrorRace() 
+ void outerInnerErrorRace() 
+ void nextCancelRace() 
+ void mapperThrows() 
+ void badMainSource() 
+ void emptyInner() 
+ void justInner() 
+ void badInnerSource() 
+ void innerCompletesReentrant() 
+ void innerErrorsReentrant() 
+ void scalarMap() 
+ void scalarMapDelayError() 
+ void scalarXMap() 
+ void badSource() 
+ void innerOverflow() 
+ void drainCancelRace() 
+ void fusedInnerCrash() 
    - TestScheduler scheduler;
    - Subscriber<String> observer;
            - int requested;
 
}
class io.reactivex.internal.operators.flowable.FlowableTake {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final long limit;
~        final long limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableTake.TakeSubscriber
class io.reactivex.internal.operators.flowable.FlowableTakeLast {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final int count;
~        final int count;
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeLastOne {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeLastOneTest {
 + void testLastOfManyReturnsLast() 
+ void testLastOfEmptyReturnsEmpty() 
+ void testLastOfOneReturnsLast() 
+ void testUnsubscribesFromUpstream() 
+ void testLastWithBackpressure() 
+ void testTakeLastZeroProcessesAllItemsButIgnoresThem() 
+ void requestMore(long n) 
+ void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(T t) 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
        - long initialRequest;
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeLastTest {
 + void testTakeLastEmpty() 
+ void testTakeLast1() 
+ void testTakeLast2() 
+ void testTakeLastWithZeroCount() 
+ void testTakeLastWithNull() 
+ void testTakeLastWithNegativeCount() 
+ void testBackpressure1() 
+ void testBackpressure2() 
+ Integer apply(Integer i) 
+ void testIssue1522() 
+ void testIgnoreRequest1() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer integer) 
+ void testIgnoreRequest2() 
+ void testIgnoreRequest3() 
+ void testIgnoreRequest4() 
+ void testUnsubscribeTakesEffectEarlyOnFastPath() 
+ void testRequestOverflow() 
+ void onNext(Integer t) 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
+ void takeLastTake() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeLastTimed {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final long count;
~    final long time;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final int bufferSize;
~    final boolean delayError;
~        final long count;
~        final long time;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final SpscLinkedArrayQueue<Object> queue;
~        final boolean delayError;
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeLastTimedTest {
 + void testTakeLastTimedWithNegativeCount() 
+ void takeLastTimed() 
+ void takeLastTimedDelayCompletion() 
+ void takeLastTimedWithCapacity() 
+ void takeLastTimedThrowingSource() 
+ void takeLastTimedWithZeroCapacity() 
+ void testContinuousDelivery() 
+ void takeLastTimeAndSize() 
+ void takeLastTime() 
+ void takeLastTimeDelayError() 
+ void takeLastTimeDelayErrorCustomScheduler() 
+ void disposed() 
+ void observeOn() 
+ void cancelCompleteRace() 
+ void run() 
+ void emptyDelayError() 
+ void doubleOnSubscribe() 
+ void badRequest() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakePublisher {
 # void subscribeActual(Subscriber<? super T> s) 
~    final Publisher<T> source;
~    final long limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeTest {
 + void testTake1() 
+ void testTake2() 
+ void testTakeWithError() 
+ void testTakeWithErrorHappeningInOnNext() 
+ void testTakeWithErrorHappeningInTheLastOnNext() 
+ void testTakeDoesntLeakErrors() 
+ void testTakeZeroDoesntLeakError() 
+ void testUnsubscribeAfterTake() 
+ void testUnsubscribeFromSynchronousInfiniteFlowable() 
+ void testMultiTake() 
+ void accept(Integer t1) 
+ void subscribe(final Subscriber<? super String> observer) 
+ void subscribe(Subscriber<? super Long> op) 
+ void testTakeObserveOn() 
+ void testProducerRequestThroughTake() 
+ void cancel() 
+ void testProducerRequestThroughTakeIsModified() 
+ void testInterrupt() 
+ void testDoesntRequestMoreThanNeededFromUpstream() 
+ void takeFinalValueThrows() 
+ void testReentrantTake() 
+ void takeNegative() 
+ void takeZero() 
+ void dispose() 
+ void doubleOnSubscribe() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeTimedTest {
 + void testTakeTimed() 
+ void testTakeTimedErrorBeforeTime() 
+ void testTakeTimedErrorAfterTime() 
+ void timedDefaultScheduler() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeUntil {
 # void subscribeActual(Subscriber<? super T> child) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(Object t) 
~        final AtomicLong requested;
~        final AtomicReference<Subscription> s;
~        final AtomicThrowable error;
~        final OtherSubscriber other;
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicate {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicateTest {
 + void takeEmpty() 
+ void takeAll() 
+ void takeFirst() 
+ void takeSome() 
+ void functionThrows() 
+ void sourceThrows() 
+ void backpressure() 
+ void testErrorIncludesLastValueAsCause() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeUntilTest {
 + void testTakeUntil() 
+ void testTakeUntilSourceCompleted() 
+ void testTakeUntilSourceError() 
+ void testTakeUntilOtherError() 
+ void testTakeUntilOtherCompleted() 
+ void sendOnCompleted() 
+ void sendOnNext(String value) 
+ void sendOnError(Throwable e) 
+ void subscribe(Subscriber<? super String> observer) 
+ void testUntilFires() 
+ void testMainCompletes() 
+ void testDownstreamUnsubscribes() 
+ void testBackpressure() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeWhile {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTakeWhileTest {
 + void testTakeWhile1() 
+ void testTakeWhileOnSubject1() 
+ void testTakeWhile2() 
+ void testTakeWhileDoesntLeakErrors() 
+ boolean test(String s) 
+ void testTakeWhileProtectsPredicateCall() 
+ void testUnsubscribeAfterTake() 
+ void subscribe(final Subscriber<? super String> observer) 
+ void testBackpressure() 
+ void testNoUnsubscribeDownstream() 
+ void testErrorCauseIncludesLastValue() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
~        final Subscription s;
~        final String[] values;
 
}
class io.reactivex.internal.operators.flowable.FlowableThrottleFirstTest {
 + void before() 
+ void testThrottlingWithCompleted() 
+ void testThrottlingWithError() 
+ void run() 
+ void testThrottle() 
+ void throttleFirstDefaultScheduler() 
+ void dispose() 
+ void badSource() 
+ void backpressureNoRequest() 
    - TestScheduler scheduler;
    - Subscriber<String> observer;
 
}
class io.reactivex.internal.operators.flowable.FlowableThrottleFirstTimed {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void run() 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long timeout;
~        final TimeUnit unit;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimeInterval {
 # void subscribeActual(Subscriber<? super Timed<T>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final Scheduler scheduler;
~    final TimeUnit unit;
~        final TimeUnit unit;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimeIntervalTest {
 + void setUp() 
+ void testTimeInterval() 
+ void timeIntervalDefault() 
+ Long apply(Timed<Integer> v) 
+ void timeIntervalDefaultSchedulerCustomUnit() 
+ void dispose() 
+ void error() 
    - Subscriber<Timed<Integer>> observer;
    - TestScheduler testScheduler;
    - PublishProcessor<Integer> subject;
    - Flowable<Timed<Integer>> observable;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimeout {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void timeout(long idx) 
+ void onNext(Object t) 
+ void dispose() 
+ boolean isDisposed() 
~    final Publisher<U> firstTimeoutIndicator;
~        final Publisher<U> firstTimeoutIndicator;
~        final OnTimeout parent;
~        final long index;
~        final FullArbiter<T> arbiter;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimeoutTests {
 + void setUp() 
+ void shouldNotTimeoutIfOnNextWithinTimeout() 
+ void shouldNotTimeoutIfSecondOnNextWithinTimeout() 
+ void shouldTimeoutIfOnNextNotWithinTimeout() 
+ void shouldTimeoutIfSecondOnNextNotWithinTimeout() 
+ void shouldCompleteIfUnderlyingComletes() 
+ void shouldErrorIfUnderlyingErrors() 
+ void shouldSwitchToOtherIfOnNextNotWithinTimeout() 
+ void shouldSwitchToOtherIfOnErrorNotWithinTimeout() 
+ void shouldSwitchToOtherIfOnCompletedNotWithinTimeout() 
+ void shouldSwitchToOtherAndCanBeUnsubscribedIfOnNextNotWithinTimeout() 
+ void shouldTimeoutIfSynchronizedFlowableEmitFirstOnNextNotWithinTimeout()
            
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnTimeout() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyComplete() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyErrored() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnDispose() 
+ void timedAndOther() 
+ void disposed() 
+ void timedErrorOther() 
+ void timedError() 
+ void timedEmptyOther() 
+ void timedEmpty() 
+ void newTimer() 
+ void badSource() 
+ void badSourceOther() 
+ void timedTake() 
+ void timedFallbackTake() 
    - PublishProcessor<String> underlyingSubject;
    - TestScheduler testScheduler;
    - Flowable<String> withTimeout;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimeoutTimed {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ void request(long n) 
+ void cancel() 
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long timeout;
~        final TimeUnit unit;
~        final FullArbiter<T> arbiter;
            - final long idx;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimeoutWithSelectorTest {
 + void testTimeoutSelectorNormal1() 
+ void testTimeoutSelectorTimeoutFirst() 
+ void testTimeoutSelectorFirstThrows() 
+ Flowable<Integer> call() 
+ void testTimeoutSelectorSubsequentThrows() 
+ void testTimeoutSelectorFirstFlowableThrows() 
+ void testTimeoutSelectorSubsequentFlowableThrows() 
+ void testTimeoutSelectorWithFirstTimeoutFirstAndNoOtherFlowable() 
+ void testTimeoutSelectorWithTimeoutFirstAndNoOtherFlowable() 
+ void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() 
+ Void answer(InvocationOnMock invocation) 
+ void run() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ Flowable<Object> apply(Flowable<Object> o) 
+ void empty() 
+ void error() 
+ void emptyInner() 
+ void badInnerSource() 
+ void badInnerSourceOther() 
+ void withOtherMainError() 
+ void badSourceTimeout() 
+ void selectorTake() 
+ void selectorFallbackTake() 
 
}
class io.reactivex.internal.operators.flowable.FlowableTimer {
 + void subscribeActual(Subscriber<? super Long> s) 
+ void request(long n) 
+ void cancel() 
+ void run() 
+ void setResource(Disposable d) 
~    final Scheduler scheduler;
~    final long delay;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.flowable.FlowableTimerTest {
 + void before() 
+ void testTimerOnce() 
+ void testTimerPeriodically() 
+ void testInterval() 
+ void testWithMultipleSubscribersStartingAtSameTime() 
+ void testWithMultipleStaggeredSubscribers() 
+ void testWithMultipleStaggeredSubscribersAndPublish() 
+ void testOnceObserverThrows() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testPeriodicObserverThrows() 
+ void disposed() 
+ void backpressureNotReady() 
+ void timerCancelRace() 
+ void run() 
+ void timerDelayZero() 
+ void timerInterruptible() 
+ Long apply(Long v) 
 
}
class io.reactivex.internal.operators.flowable.FlowableTimestampTest {
 + void before() 
+ void timestampWithScheduler() 
+ void timestampWithScheduler2() 
+ void timeIntervalDefault() 
+ Long apply(Timed<Integer> v) 
+ void timeIntervalDefaultSchedulerCustomUnit() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToCompletableTest {
 + void testJustSingleItemObservable() 
+ void testErrorObservable() 
+ void testJustTwoEmissionsObservableThrowsError() 
+ void testEmptyObservable() 
+ void testNeverObservable() 
+ void testShouldUseUnsafeSubscribeInternallyNotSubscribe() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToFutureTest {
 + void testSuccess() 
+ void testSuccessOperatesOnSuppliedScheduler() 
+ void testFailure() 
+ void testCancelledBeforeSubscribe() 
+ void testCancellationDuringFutureGet() 
+ boolean isCancelled() 
+ boolean isDone() 
+ Object get() 
+ Object get(long timeout, TimeUnit unit) 
+ void backpressure() 
+ void withTimeoutNoTimeout() 
+ void withTimeoutTimeout() 
+ void withTimeoutNoTimeoutScheduler() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToList {
 # void subscribeActual(Subscriber<? super U> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
~    final Callable<U> collectionSupplier;
 
}
class io.reactivex.internal.operators.flowable.FlowableToListSingle {
 # void subscribeActual(SingleObserver<? super U> s) 
+ Flowable<U> fuseToFlowable() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Flowable<T> source;
~    final Callable<U> collectionSupplier;
 
}
class io.reactivex.internal.operators.flowable.FlowableToListTest {
 + void testListFlowable() 
+ void testListViaFlowableFlowable() 
+ void testListMultipleSubscribersFlowable() 
+ void testListWithNullValueFlowable() 
+ void testListWithBlockingFirstFlowable() 
+ void testBackpressureHonoredFlowable() 
+ void testAsyncRequestedFlowable() 
+ void run() 
+ void capacityHintFlowable() 
+ void testList() 
+ void testListViaFlowable() 
+ void testListMultipleSubscribers() 
+ void testListWithNullValue() 
+ void testListWithBlockingFirst() 
+ void testBackpressureHonored() 
+ void testAsyncRequested() 
~{static} void await(CyclicBarrier cb) 
+ void capacityHint() 
+ void dispose() 
+ void error() 
+ void errorSingle() 
+ void collectionSupplierThrows() 
+ void collectionSupplierReturnsNull() 
+ void singleCollectionSupplierThrows() 
+ void singleCollectionSupplierReturnsNull() 
+ void onNextCancelRace() 
+ void onNextCancelRaceFlowable() 
+ void onCompleteCancelRaceFlowable() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToMapTest {
 + void before() 
+ Integer apply(String t1) 
+ String apply(String t1) 
+ void testToMapFlowable() 
+ void testToMapWithValueSelectorFlowable() 
+ void testToMapWithErrorFlowable() 
+ void testToMapWithErrorInValueSelectorFlowable() 
+ void testToMapWithFactoryFlowable() 
+ String apply(String v) 
+ void testToMapWithErrorThrowingFactoryFlowable() 
+ void testToMap() 
+ void testToMapWithValueSelector() 
+ void testToMapWithError() 
+ void testToMapWithErrorInValueSelector() 
+ void testToMapWithFactory() 
+ void testToMapWithErrorThrowingFactory() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToMultimapTest {
 + void before() 
+ Integer apply(String t1) 
+ String apply(String t1) 
+ void testToMultimapFlowable() 
+ void testToMultimapWithValueSelectorFlowable() 
+ void testToMultimapWithMapFactoryFlowable() 
+ String apply(String v) 
+ Collection<String> apply(Integer e) 
+ void testToMultimapWithCollectionFactoryFlowable() 
+ void testToMultimapWithErrorFlowable() 
+ void testToMultimapWithErrorInValueSelectorFlowable() 
+ void testToMultimapWithMapThrowingFactoryFlowable() 
+ void testToMultimapWithThrowingCollectionFactoryFlowable() 
+ void testToMultimap() 
+ void testToMultimapWithValueSelector() 
+ void testToMultimapWithMapFactory() 
+ void testToMultimapWithCollectionFactory() 
+ void testToMultimapWithError() 
+ void testToMultimapWithErrorInValueSelector() 
+ void testToMultimapWithMapThrowingFactory() 
+ void testToMultimapWithThrowingCollectionFactory() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToSingleTest {
 + void testJustSingleItemObservable() 
+ void testErrorObservable() 
+ void testJustTwoEmissionsObservableThrowsError() 
+ void testEmptyObservable() 
+ void testRepeatObservableThrowsError() 
+ void testShouldUseUnsafeSubscribeInternallyNotSubscribe() 
 
}
class io.reactivex.internal.operators.flowable.FlowableToSortedListTest {
 + void testSortedListFlowable() 
+ void testSortedListWithCustomFunctionFlowable() 
+ void testWithFollowingFirstFlowable() 
+ void testBackpressureHonoredFlowable() 
+ void testAsyncRequestedFlowable() 
+ void run() 
+ void sorted() 
+ void sortedComparator() 
+ void toSortedListCapacityFlowable() 
+ void toSortedListComparatorCapacityFlowable() 
+ void testSortedList() 
+ void testSortedListWithCustomFunction() 
+ void testWithFollowingFirst() 
+ void testBackpressureHonored() 
+ void testAsyncRequested() 
~{static} void await(CyclicBarrier cb) 
+ void toSortedListCapacity() 
+ void toSortedListComparatorCapacity() 
 
}
class io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void run() 
~    final Scheduler scheduler;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableUnsubscribeOnTest {
 + void unsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnSameThread() 
+ void unsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnDifferentThreads() 
+ void cancel() 
+ Thread getThread() 
+ void request(long n) 
+ void run() 
+ Worker createWorker() 
+ void takeHalf() 
+ void dispose() 
+ void normal() 
+ void error() 
+ void signalAfterDispose() 
        - final Scheduler eventLoop;
 
}
class io.reactivex.internal.operators.flowable.FlowableUsing {
 + void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final boolean eager;
~        final D resource;
~        final boolean eager;
 
}
class io.reactivex.internal.operators.flowable.FlowableUsingTest {
 + void accept(Resource r) 
+ void accept(Disposable s) 
+ void testUsing() 
+ void testUsingEagerly() 
- void performTestUsing(boolean disposeEagerly) 
+ Flowable<String> apply(Resource res) 
+ void testUsingWithSubscribingTwice() 
+ void testUsingWithSubscribingTwiceDisposeEagerly() 
- void performTestUsingWithSubscribingTwice(boolean disposeEagerly) 
+ void dispose() 
+ void testUsingWithResourceFactoryError() 
+ void testUsingWithResourceFactoryErrorDisposeEagerly() 
- void performTestUsingWithResourceFactoryError(boolean disposeEagerly) 
+ Flowable<Integer> apply(Disposable s) 
+ void testUsingWithFlowableFactoryError() 
+ void testUsingWithFlowableFactoryErrorDisposeEagerly() 
- void performTestUsingWithFlowableFactoryError(boolean disposeEagerly) 
+ Flowable<Integer> apply(Disposable subscription) 
+ void testUsingWithFlowableFactoryErrorInOnSubscribe() 
+ void testUsingWithFlowableFactoryErrorInOnSubscribeDisposeEagerly() 
- void performTestUsingWithFlowableFactoryErrorInOnSubscribe(boolean disposeEagerly) 
+ void testUsingDisposesEagerlyBeforeCompletion() 
+ void testUsingDoesNotDisposesEagerlyBeforeCompletion() 
+ void testUsingDisposesEagerlyBeforeError() 
+ void testUsingDoesNotDisposesEagerlyBeforeError() 
- {static} Action createUnsubAction(final List<String> events) 
- {static} Consumer<Throwable> createOnErrorAction(final List<String> events) 
- {static} Callable<Resource> createResourceFactory(final List<String> events) 
- {static} Action createOnCompletedAction(final List<String> events) 
+ void factoryThrows() 
+ Flowable<Integer> apply(Integer v) 
+ void accept(Integer c) 
+ void nonEagerTermination() 
+ Flowable<Object> apply(Object v) 
+ void supplierDisposerCrash() 
+ void accept(Object e) 
+ void eagerOnErrorDisposerCrash() 
+ void eagerOnCompleteDisposerCrash() 
+ void nonEagerDisposerCrash() 
 
}
class io.reactivex.internal.operators.flowable.FlowableWindow {
 + void subscribeActual(Subscriber<? super Flowable<T>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void run() 
~    final long size;
~    final long skip;
~    final int bufferSize;
~        final long size;
~        final AtomicBoolean once;
~        final int bufferSize;
~        final long skip;
~        final AtomicBoolean firstRequest;
~        final SpscLinkedArrayQueue<UnicastProcessor<T>> queue;
~        final ArrayDeque<UnicastProcessor<T>> windows;
~        final AtomicLong requested;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowBoundary {
 # void subscribeActual(Subscriber<? super Flowable<T>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ boolean accept(Subscriber<? super Flowable<T>> a, Object v) 
+ void onNext(B t) 
~    final Publisher<B> other;
~    final int bufferSize;
~        final Publisher<B> other;
~        final int bufferSize;
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector {
 # void subscribeActual(Subscriber<? super Flowable<T>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ boolean accept(Subscriber<? super Flowable<T>> a, Object v) 
+ void onNext(B t) 
+ void onNext(V t) 
~    final Publisher<B> open;
~    final int bufferSize;
~        final Publisher<B> open;
~        final int bufferSize;
~        final CompositeDisposable resources;
~        final List<UnicastProcessor<T>> ws;
~        final UnicastProcessor<T> w;
~        final B open;
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier {
 # void subscribeActual(Subscriber<? super Flowable<T>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(B t) 
~    final int bufferSize;
~        final int bufferSize;
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowTimed {
 # void subscribeActual(Subscriber<? super Flowable<T>> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void dispose() 
+ void run() 
~    final long timespan;
~    final long timeskip;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final long maxSize;
~    final int bufferSize;
~    final boolean restartTimerOnMaxSize;
~        final long timespan;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final int bufferSize;
~        final boolean restartTimerOnMaxSize;
~        final long maxSize;
~            final long index;
~        final long timeskip;
~        final List<UnicastProcessor<T>> windows;
~            final UnicastProcessor<T> w;
~            final boolean open;
            - final UnicastProcessor<T> processor;
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowWithFlowableTest {
 + void testWindowViaFlowableNormal1() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testWindowViaFlowableBoundaryCompletes() 
+ void testWindowViaFlowableBoundaryThrows() 
+ void testWindowViaFlowableSourceThrows() 
+ void testWindowNoDuplication() 
+ void onNext(Flowable<Integer> t) 
+ Flowable<Object> call() 
+ void testWindowViaFlowableNoUnsubscribe() 
+ void testBoundaryUnsubscribedOnMainCompletion() 
+ void testMainUnsubscribedOnBoundaryCompletion() 
+ void testChildUnsubscribed() 
+ void testInnerBackpressure() 
+ void newBoundaryCalledAfterWindowClosed() 
+ void boundaryDispose() 
+ void boundaryDispose2() 
+ void boundaryOnError() 
+ void mainError() 
+ void innerBadSource() 
+ Object apply(Flowable<Integer> o) 
+ void reentrant() 
+ Flowable<Integer> apply(Flowable<Integer> v) 
+ void reentrantCallable() 
+ Flowable<Integer> call() 
+ void badSource() 
+ void badSourceCallable() 
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowWithSizeTest {
 + Flowable<List<T>> apply(Flowable<T> xs) 
+ void accept(List<T> xs) 
+ void testNonOverlappingWindows() 
+ void testSkipAndCountGaplessWindows() 
+ void testOverlappingWindows() 
+ void testSkipAndCountWindowsWithGaps() 
+ void testWindowUnsubscribeNonOverlapping() 
+ void testWindowUnsubscribeNonOverlappingAsyncSource() 
+ void testWindowUnsubscribeOverlapping() 
+ void testWindowUnsubscribeOverlappingAsyncSource() 
- List<String> list(String... args) 
+ void testBackpressureOuter() 
+ void onNext(Flowable<Integer> t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ {static} Flowable<Integer> hotStream() 
+ void testTakeFlatMapCompletes() 
+ void testBackpressureOuterInexact() 
+ Publisher<List<Integer>> apply(Flowable<List<Integer>> v) 
+ void dispose() 
+ void doubleOnSubscribe() 
+ Flowable<Flowable<Object>> apply(Flowable<Object> o) 
+ void errorExact() 
+ void errorSkip() 
+ void errorOverlap() 
+ void errorExactInner() 
+ void accept(Flowable<Integer> w) 
+ void errorSkipInner() 
+ void errorOverlapInner() 
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowWithStartEndFlowableTest {
 + void before() 
+ void testFlowableBasedOpenerAndCloser() 
+ void subscribe(Subscriber<? super Object> observer) 
+ Flowable<Object> apply(Object opening) 
+ void testFlowableBasedCloser() 
+ Flowable<Object> call() 
- List<String> list(String... args) 
+ void run() 
- void complete(final Subscriber<?> observer, int delay) 
- Consumer<Flowable<String>> observeWindow(final List<String> list, final List<List<String>> lists) 
+ void onError(Throwable e) 
+ void onNext(String args) 
+ void testNoUnsubscribeAndNoLeak() 
+ void testUnsubscribeAll() 
+ void dispose() 
+ void reentrant() 
+ Flowable<Integer> apply(Flowable<Integer> v) 
+ void badSourceCallable() 
+ void boundarySelectorNormal() 
+ void startError() 
+ void endError() 
+ void mainError() 
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableWindowWithTimeTest {
 + void before() 
+ void testTimedAndCount() 
+ void testTimed() 
- List<String> list(String... args) 
+ void run() 
- void complete(final Subscriber<?> observer, int delay) 
+ void accept(Flowable<T> stringFlowable) 
+ void onError(Throwable e) 
+ void onNext(T args) 
+ void testExactWindowSize() 
+ void testTakeFlatMapCompletes() 
+ Flowable<Integer> apply(Flowable<Integer> w) 
+ void accept(Integer pv) 
+ void timespanTimeskipCustomSchedulerBufferSize() 
+ void timespanDefaultSchedulerSize() 
+ void timespanDefaultSchedulerSizeRestart() 
+ void invalidSpan() 
+ void timespanTimeskipDefaultScheduler() 
+ void timespanTimeskipCustomScheduler() 
+ void timeskipJustOverlap() 
+ void timeskipJustSkip() 
+ void timeskipSkipping() 
+ void timeskipOverlapping() 
+ void exactOnError() 
+ void overlappingOnError() 
+ void skipOnError() 
+ void exactBackpressure() 
+ void skipBackpressure() 
+ void overlapBackpressure() 
+ void exactBackpressure2() 
+ void skipBackpressure2() 
+ void overlapBackpressure2() 
+ void dispose() 
+ void restartTimer() 
+ void exactBoundaryError() 
+ void restartTimerMany() 
+ void exactUnboundedReentrant() 
+ Flowable<Integer> apply(Flowable<Integer> v) 
+ void exactBoundedReentrant() 
+ void exactBoundedReentrant2() 
+ void skipReentrant() 
+ void sizeTimeTimeout() 
+ void periodicWindowCompletion() 
+ void periodicWindowCompletionRestartTimer() 
+ void periodicWindowCompletionBounded() 
+ void periodicWindowCompletionRestartTimerBounded() 
+ void periodicWindowCompletionRestartTimerBoundedSomeData() 
+ void countRestartsOnTimeTick() 
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.flowable.FlowableWithLatestFrom {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ boolean setOther(Subscription o) 
+ void otherError(Throwable e) 
+ void onNext(U t) 
 
}
class io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ void onNext(Object t) 
+ boolean isDisposed() 
+ void dispose() 
+ R apply(T t) 
~        final WithLatestInnerSubscriber[] subscribers;
~        final AtomicReferenceArray<Object> values;
~        final AtomicReference<Subscription> s;
~        final AtomicLong requested;
~        final AtomicThrowable error;
~        final int index;
 
}
class io.reactivex.internal.operators.flowable.FlowableWithLatestFromTest {
 + Integer apply(Integer t1, Integer t2) 
+ void testSimple() 
+ void testEmptySource() 
+ void testEmptyOther() 
+ void testUnsubscription() 
+ void testSourceThrows() 
+ void testOtherThrows() 
+ void testFunctionThrows() 
+ void testNoDownstreamUnsubscribe() 
+ void testBackpressure() 
+ String apply(Object[] args) 
+ void manySources() 
+ void manySourcesIterable() 
+ void manySourcesIterableSweep() 
+ void backpressureNoSignal() 
+ void backpressureWithSignal() 
+ void withEmpty() 
+ void withError() 
+ void withMainError() 
+ void with2Others() 
+ void with3Others() 
+ void with4Others() 
+ void dispose() 
+ Object apply(Integer a, Integer b, Integer c) 
+ void manyIteratorThrows() 
+ Object apply(Object[] a) 
+ void manyCombinerThrows() 
+ void manyErrors() 
+ void otherErrors() 
+ Integer apply(Integer a, Integer b) 
+ void combineToNull1() 
+ void combineToNull2() 
 
}
class io.reactivex.internal.operators.flowable.FlowableZip {
 + void subscribeActual(Subscriber<? super R> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int bufferSize;
~    final boolean delayError;
~        final AtomicLong requested;
~        final AtomicThrowable errors;
~        final boolean delayErrors;
~        final Object[] current;
~        final int prefetch;
~        final int limit;
 
}
class io.reactivex.internal.operators.flowable.FlowableZipCompletionTest {
 + void setUp() 
+ void testFirstCompletesThenSecondInfinite() 
+ void testSecondInfiniteThenFirstCompletes() 
+ void testSecondCompletesThenFirstInfinite() 
+ void testFirstInfiniteThenSecondCompletes() 
 
}
class io.reactivex.internal.operators.flowable.FlowableZipIterable {
 + void subscribeActual(Subscriber<? super V> t) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final Iterable<U> other;
~        final Iterator<U> iterator;
 
}
class io.reactivex.internal.operators.flowable.FlowableZipIterableTest {
 + void setUp() 
+ String apply(Object t1, Object t2) 
+ String apply(Object t1, Object t2, Object t3) 
+ void testZipIterableSameSize() 
+ void testZipIterableEmptyFirstSize() 
+ void testZipIterableEmptySecond() 
+ void testZipIterableFirstShorter() 
+ void testZipIterableSecondShorter() 
+ void testZipIterableFirstThrows() 
+ void testZipIterableIteratorThrows() 
+ void testZipIterableHasNextThrows() 
+ String next() 
+ void remove() 
+ void testZipIterableNextThrows() 
+ void accept(String pv) 
+ String apply(Integer t1) 
+ void testTake2() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void iteratorThrows() 
+ void badSource() 
+ Object apply(Integer a, Integer b) 
 
}
class io.reactivex.internal.operators.flowable.FlowableZipTest {
 + void setUp() 
+ void testCollectionSizeDifferentThanFunction() 
+ void testStartpingDifferentLengthFlowableSequences1() 
+ void testStartpingDifferentLengthFlowableSequences2() 
+ String apply(Object t1, Object t2) 
+ String apply(Object t1, Object t2, Object t3) 
+ void testAggregatorSimple() 
+ void testAggregatorDifferentSizedResultsWithOnComplete() 
+ void testAggregateMultipleTypes() 
+ void testAggregate3Types() 
+ void testAggregatorsWithDifferentSizesAndTiming() 
+ void testAggregatorError() 
+ void testAggregatorUnsubscribe() 
+ void testAggregatorEarlyCompletion() 
+ void testStart2Types() 
+ void testStart3Types() 
+ void testOnNextExceptionInvokesOnError() 
+ void testOnFirstCompletion() 
+ void testOnErrorTermination() 
+ String apply(String t1, String t2) 
+ Integer apply(Integer i1, Integer i2) 
+ String apply(String a1, String a2, String a3) 
+ String apply(String s, Integer i) 
+ String apply(String s, Integer i, int[] iArray) 
- {static} String getStringValue(Object o) 
+ void subscribe(Subscriber<? super String> observer) 
+ void testFirstCompletesThenSecondInfinite() 
+ void testSecondInfiniteThenFirstCompletes() 
+ void testSecondCompletesThenFirstInfinite() 
+ void testFirstInfiniteThenSecondCompletes() 
+ void testFirstFails() 
+ void testSecondFails() 
+ void testStartWithOnCompletedTwice() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer args) 
+ void testStart() 
+ void accept(String s) 
+ void testStartAsync() 
+ void testStartInfiniteAndFinite() 
+ void onNext(String s) 
+ void testEmitNull() 
~{static} String kind(Notification notification) 
~{static} String value(Notification notification) 
+ void testEmitMaterializedNotifications() 
+ void testStartEmptyFlowables() 
+ void testStartEmptyList() 
+ void testStartEmptyListBlocking() 
+ void testBackpressureSync() 
+ void testBackpressureAsync() 
+ void testDownstreamBackpressureRequestsWithFiniteSyncFlowables() 
+ void testDownstreamBackpressureRequestsWithInfiniteAsyncFlowables() 
+ void testDownstreamBackpressureRequestsWithInfiniteSyncFlowables() 
- Flowable<Integer> createInfiniteFlowable(final AtomicInteger generated) 
+ Integer next() 
+ boolean hasNext() 
+ void subscribe(final Subscriber<? super Integer> o) 
+ void testIssue1812() 
+ void testUnboundedDownstreamOverrequesting() 
+ void onNext(Integer t) 
+ void testZipRace() 
+ void testZipRequest1() 
+ void zipNArguments() 
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7, Object t8,
                Object t9) 
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7, Object t8)
                
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7)
                
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6) 
+ Object apply(Object t1, Object t2, Object t3, Object t4, Object t5) 
+ Object apply(Object t1, Object t2, Object t3, Object t4) 
+ Object apply(Object t1, Object t2, Object t3) 
+ Object apply(Object t1, Object t2) 
+ Object apply(Object t1) 
+ void zip2DelayError() 
+ void zip2DelayErrorPrefetch() 
+ void zip2Prefetch() 
+ void zipArrayEmpty() 
+ void zip2() 
+ void zip3() 
+ void zip4() 
+ void zip5() 
+ void zip6() 
+ void zip7() 
+ void zip8() 
+ void zip9() 
+ void zipArrayMany() 
+ void dispose() 
+ void badRequest() 
+ void multiError() 
# void subscribeActual(Subscriber<? super Object> s) 
+ Object apply(Object a, Object b) 
+ void singleErrorDelayed() 
+ void singleErrorDelayedBackpressured() 
+ void fusedInputThrows() 
+ Integer apply(Integer a, Integer b) 
+ void fusedInputThrowsDelayError() 
+ void fusedInputThrowsBackpressured() 
+ void fusedInputThrowsDelayErrorBackpressured() 
+ void noCrossBoundaryFusion() 
+ Object apply(Integer v) 
+ List<Object> apply(Object t1, Object t2) 
+ int requestFusion(int mode) 
+ boolean offer(Integer value) 
+ boolean offer(Integer v1, Integer v2) 
+ Integer poll() 
+ boolean isEmpty() 
+ void clear() 
+ void request(long n) 
+ void cancel() 
+ void subscribe(Subscriber<? super Integer> s) 
+ void fusedInputThrows2() 
+ void fusedInputThrows2Backpressured() 
+ void cancelOnBackpressureBoundary() 
 
}
class io.reactivex.internal.operators.flowable.FlowableZipTest.ArgsToString
class io.reactivex.internal.operators.flowable.Maybe
class io.reactivex.internal.operators.flowable.NotificationLiteTest {
 + void testComplete() 
+ void testValueKind() 
+ void soloEnum() 
+ void errorNotification() 
+ void completeNotification() 
+ void disposableNotification() 
+ void subscriptionNotification() 
 
}
class io.reactivex.internal.operators.flowable.Single
class io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstreamTest {
 + void upstream() 
 
}
class io.reactivex.internal.operators.maybe.Completable
class io.reactivex.internal.operators.maybe.Flowable
class io.reactivex.internal.operators.maybe.Maybe
class io.reactivex.internal.operators.maybe.MaybeAmb {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.maybe.MaybeAmbTest {
 + void ambLots() 
+ void ambFirstDone() 
+ void dispose() 
+ void innerErrorRace() 
+ void run() 
 
}
class io.reactivex.internal.operators.maybe.MaybeCache {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<MaybeSource<T>> source;
~    final AtomicReference<CacheDisposable<T>[]> observers;
 
}
class io.reactivex.internal.operators.maybe.MaybeCacheTest {
 + void offlineSuccess() 
+ void offlineError() 
+ void offlineComplete() 
+ void onlineSuccess() 
+ void onlineError() 
+ void onlineComplete() 
+ void crossCancelOnSuccess() 
+ void crossCancelOnError() 
+ void crossCancelOnComplete() 
+ void addAddRace() 
+ void removeRemoveRace() 
+ void run() 
+ void doubleDispose() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeCallbackObserver {
 + void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final Action onComplete;
 
}
class io.reactivex.internal.operators.maybe.MaybeCallbackObserverTest {
 + void dispose() 
+ void onSuccessCrashes() 
+ void onErrorCrashes() 
+ void onCompleteCrashes() 
 
}
class io.reactivex.internal.operators.maybe.MaybeConcatArray {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final AtomicLong requested;
~        final AtomicReference<Object> current;
~        final SequentialDisposable disposables;
 
}
class io.reactivex.internal.operators.maybe.MaybeConcatArrayDelayError {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final AtomicLong requested;
~        final AtomicReference<Object> current;
~        final SequentialDisposable disposables;
~        final AtomicThrowable errors;
 
}
class io.reactivex.internal.operators.maybe.MaybeConcatArrayTest {
 + void cancel() 
+ void cancelDelayError() 
+ void backpressure() 
+ void backpressureDelayError() 
+ void requestCancelRace() 
+ void run() 
+ void requestCancelRaceDelayError() 
+ void errorAfterTermination() 
# void subscribeActual(MaybeObserver<? super Integer> observer) 
+ void noSubsequentSubscription() 
+ void subscribe(MaybeEmitter<Integer> s) 
+ void noSubsequentSubscriptionDelayError() 
 
}
class io.reactivex.internal.operators.maybe.MaybeConcatIterable {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final AtomicLong requested;
~        final AtomicReference<Object> current;
~        final SequentialDisposable disposables;
 
}
class io.reactivex.internal.operators.maybe.MaybeConcatIterableTest {
 + void take() 
+ void iteratorThrows() 
+ void error() 
+ void successCancelRace() 
+ void run() 
+ void hasNextThrows() 
+ void nextThrows() 
+ void nextReturnsNull() 
+ void noSubsequentSubscription() 
+ void subscribe(MaybeEmitter<Integer> s) 
+ void noSubsequentSubscriptionDelayError() 
 
}
class io.reactivex.internal.operators.maybe.MaybeConcatPublisherTest {
 + void scalar() 
+ void callable() 
 
}
class io.reactivex.internal.operators.maybe.MaybeContains {
 + MaybeSource<T> source() 
# void subscribeActual(SingleObserver<? super Boolean> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final MaybeSource<T> source;
~    final Object value;
~        final Object value;
 
}
class io.reactivex.internal.operators.maybe.MaybeContainsTest {
 + void doesContain() 
+ void doesntContain() 
+ void empty() 
+ void error() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
+ void hasSource() 
 
}
class io.reactivex.internal.operators.maybe.MaybeCount {
 + MaybeSource<T> source() 
# void subscribeActual(SingleObserver<? super Long> observer) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
~    final MaybeSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeCountTest {
 + void one() 
+ void empty() 
+ void error() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
+ void hasSource() 
 
}
class io.reactivex.internal.operators.maybe.MaybeCreate {
 # void subscribeActual(MaybeObserver<? super T> s) 
+ void onSuccess(T value) 
+ void onError(Throwable t) 
+ boolean tryOnError(Throwable t) 
+ void onComplete() 
+ void setDisposable(Disposable d) 
+ void setCancellable(Cancellable c) 
+ void dispose() 
+ boolean isDisposed() 
~    final MaybeOnSubscribe<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeCreateTest {
 + void callbackThrows() 
+ void onSuccessNull() 
+ void onErrorNull() 
+ void dispose() 
+ void onSuccessThrows() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onErrorThrows() 
+ void onCompleteThrows() 
+ void onSuccessThrows2() 
+ void onErrorThrows2() 
+ void onCompleteThrows2() 
+ void tryOnError() 
+ void subscribe(MaybeEmitter<Object> e) 
 
}
class io.reactivex.internal.operators.maybe.MaybeDefer {
 # void subscribeActual(MaybeObserver<? super T> observer) 
 
}
class io.reactivex.internal.operators.maybe.MaybeDelay {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long delay;
~        final TimeUnit unit;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
~    final Publisher<U> other;
~        final OtherSubscriber<T> other;
~        final Publisher<U> otherSource;
 
}
class io.reactivex.internal.operators.maybe.MaybeDelayOtherTest {
 + void justWithOnNext() 
+ void justWithOnComplete() 
+ void justWithOnError() 
+ void emptyWithOnNext() 
+ void emptyWithOnComplete() 
+ void emptyWithOnError() 
+ void errorWithOnNext() 
+ void errorWithOnComplete() 
+ void errorWithOnError() 
+ void withCompletableDispose() 
+ void withCompletableDoubleOnSubscribe() 
+ void withOtherPublisherDispose() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final Publisher<U> other;
~        final DelayMaybeObserver<T> main;
 
}
class io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionTest {
 + void normal() 
+ void timed() 
+ void timedEmpty() 
+ void timedTestScheduler() 
+ void otherError() 
+ void mainError() 
+ void withPublisherDispose() 
+ void withPublisherDoubleOnSubscribe() 
+ void withPublisherCallAfterTerminalEvent() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDelayTest {
 + void success() 
+ void error() 
+ void complete() 
+ void nullUnit() 
+ void nullScheduler() 
+ void disposeDuringDelay() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable {
 # void subscribeActual(MaybeObserver<? super T> subscriber) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSuccess(T value) 
~    final MaybeSource<T> source;
~    final CompletableSource other;
~        final MaybeSource<T> source;
~        final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.operators.maybe.MaybeDetach {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDetachTest {
 + void doubleSubscribe() 
+ void dispose() 
+ void onError() 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDoAfterSuccess {
 # void subscribeActual(MaybeObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDoAfterSuccessTest {
 + void accept(Integer e) 
+ void onNext(Integer t) 
+ void just() 
+ void error() 
+ void empty() 
+ void consumerNull() 
+ void justConditional() 
+ void errorConditional() 
+ void emptyConditional() 
+ void consumerThrows() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDoFinally {
 # void subscribeActual(MaybeObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Action onFinally;
~        final Action onFinally;
 
}
class io.reactivex.internal.operators.maybe.MaybeDoFinallyTest {
 + void run() 
+ void normalJust() 
+ void normalEmpty() 
+ void normalError() 
+ void doubleOnSubscribe() 
+ Maybe<Object> apply(Maybe<Object> f) 
+ void normalJustConditional() 
+ void normalEmptyConditional() 
+ void normalErrorConditional() 
+ void nullAction() 
+ void actionThrows() 
+ void actionThrowsConditional() 
+ void disposed() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDoOnEvent {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeDoOnEventTest {
 + void dispose() 
+ void doubleOnSubscribe() 
+ void onSubscribeCrash() 
+ void accept(Disposable s) 
 
}
class io.reactivex.internal.operators.maybe.MaybeEmpty {
 # void subscribeActual(MaybeObserver<? super Object> observer) 
+ Object call() 
 
}
class io.reactivex.internal.operators.maybe.MaybeEmptyTest {
 + void scalarCallable() 
 
}
class io.reactivex.internal.operators.maybe.MaybeEqualSingle {
 # void subscribeActual(SingleObserver<? super Boolean> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~        final EqualObserver<T> observer1;
~        final EqualObserver<T> observer2;
~        final EqualCoordinator<T> parent;
 
}
class io.reactivex.internal.operators.maybe.MaybeEqualTest {
 + void dispose() 
+ void predicateThrows() 
 
}
class io.reactivex.internal.operators.maybe.MaybeError {
 # void subscribeActual(MaybeObserver<? super T> observer) 
~    final Throwable error;
 
}
class io.reactivex.internal.operators.maybe.MaybeErrorCallable {
 # void subscribeActual(MaybeObserver<? super T> observer) 
 
}
class io.reactivex.internal.operators.maybe.MaybeErrorTest {
 + void errorCallableThrows() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFilter {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFilterSingle {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeFilterSingleTest {
 + void error() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector {
 # void subscribeActual(MaybeObserver<? super R> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSuccess(U value) 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelectorTest {
 + String apply(Integer a, Integer b) 
+ void normal() 
+ void normalWithEmpty() 
+ void emptyWithJust() 
+ MaybeSource<Integer> apply(Integer v) 
+ void errorWithJust() 
+ void justWithError() 
+ void dispose() 
+ Object apply(Object a, Integer b) 
+ void doubleOnSubscribe() 
+ void mapperThrows() 
+ void mapperReturnsNull() 
+ void resultSelectorThrows() 
+ Object apply(Integer a, Integer b) 
+ void resultSelectorReturnsNull() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapCompletable {
 # void subscribeActual(CompletableObserver s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final MaybeSource<T> source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapCompletableTest {
 + void dispose() 
+ void mapperThrows() 
+ void mapperReturnsNull() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowable {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
+ R poll() 
~    final MaybeSource<T> source;
~        final AtomicLong requested;
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowableTest {
 + void normal() 
+ void emptyIterable() 
+ void error() 
+ void empty() 
+ void backpressure() 
+ void take() 
+ void fused() 
+ void fusedNoSync() 
+ void iteratorCrash() 
+ void hasNextCrash() 
+ void nextCrash() 
+ void hasNextCrash2() 
+ void async1() 
+ void async2() 
+ void async3() 
+ void async4() 
+ void fusedEmptyCheck() 
+ void onSubscribe(Subscription d) 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void hasNextThrowsUnbounded() 
+ void nextThrowsUnbounded() 
+ void hasNextThrows() 
+ void nextThrows() 
+ void requestBefore() 
+ void requestCreateInnerRace() 
+ void run() 
+ void cancelCreateInnerRace() 
+ void slowPathCancelAfterHasNext() 
+ Integer next() 
+ void remove() 
+ void fastPathCancelAfterHasNext() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservable {
 # void subscribeActual(Observer<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
+ R poll() 
~    final MaybeSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservableTest {
 + void normal() 
+ void emptyIterable() 
+ void error() 
+ void empty() 
+ void take() 
+ void fused() 
+ void fusedNoSync() 
+ void iteratorCrash() 
+ void hasNextCrash() 
+ void nextCrash() 
+ void hasNextCrash2() 
+ void doubleOnSubscribe() 
+ void dispose() 
+ void async1() 
+ void async2() 
+ void async3() 
+ void async4() 
+ void fusedEmptyCheck() 
+ void onSubscribe(Disposable d) 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapNotification {
 # void subscribeActual(MaybeObserver<? super R> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSuccess(R value) 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapNotificationTest {
 + void dispose() 
+ void doubleOnSubscribe() 
+ void onSuccessNull() 
+ void onErrorNull() 
+ void onCompleteNull() 
+ void onSuccessEmpty() 
+ void onSuccessError() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapSingle {
 # void subscribeActual(SingleObserver<? super R> actual) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(final Disposable d) 
+ void onSuccess(final R value) 
+ void onError(final Throwable e) 
~    final MaybeSource<T> source;
~        final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement {
 # void subscribeActual(MaybeObserver<? super R> actual) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(final Disposable d) 
+ void onSuccess(final R value) 
+ void onError(final Throwable e) 
~    final MaybeSource<T> source;
~        final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElementTest {
 + void flatMapSingleElementNull() 
+ void flatMapSingleElementValue() 
+ void flatMapSingleElementValueDifferentType() 
+ void flatMapSingleElementValueNull() 
+ void flatMapSingleElementValueErrorThrown() 
+ void flatMapSingleElementError() 
+ void flatMapSingleElementEmpty() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void singleErrors() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatMapSingleTest {
 + void flatMapSingleNull() 
+ void flatMapSingleValue() 
+ void flatMapSingleValueDifferentType() 
+ void flatMapSingleValueNull() 
+ void flatMapSingleValueErrorThrown() 
+ void flatMapSingleError() 
+ void flatMapSingleEmpty() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void singleErrors() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlatten {
 # void subscribeActual(MaybeObserver<? super R> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSuccess(R value) 
 
}
class io.reactivex.internal.operators.maybe.MaybeFlattenTest {
 + void dispose() 
+ void doubleOnSubscribe() 
+ void mainError() 
+ void mainEmpty() 
+ void mapperThrows() 
+ void mapperReturnsNull() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromAction {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ T call() 
~    final Action action;
 
}
class io.reactivex.internal.operators.maybe.MaybeFromActionTest {
 + void fromActionNull() 
+ void fromAction() 
+ void fromActionTwice() 
+ void fromActionInvokesLazy() 
+ void fromActionThrows() 
+ void callable() 
+ void run() 
+ void noErrorLoss() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromCallable {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ T call() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromCallableTest {
 + void fromCallableNull() 
+ void fromCallable() 
+ void fromCallableTwice() 
+ void fromCallableInvokesLazy() 
+ void fromCallableThrows() 
+ void callable() 
+ Integer call() 
+ void noErrorLoss() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromCompletable {
 + CompletableSource source() 
# void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onComplete() 
+ void onError(Throwable e) 
~    final CompletableSource source;
 
}
class io.reactivex.internal.operators.maybe.MaybeFromCompletableTest {
 + void fromCompletableNull() 
+ void fromCompletable() 
+ void fromCompletableError() 
+ void source() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromFuture {
 # void subscribeActual(MaybeObserver<? super T> observer) 
~    final long timeout;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.maybe.MaybeFromFutureTest {
 + void cancelImmediately() 
+ void timeout() 
+ void timedWait() 
+ void interrupt() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromRunnable {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ T call() 
~    final Runnable runnable;
 
}
class io.reactivex.internal.operators.maybe.MaybeFromRunnableTest {
 + void fromRunnableNull() 
+ void fromRunnable() 
+ void fromRunnableTwice() 
+ void fromRunnableInvokesLazy() 
+ void fromRunnableThrows() 
+ void callable() 
+ void run() 
+ void noErrorLoss() 
 
}
class io.reactivex.internal.operators.maybe.MaybeFromSingle {
 + SingleSource<T> source() 
# void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeFromSingleTest {
 + void fromSingleNull() 
+ void fromSingle() 
+ void fromSingleThrows() 
+ void source() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeHide {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeHideTest {
 + void normal() 
+ void empty() 
+ void error() 
+ void hidden() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeIgnoreElement {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable {
 # void subscribeActual(CompletableObserver observer) 
+ Maybe<T> fuseToMaybe() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
~    final MaybeSource<T> source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.maybe.MaybeIgnoreElementTest {
 + void dispose() 
+ void dispose2() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeIsEmpty {
 # void subscribeActual(MaybeObserver<? super Boolean> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeIsEmptySingle {
 + MaybeSource<T> source() 
+ Maybe<Boolean> fuseToMaybe() 
# void subscribeActual(SingleObserver<? super Boolean> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final MaybeSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeIsEmptySingleTest {
 + void source() 
 
}
class io.reactivex.internal.operators.maybe.MaybeIsEmptyTest {
 + void normal() 
+ void empty() 
+ void error() 
+ void fusedBackToMaybe() 
+ void normalToMaybe() 
+ void emptyToMaybe() 
+ void errorToMaybe() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
+ void disposeToMaybe() 
+ void isDisposedToMaybe() 
+ void doubleOnSubscribeToMaybe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeJust {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ T call() 
~    final T value;
 
}
class io.reactivex.internal.operators.maybe.MaybeJustTest {
 + void scalarCallable() 
 
}
class io.reactivex.internal.operators.maybe.MaybeLift {
 # void subscribeActual(MaybeObserver<? super R> observer) 
 
}
class io.reactivex.internal.operators.maybe.MaybeMap {
 # void subscribeActual(MaybeObserver<? super R> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeMergeArray {
 # void subscribeActual(Subscriber<? super T> s) 
+ int requestFusion(int mode) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean offer(T value) 
+ boolean offer(T v1, T v2) 
+ T peek() 
+ void drop() 
+ int consumerIndex() 
+ int producerIndex() 
+ boolean offer(T e) 
~        final CompositeDisposable set;
~        final AtomicLong requested;
~        final SimpleQueueWithConsumerIndex<Object> queue;
~        final AtomicThrowable error;
~        final int sourceCount;
~        final AtomicInteger producerIndex;
 
}
class io.reactivex.internal.operators.maybe.MaybeMergeArray.MergeMaybeObserver
class io.reactivex.internal.operators.maybe.MaybeMergeArrayTest {
 + void normal() 
+ void fusedPollMixed() 
+ void fusedEmptyCheck() 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void cancel() 
+ void firstErrors() 
+ void errorFused() 
+ void errorRace() 
+ void run() 
+ void mergeBadSource() 
+ void smallOffer2Throws() 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void largeOffer2Throws() 
 
}
class io.reactivex.internal.operators.maybe.MaybeMergeWithTest {
 + void normal() 
 
}
class io.reactivex.internal.operators.maybe.MaybeNever {
 # void subscribeActual(MaybeObserver<? super Object> observer) 
 
}
class io.reactivex.internal.operators.maybe.MaybeObserveOn {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void run() 
~    final Scheduler scheduler;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.maybe.MaybeOfTypeTest {
 + void normal() 
+ void normalDowncast() 
+ void notInstance() 
+ void error() 
+ void errorNotInstance() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeOnErrorComplete {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.maybe.MaybeOnErrorNext {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final boolean allowFatal;
~        final boolean allowFatal;
~            final AtomicReference<Disposable> d;
 
}
class io.reactivex.internal.operators.maybe.MaybeOnErrorReturn {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeOnErrorXTest {
 + void onErrorReturnConst() 
+ void onErrorReturn() 
+ void onErrorComplete() 
+ void onErrorCompleteTrue() 
+ void onErrorCompleteFalse() 
+ void onErrorReturnFunctionThrows() 
+ void onErrorCompletePredicateThrows() 
+ void onErrorResumeNext() 
+ void onExceptionResumeNext() 
+ void onExceptionResumeNextPassthrough() 
+ void onErrorResumeNextFunctionThrows() 
+ void onErrorReturnSuccess() 
+ void onErrorReturnEmpty() 
+ void onErrorReturnDispose() 
+ void onErrorReturnDoubleOnSubscribe() 
+ void onErrorCompleteSuccess() 
+ void onErrorCompleteEmpty() 
+ void onErrorCompleteDispose() 
+ void onErrorCompleteDoubleOnSubscribe() 
+ void onErrorNextDispose() 
+ void onErrorNextDoubleOnSubscribe() 
+ void onErrorNextIsAlsoError() 
 
}
class io.reactivex.internal.operators.maybe.MaybePeek {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final Action onCompleteCall;
~    final Action onAfterTerminate;
~    final Action onDisposeCall;
~        final MaybePeek<T> parent;
 
}
class io.reactivex.internal.operators.maybe.MaybePeekTest {
 + void disposed() 
+ void doubleOnSubscribe() 
+ void doubleError() 
# void subscribeActual(MaybeObserver<? super Integer> observer) 
+ void accept(Throwable e) 
+ void doubleComplete() 
+ void run() 
+ void doOnErrorThrows() 
+ void afterTerminateThrows() 
 
}
class io.reactivex.internal.operators.maybe.MaybeSubscribeOn {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final Scheduler scheduler;
~        final MaybeSource<T> source;
~        final SequentialDisposable task;
 
}
class io.reactivex.internal.operators.maybe.MaybeSubscribeOnTest {
 + void dispose() 
 
}
class io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~            final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptyTest {
 + void nonEmpty() 
+ void empty() 
+ void defaultIfEmptyNonEmpty() 
+ void defaultIfEmptyEmpty() 
+ void error() 
+ void errorOther() 
+ void emptyOtherToo() 
+ void dispose() 
+ void isDisposed() 
+ void doubleOnSubscribe() 
+ void emptyCancelRace() 
+ void run() 
 
}
class io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSuccess(Object value) 
~    final MaybeSource<U> other;
~        final TakeUntilOtherMaybeObserver<U> other;
 
}
class io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object value) 
~    final Publisher<U> other;
~        final TakeUntilOtherMaybeObserver<U> other;
 
}
class io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisherTest {
 + void disposed() 
+ void doubleOnSubscribe() 
+ void mainErrors() 
+ void otherErrors() 
+ void mainCompletes() 
+ void otherCompletes() 
+ void onErrorRace() 
+ void run() 
+ void onCompleteRace() 
+ void otherSignalsAndCompletes() 
 
}
class io.reactivex.internal.operators.maybe.MaybeTakeUntilTest {
 + void normalPublisher() 
+ void normalMaybe() 
+ void untilFirstPublisher() 
+ void untilFirstMaybe() 
+ void disposed() 
+ void doubleOnSubscribe() 
+ void mainErrors() 
+ void otherErrors() 
+ void mainCompletes() 
+ void otherCompletes() 
+ void onErrorRace() 
+ void run() 
+ void onCompleteRace() 
 
}
class io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void otherError(Throwable e) 
+ void otherComplete() 
+ void onSuccess(Object value) 
~    final MaybeSource<U> other;
~        final TimeoutFallbackMaybeObserver<T> otherObserver;
 
}
class io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void otherError(Throwable e) 
+ void otherComplete() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object value) 
~    final Publisher<U> other;
~        final TimeoutFallbackMaybeObserver<T> otherObserver;
 
}
class io.reactivex.internal.operators.maybe.MaybeTimeoutPublisherTest {
 + void mainError() 
+ void otherError() 
+ void fallbackError() 
+ void fallbackComplete() 
+ void mainComplete() 
+ void otherComplete() 
+ void dispose() 
+ void dispose2() 
+ void onErrorRace() 
+ void run() 
+ void onCompleteRace() 
+ void badSourceOther() 
 
}
class io.reactivex.internal.operators.maybe.MaybeTimeoutTest {
 + void normal() 
+ void normalMaybe() 
+ void never() 
+ void neverMaybe() 
+ void normalFallback() 
+ void normalMaybeFallback() 
+ void neverFallback() 
+ void neverMaybeFallback() 
+ void neverFallbackScheduler() 
+ void neverScheduler() 
+ void normalFlowableFallback() 
+ void neverFlowableFallback() 
+ void normalFlowable() 
+ void neverFlowable() 
+ void mainError() 
+ void otherError() 
+ void fallbackError() 
+ void fallbackComplete() 
+ void mainComplete() 
+ void otherComplete() 
+ void dispose() 
+ void dispose2() 
+ void onErrorRace() 
+ void run() 
+ void onCompleteRace() 
 
}
class io.reactivex.internal.operators.maybe.MaybeTimer {
 # void subscribeActual(final MaybeObserver<? super Long> observer) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.maybe.MaybeTimerTest {
 + void dispose() 
+ void timerInterruptible() 
+ Long apply(Long v) 
 
}
class io.reactivex.internal.operators.maybe.MaybeToCompletableTest {
 + void source() 
+ void dispose() 
+ void successToComplete() 
+ void doubleSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeToFlowable {
 + MaybeSource<T> source() 
# void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void cancel() 
~    final MaybeSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeToFlowableTest {
 + void source() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeToObservable {
 + MaybeSource<T> source() 
# void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
~    final MaybeSource<T> source;
 
}
class io.reactivex.internal.operators.maybe.MaybeToObservableTest {
 + void source() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeToSingle {
 + MaybeSource<T> source() 
# void subscribeActual(SingleObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final MaybeSource<T> source;
~    final T defaultValue;
~        final T defaultValue;
 
}
class io.reactivex.internal.operators.maybe.MaybeToSingleTest {
 + void source() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.maybe.MaybeUnsafeCreate {
 # void subscribeActual(MaybeObserver<? super T> observer) 
 
}
class io.reactivex.internal.operators.maybe.MaybeUnsubscribeOn {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ void run() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final Scheduler scheduler;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.maybe.MaybeUnsubscribeOnTest {
 + void normal() 
+ void run() 
+ void just() 
+ void error() 
+ void empty() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void disposeRace() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.maybe.MaybeUsing {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final boolean eager;
~        final boolean eager;
 
}
class io.reactivex.internal.operators.maybe.MaybeUsingTest {
 + void resourceSupplierThrows() 
+ MaybeSource<Integer> apply(Object v) 
+ void accept(Object d) 
+ void errorEager() 
+ void emptyEager() 
+ void errorNonEager() 
+ void emptyNonEager() 
+ void supplierCrashEager() 
+ void supplierCrashNonEager() 
+ void supplierAndDisposerCrashEager() 
+ void supplierAndDisposerCrashNonEager() 
+ void dispose() 
+ Object call() 
+ void disposeCrashes() 
+ void isDisposed() 
+ void justDisposerCrashes() 
+ void emptyDisposerCrashes() 
+ void errorDisposerCrash() 
+ void doubleOnSubscribe() 
+ void successDisposeRace() 
+ void run() 
+ void errorDisposeRace() 
+ void emptyDisposeRace() 
 
}
class io.reactivex.internal.operators.maybe.MaybeZipArray {
 # void subscribeActual(MaybeObserver<? super R> observer) 
+ boolean isDisposed() 
+ void dispose() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ R apply(T t) 
~        final ZipMaybeObserver<T>[] observers;
~        final Object[] values;
~        final int index;
 
}
class io.reactivex.internal.operators.maybe.MaybeZipArray.ZipCoordinator
class io.reactivex.internal.operators.maybe.MaybeZipArrayTest {
 + Object apply(Object a, Object b) 
+ Object apply(Object a, Object b, Object c) 
+ void firstError() 
+ void secondError() 
+ void dispose() 
+ void zipperThrows() 
+ void zipperReturnsNull() 
+ void middleError() 
+ void innerErrorRace() 
+ void run() 
+ void zipArrayOneIsNull() 
 
}
class io.reactivex.internal.operators.maybe.MaybeZipIterable {
 # void subscribeActual(MaybeObserver<? super R> observer) 
+ R apply(T t) 
 
}
class io.reactivex.internal.operators.maybe.MaybeZipIterableTest {
 + Object apply(Object[] a) 
+ void firstError() 
+ void secondError() 
+ void dispose() 
+ void zipperThrows() 
+ void zipperReturnsNull() 
+ void middleError() 
+ void innerErrorRace() 
+ void run() 
+ void iteratorThrows() 
+ void hasNextThrows() 
+ void nextThrows() 
+ void zipIterableOneIsNull() 
+ void zipIterableTwoIsNull() 
 
}
class io.reactivex.internal.operators.maybe.Observable
class io.reactivex.internal.operators.maybe.Single
class io.reactivex.internal.operators.observable.AbstractObservableWithUpstreamTest {
 + void source() 
 
}
class io.reactivex.internal.operators.observable.BlockingObservableIterable {
 + Iterator<T> iterator() 
+ boolean hasNext() 
+ T next() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void remove() 
+ void dispose() 
+ boolean isDisposed() 
~    final int bufferSize;
~        final SpscLinkedArrayQueue<T> queue;
~        final Lock lock;
~        final Condition condition;
 
}
class io.reactivex.internal.operators.observable.BlockingObservableIterable.BlockingObservableIterator
class io.reactivex.internal.operators.observable.BlockingObservableLatest {
 + Iterator<T> iterator() 
+ void onNext(Notification<T> args) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean hasNext() 
+ T next() 
+ void remove() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.BlockingObservableLatestTest {
 + void testSimple() 
+ void testSameSourceMultipleIterators() 
+ void testEmpty() 
+ void testSimpleJustNext() 
+ void testHasNextThrows() 
+ void testNextThrows() 
+ void testFasterSource() 
+ void remove() 
+ void empty() 
+ void error() 
+ void error2() 
+ void interrupted() 
+ void onError() 
 
}
class io.reactivex.internal.operators.observable.BlockingObservableMostRecent {
 + Iterator<T> iterator() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(T args) 
+ Iterator getIterable() 
+ boolean hasNext() 
+ T next() 
+ void remove() 
~    final ObservableSource<T> source;
~    final T initialValue;
            - Object buf;
 
}
class io.reactivex.internal.operators.observable.BlockingObservableMostRecentTest {
 + void testMostRecentNull() 
+ void testMostRecent() 
+ void testMostRecentWithException() 
+ void testSingleSourceManyIterators() 
+ void empty() 
 
}
class io.reactivex.internal.operators.observable.BlockingObservableNext {
 + Iterator<T> iterator() 
+ boolean hasNext() 
- boolean moveToNext() 
+ T next() 
+ void remove() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Notification<T> args) 
+ Notification<T> takeNext() 
~    final ObservableSource<T> source;
        - final NextObserver<T> observer;
        - final ObservableSource<T> items;
        - T next;
        - Throwable error;
        - boolean started;
 
}
class io.reactivex.internal.operators.observable.BlockingObservableNext.NextObserver
class io.reactivex.internal.operators.observable.BlockingObservableNextTest {
 - void fireOnNextInNewThread(final Subject<String> o, final String value) 
- void fireOnErrorInNewThread(final Subject<String> o) 
+ void testNext() 
+ void testNextWithError() 
+ void testNextWithEmpty() 
+ void testOnError() 
+ void testOnErrorInNewThread() 
- void assertErrorAfterObservableFail(Iterator<String> it) 
+ void testNextWithOnlyUsingNextMethod() 
+ void testNextWithCallingHasNextMultipleTimes() 
+ void testNoBufferingOrBlockingOfSequence() 
+ void testSingleSourceManyIterators() 
+ void testSynchronousNext() 
+ void interrupt() 
+ void remove() 
+ void nextObserverError() 
+ void nextObserverOnNext() 
+ void nextObserverOnCompleteOnNext() 
 
}
class io.reactivex.internal.operators.observable.BlockingObservableToFutureTest {
 + void constructorShouldBePrivate() 
+ void testToFuture() 
+ void testToFutureList() 
+ void testExceptionWithMoreThanOneElement() 
+ void testToFutureWithException() 
+ void testGetAfterCancel() 
+ void testGetWithTimeoutAfterCancel() 
+ void testGetWithEmptyFlowable() 
+ void testGetWithASingleNullItem() 
 
}
class io.reactivex.internal.operators.observable.BlockingObservableToIteratorTest {
 + void testToIterator() 
+ void testToIteratorWithException() 
+ void testExceptionThrownFromOnSubscribe() 
+ void dispose() 
+ void interruptWait() 
+ void emptyThrowsNoSuch() 
+ void remove() 
 
}
class io.reactivex.internal.operators.observable.Burst {
 # void subscribeActual(final Observer<? super T> observer) 
+ Observable<T> error(Throwable e) 
+ Observable<T> create() 
~    final List<T> items;
~    final Throwable error;
        - final List<T> items;
        - Throwable error;
 
}
class io.reactivex.internal.operators.observable.Completable
class io.reactivex.internal.operators.observable.Maybe
class io.reactivex.internal.operators.observable.Observable
class io.reactivex.internal.operators.observable.ObservableAll {
 # void subscribeActual(Observer<? super Boolean> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.observable.ObservableAllSingle {
 # void subscribeActual(SingleObserver<? super Boolean> t) 
+ Observable<Boolean> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableAllTest {
 + void testAllObservable() 
+ void testNotAllObservable() 
+ void testEmptyObservable() 
+ void testErrorObservable() 
+ void testFollowingFirstObservable() 
+ void testIssue1935NoUnsubscribeDownstreamObservable() 
+ Observable<Integer> apply(Boolean t1) 
+ void testPredicateThrowsExceptionAndValueInCauseMessageObservable() 
+ void testAll() 
+ void testNotAll() 
+ void testEmpty() 
+ void testError() 
+ void testFollowingFirst() 
+ void testIssue1935NoUnsubscribeDownstream() 
+ void testPredicateThrowsExceptionAndValueInCauseMessage() 
+ void dispose() 
+ void predicateThrowsObservable() 
+ boolean test(Integer v) 
+ void predicateThrows() 
 
}
class io.reactivex.internal.operators.observable.ObservableAmb {
 + void subscribeActual(Observer<? super T> s) 
+ void subscribe(ObservableSource<? extends T>[] sources) 
+ boolean win(int index) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final AmbInnerObserver<T>[] observers;
~        final AmbCoordinator<T> parent;
~        final int index;
 
}
class io.reactivex.internal.operators.observable.ObservableAmbTest {
 + void setUp() 
- Observable<String> createObservable(final String[] values,
            final long interval, final Throwable e) 
+ void run() 
+ void testAmb() 
+ void testAmb2() 
+ void testAmb3() 
+ void testSubscriptionOnlyHappensOnce() 
+ void testSynchronousSources() 
+ void testAmbCancelsOthers() 
+ void ambArrayEmpty() 
+ void ambArraySingleElement() 
+ void manySources() 
+ void emptyIterable() 
+ void singleIterable() 
+ void disposed() 
+ void onNextRace() 
+ void onCompleteRace() 
+ void onErrorRace() 
+ void ambWithOrder() 
+ void ambIterableOrder() 
+ void ambArrayOrder() 
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableAny {
 # void subscribeActual(Observer<? super Boolean> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.observable.ObservableAnySingle {
 # void subscribeActual(SingleObserver<? super Boolean> t) 
+ Observable<Boolean> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableAnyTest {
 + void testAnyWithTwoItemsObservable() 
+ void testIsEmptyWithTwoItemsObservable() 
+ void testAnyWithOneItemObservable() 
+ void testIsEmptyWithOneItemObservable() 
+ void testAnyWithEmptyObservable() 
+ void testIsEmptyWithEmptyObservable() 
+ void testAnyWithPredicate1Observable() 
+ void testExists1Observable() 
+ void testAnyWithPredicate2Observable() 
+ void testAnyWithEmptyAndPredicateObservable() 
+ void testWithFollowingFirstObservable() 
+ void testIssue1935NoUnsubscribeDownstreamObservable() 
+ void testPredicateThrowsExceptionAndValueInCauseMessageObservable() 
+ void testAnyWithTwoItems() 
+ void testIsEmptyWithTwoItems() 
+ void testAnyWithOneItem() 
+ void testIsEmptyWithOneItem() 
+ void testAnyWithEmpty() 
+ void testIsEmptyWithEmpty() 
+ void testAnyWithPredicate1() 
+ void testExists1() 
+ void testAnyWithPredicate2() 
+ void testAnyWithEmptyAndPredicate() 
+ void testWithFollowingFirst() 
+ void testIssue1935NoUnsubscribeDownstream() 
+ void testPredicateThrowsExceptionAndValueInCauseMessage() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ SingleSource<Boolean> apply(Observable<Object> o) 
+ void predicateThrowsSuppressOthers() 
+ boolean test(Integer v) 
+ void badSourceSingle() 
 
}
class io.reactivex.internal.operators.observable.ObservableAutoConnect {
 + void subscribeActual(Observer<? super T> child) 
~    final int numberOfObservers;
~    final AtomicInteger clients;
 
}
class io.reactivex.internal.operators.observable.ObservableAutoConnectTest {
 + void autoConnectImmediately() 
 
}
class io.reactivex.internal.operators.observable.ObservableBlockingSubscribe {
  
}
class io.reactivex.internal.operators.observable.ObservableBlockingTest {
 + void blockingFirst() 
+ void blockingFirstDefault() 
+ void blockingSubscribeConsumer() 
+ void blockingSubscribeConsumerConsumer() 
+ void blockingSubscribeConsumerConsumerError() 
+ void blockingSubscribeConsumerConsumerAction() 
+ void run() 
+ void blockingSubscribeObserver() 
+ void onNext(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void blockingSubscribeObserverError() 
+ void blockingForEachThrows() 
+ void blockingFirstEmpty() 
+ void blockingLastEmpty() 
+ void blockingFirstNormal() 
+ void blockingLastNormal() 
+ void blockingSingleEmpty() 
+ void utilityClass() 
+ void disposeUpFront() 
+ void delayed() 
# void subscribeActual(Observer<? super Integer> observer) 
+ void interrupt() 
+ void onCompleteDelayed() 
+ void blockingCancelUpfront() 
 
}
class io.reactivex.internal.operators.observable.ObservableBuffer {
 # void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int count;
~    final int skip;
~    final Callable<U> bufferSupplier;
~        final int count;
~        final Callable<U> bufferSupplier;
~        final int skip;
~        final ArrayDeque<U> buffers;
 
}
class io.reactivex.internal.operators.observable.ObservableBufferBoundary {
 # void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void accept(Observer<? super U> a, U v) 
+ void onNext(Open t) 
+ void onNext(Close t) 
~    final Callable<U> bufferSupplier;
~        final Callable<U> bufferSupplier;
~        final CompositeDisposable resources;
~        final List<U> buffers;
~        final U value;
 
}
class io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier {
 # void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void accept(Observer<? super U> a, U v) 
+ void onNext(B t) 
~    final Callable<U> bufferSupplier;
~        final Callable<U> bufferSupplier;
 
}
class io.reactivex.internal.operators.observable.ObservableBufferExactBoundary {
 # void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void accept(Observer<? super U> a, U v) 
+ void onNext(B t) 
~    final ObservableSource<B> boundary;
~    final Callable<U> bufferSupplier;
~        final Callable<U> bufferSupplier;
~        final ObservableSource<B> boundary;
 
}
class io.reactivex.internal.operators.observable.ObservableBufferTest {
 + void before() 
+ void testComplete() 
+ void testSkipAndCountOverlappingBuffers() 
+ void testSkipAndCountGaplessBuffers() 
+ void testSkipAndCountBuffersWithGaps() 
+ void testTimedAndCount() 
+ void testTimed() 
+ void testObservableBasedOpenerAndCloser() 
+ void subscribe(Observer<Object> observer) 
+ Observable<Object> apply(Object opening) 
+ void testObservableBasedCloser() 
+ Observable<Object> call() 
+ void testLongTimeAction() 
+ void accept(List<Integer> t1) 
- List<String> list(String... args) 
+ void run() 
- void complete(final Observer<?> observer, int delay) 
+ void testBufferStopsWhenUnsubscribed1() 
+ void bufferWithBONormal1() 
+ void bufferWithBOEmptyLastViaBoundary() 
+ void bufferWithBOEmptyLastViaSource() 
+ void bufferWithBOEmptyLastViaBoth() 
+ void bufferWithBOSourceThrows() 
+ void bufferWithBOBoundaryThrows() 
+ void bufferWithSizeTake1() 
+ void bufferWithSizeSkipTake1() 
+ void bufferWithTimeTake1() 
+ void bufferWithTimeSkipTake2() 
+ void bufferWithBoundaryTake2() 
+ void bufferWithStartEndBoundaryTake2() 
+ void accept(List<Long> pv) 
+ void bufferWithSizeThrows() 
+ void bufferWithTimeThrows() 
+ void bufferWithTimeAndSize() 
+ void bufferWithStartEndStartThrows() 
+ void bufferWithStartEndEndFunctionThrows() 
+ void bufferWithStartEndEndThrows() 
+ void testBufferWithTimeDoesntUnsubscribeDownstream() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void bufferTimeSkipDefault() 
+ void bufferBoundaryHint() 
~{static} HashSet<Integer> set(Integer... values) 
+ void bufferIntoCustomCollection() 
+ void bufferSkipIntoCustomCollection() 
+ void supplierThrows() 
+ void supplierThrows2() 
+ void supplierThrows3() 
+ void supplierThrows4() 
+ void supplierThrows5() 
+ void supplierThrows6() 
+ void supplierReturnsNull() 
+ void supplierReturnsNull2() 
+ void supplierReturnsNull3() 
+ void boundaryBufferSupplierThrows() 
+ void boundaryBoundarySupplierThrows() 
+ Collection<Object> call() 
+ void boundaryBufferSupplierThrows2() 
+ void boundaryBufferSupplierReturnsNull() 
+ void boundaryBoundarySupplierThrows2() 
+ void boundaryCancel() 
+ void boundaryBoundarySupplierReturnsNull() 
+ void boundaryBoundarySupplierReturnsNull2() 
+ void boundaryMainError() 
+ void boundaryBoundaryError() 
+ void dispose() 
+ void restartTimer() 
+ void bufferSupplierCrash2() 
+ void bufferSkipSupplierCrash2() 
+ void bufferSkipError() 
+ void bufferSkipOverlap() 
+ void bufferTimedExactError() 
+ void bufferTimedSkipError() 
+ void bufferTimedOverlapError() 
+ void bufferTimedExactEmpty() 
+ void bufferTimedSkipEmpty() 
+ void bufferTimedOverlapEmpty() 
+ void bufferTimedExactSupplierCrash() 
+ void bufferTimedExactBoundedError() 
    - Observer<List<String>> observer;
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableBufferTimed {
 # void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ void accept(Observer<? super U> a, U v) 
~    final long timespan;
~    final long timeskip;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final Callable<U> bufferSupplier;
~    final int maxSize;
~    final boolean restartTimerOnMaxSize;
~        final Callable<U> bufferSupplier;
~        final long timespan;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final long timeskip;
~        final Worker w;
~        final List<U> buffers;
~            final U b;
            - final U b;
            - final U buffer;
~        final int maxSize;
~        final boolean restartTimerOnMaxSize;
 
}
class io.reactivex.internal.operators.observable.ObservableBufferUntilSubscriberTest {
 + void testIssue1677() 
+ Observable<Object> apply(Observable<Integer> integerObservable) 
+ void accept(List<Object> integers) 
 
}
class io.reactivex.internal.operators.observable.ObservableCache {
 # void subscribeActual(Observer<? super T> t) 
+ boolean addChild(ReplayDisposable<T> p) 
+ void removeChild(ReplayDisposable<T> p) 
+ void onSubscribe(Disposable s) 
+ void connect() 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
+ void replay() 
~    final CacheState<T> state;
~    final AtomicBoolean once;
~        final SequentialDisposable connection;
~        final AtomicReference<ReplayDisposable<T>[]> observers;
~        final CacheState<T> state;
 
}
class io.reactivex.internal.operators.observable.ObservableCacheTest {
 + void testColdReplayNoBackpressure() 
+ void testCache() 
+ void accept(String v) 
+ void testUnsubscribeSource() 
+ void testTake() 
+ void testAsync() 
+ void testAsyncComeAndGo() 
+ void testNoMissingBackpressureException() 
+ void testValuesAndThenError() 
+ void unsafeChildThrows() 
+ void onNext(Integer t) 
+ void observers() 
+ void disposeOnArrival() 
+ void disposeOnArrival2() 
+ void dispose() 
+ void take() 
+ void subscribeEmitRace() 
+ void run() 
 
}
class io.reactivex.internal.operators.observable.ObservableCastTest {
 + void testCast() 
+ void testCastWithWrongType() 
 
}
class io.reactivex.internal.operators.observable.ObservableCollect {
 # void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final U u;
 
}
class io.reactivex.internal.operators.observable.ObservableCollectSingle {
 # void subscribeActual(SingleObserver<? super U> t) 
+ Observable<U> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
~        final U u;
 
}
class io.reactivex.internal.operators.observable.ObservableCollectTest {
 + void testCollectToListObservable() 
+ void accept(List<Integer> list, Integer v) 
+ void testCollectToStringObservable() 
+ void accept(StringBuilder sb, Integer v) 
+ void testCollectorFailureDoesNotResultInTwoErrorEmissionsObservable() 
+ void testCollectorFailureDoesNotResultInErrorAndCompletedEmissionsObservable() 
+ void testCollectorFailureDoesNotResultInErrorAndOnNextEmissionsObservable() 
+ void collectIntoObservable() 
+ void testCollectToList() 
+ void testCollectToString() 
+ void testCollectorFailureDoesNotResultInTwoErrorEmissions() 
+ void testCollectorFailureDoesNotResultInErrorAndCompletedEmissions() 
+ void testCollectorFailureDoesNotResultInErrorAndOnNextEmissions() 
+ void collectInto() 
+ void dispose() 
+ void accept(List<Integer> a, Integer b) 
+ List<Integer> call() 
+ void doubleOnSubscribe() 
+ ObservableSource<List<Integer>> apply(Observable<Integer> o) 
+ void badSource() 
 
}
class io.reactivex.internal.operators.observable.ObservableCombineLatest {
 + void subscribeActual(Observer<? super R> s) 
+ void subscribe(ObservableSource<? extends T>[] sources) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int bufferSize;
~    final boolean delayError;
~        final T[] latest;
~        final SpscLinkedArrayQueue<Object> queue;
~        final boolean delayError;
~        final int index;
 
}
class io.reactivex.internal.operators.observable.ObservableCombineLatestTest {
 + void testCombineLatestWithFunctionThatThrowsAnException() 
+ void testCombineLatestDifferentLengthObservableSequences1() 
+ void testCombineLatestDifferentLengthObservableSequences2() 
+ void testCombineLatestWithInterleavingSequences() 
+ void testCombineLatest2Types() 
+ void testCombineLatest3TypesA() 
+ void testCombineLatest3TypesB() 
+ String apply(String a1, String a2, String a3) 
+ String apply(String s, Integer i) 
+ String apply(String s, Integer i, int[] iArray) 
- {static} String getStringValue(Object o) 
+ Integer apply(Integer t1, Integer t2) 
+ void combineSimple() 
+ void combineMultipleObservers() 
+ void testFirstNeverProduces() 
+ void testSecondNeverProduces() 
+ void test0Sources() 
+ void test1ToNSources() 
+ void test1ToNSourcesScheduled() 
+ void onNext(List<Object> t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void test2SourcesOverload() 
+ void test3SourcesOverload() 
+ void test4SourcesOverload() 
+ void test5SourcesOverload() 
+ void test6SourcesOverload() 
+ void test7SourcesOverload() 
+ void test8SourcesOverload() 
+ void test9SourcesOverload() 
+ void testZeroSources() 
+ void testWithCombineLatestIssue1717() 
+ Long apply(Long t1, Integer t2) 
+ void combineLatestArrayOfSources() 
+ Object apply(Object[] a) 
+ void combineLatestDelayErrorArrayOfSources() 
+ void combineLatestDelayErrorArrayOfSourcesWithError() 
+ void combineLatestDelayErrorIterableOfSources() 
+ void combineLatestDelayErrorIterableOfSourcesWithError() 
+ void combineLatestEmpty() 
+ void combineLatestDelayErrorEmpty() 
+ void disposed() 
+ void cancelWhileSubscribing() 
+ Object apply(Object a, Object b) 
+ void combineAsync() 
+ void error() 
+ void errorDelayed() 
+ void errorDelayed2() 
+ void onErrorRace() 
+ void run() 
+ void dontSubscribeIfDone() 
+ void accept(Disposable d) 
+ void dontSubscribeIfDone2() 
+ void combine2Observable2Errors() 
+ Object apply(Long aLong) 
+ void accept(Notification<Integer> integerNotification) 
+ void accept(Notification<Object> integerNotification) 
+ Object apply(Object[] objects) 
+ void eagerDispose() 
 
}
class io.reactivex.internal.operators.observable.ObservableConcatMap {
 + void subscribeActual(Observer<? super U> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
+ void onNext(U t) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onNext(R value) 
~    final int bufferSize;
~    final ErrorMode delayErrors;
~        final SequentialDisposable sa;
~        final Observer<U> inner;
~        final int bufferSize;
~        final AtomicThrowable error;
~        final DelayErrorInnerObserver<R> observer;
~        final SequentialDisposable arbiter;
~        final boolean tillTheEnd;
 
}
class io.reactivex.internal.operators.observable.ObservableConcatMapEager {
 # void subscribeActual(Observer<? super R> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void innerNext(InnerQueuedObserver<R> inner, R value) 
+ void innerError(InnerQueuedObserver<R> inner, Throwable e) 
+ void innerComplete(InnerQueuedObserver<R> inner) 
+ void drain() 
~    final ErrorMode errorMode;
~    final int maxConcurrency;
~    final int prefetch;
~        final int maxConcurrency;
~        final int prefetch;
~        final ErrorMode errorMode;
~        final AtomicThrowable error;
~        final ArrayDeque<InnerQueuedObserver<R>> observers;
 
}
class io.reactivex.internal.operators.observable.ObservableConcatMapEagerTest {
 + void normal() 
+ void normalBackpressured() 
+ void normalDelayBoundary() 
+ void normalDelayBoundaryBackpressured() 
+ void normalDelayEnd() 
+ void normalDelayEndBackpressured() 
+ void mainErrorsDelayBoundary() 
+ void mainErrorsDelayEnd() 
+ void mainErrorsImmediate() 
+ void longEager() 
+ Observable<Integer> apply(Integer t) 
+ void before() 
+ void testSimple() 
+ void testSimple2() 
+ void testEagerness2() 
+ void testEagerness3() 
+ void testEagerness4() 
+ void testEagerness5() 
+ void testEagerness6() 
+ void testEagerness7() 
+ void testEagerness8() 
+ void testEagerness9() 
+ void testMainError() 
+ void testInnerError() 
+ void testInnerEmpty() 
+ void testMapperThrows() 
+ void testInvalidMaxConcurrent() 
+ void testInvalidCapacityHint() 
+ void testBackpressure() 
+ void testAsynchronousRun() 
+ void testReentrantWork() 
+ void accept(Integer t) 
+ void testPrefetchIsBounded() 
+ void testInnerNull() 
+ void testMaxConcurrent5() 
+ void many() 
+ void capacityHint() 
+ void Observable() 
+ void ObservableCapacityHint() 
+ void badCapacityHint() 
+ void mappingBadCapacityHint() 
+ void concatEagerIterable() 
+ void dispose() 
+ void empty() 
+ void innerError() 
+ void innerErrorMaxConcurrency() 
+ void innerCallableThrows() 
+ void innerOuterRace() 
+ void run() 
+ void nextCancelRace() 
+ void mapperCancels() 
+ void innerErrorFused() 
+ void innerErrorAfterPoll() 
+ ObservableSource<Integer> apply(Integer v) 
+ void fuseAndTake() 
+ void doubleOnSubscribe() 
+ void oneDelayed() 
 
}
class io.reactivex.internal.operators.observable.ObservableConcatMapTest {
 + void asyncFused() 
+ void dispose() 
+ void dispose2() 
+ void mainError() 
+ void innerError() 
+ void mainErrorDelayed() 
+ void innerErrorDelayError() 
+ void innerErrorDelayError2() 
+ void badSource() 
+ ObservableSource<Integer> apply(Integer v) 
+ void badSourceDelayError() 
+ void normalDelayErrors() 
+ void normalDelayErrorsTillTheEnd() 
+ void onErrorRace() 
+ void run() 
+ void mapperThrows() 
+ void fusedPollThrows() 
+ void fusedPollThrowsDelayError() 
+ void mapperThrowsDelayError() 
+ void badInnerDelayError() 
 
}
class io.reactivex.internal.operators.observable.ObservableConcatTest {
 + void testConcat() 
+ void testConcatWithList() 
+ void testConcatObservableOfObservables() 
+ void subscribe(Observer<? super Observable<String>> observer) 
+ void testSimpleAsyncConcat() 
+ void testNestedAsyncConcatLoop() 
+ void testNestedAsyncConcat() 
+ void testBlockedObservableOfObservables() 
+ void testConcatConcurrentWithInfinity() 
+ void testConcatNonBlockingObservables() 
+ void testConcatUnsubscribe() 
+ void testConcatUnsubscribeConcurrent() 
+ void dispose() 
+ boolean isDisposed() 
+ void subscribe(final Observer<? super T> observer) 
+ void testMultipleObservers() 
+ void concatVeryLongObservableOfObservables() 
+ void concatVeryLongObservableOfObservablesTakeHalf() 
+ void testConcatOuterBackpressure() 
+ void testConcatWithNonCompliantSourceDoubleOnComplete() 
+ void testIssue2890NoStackoverflow() 
+ void onNext(Integer t) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void concatMapRangeAsyncLoopIssue2876() 
+ Observable<Integer> apply(Integer t) 
+ void concat3() 
+ void concat4() 
+ void concatArrayDelayError() 
+ void concatArrayDelayErrorWithError() 
+ void concatIterableDelayError() 
+ void concatIterableDelayErrorWithError() 
+ void concatObservableDelayError() 
+ void concatObservableDelayErrorWithError() 
+ void concatObservableDelayErrorBoundary() 
+ void concatObservableDelayErrorTillEnd() 
+ void concatMapDelayError() 
+ void concatMapDelayErrorWithError() 
+ void concatMapIterableBufferSize() 
+ void emptyArray() 
+ void singleElementArray() 
+ void concatMapDelayErrorEmptySource() 
+ void concatMapDelayErrorJustSource() 
+ void concatArrayEmpty() 
+ void concatArraySingleElement() 
+ void concatMapErrorEmptySource() 
+ void concatMapJustSource() 
+ void noSubsequentSubscription() 
+ void subscribe(ObservableEmitter<Integer> s) 
+ void noSubsequentSubscriptionDelayError() 
+ void noSubsequentSubscriptionIterable() 
+ void noSubsequentSubscriptionDelayErrorIterable() 
        - final List<T> values;
        - Thread t;
        - int count;
        - final CountDownLatch once;
        - final CountDownLatch okToContinue;
        - final T seed;
        - final int size;
 
}
class io.reactivex.internal.operators.observable.ObservableCount {
 + void subscribeActual(Observer<? super Long> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableCountSingle {
 + void subscribeActual(SingleObserver<? super Long> t) 
+ Observable<Long> fuseToObservable() 
+ void onSubscribe(Disposable d) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableCountTest {
 + void dispose() 
+ void doubleOnSubscribe() 
+ SingleSource<Long> apply(Observable<Object> o) 
 
}
class io.reactivex.internal.operators.observable.ObservableCreate {
 # void subscribeActual(Observer<? super T> observer) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ boolean tryOnError(Throwable t) 
+ void onComplete() 
+ void setDisposable(Disposable d) 
+ void setCancellable(Cancellable c) 
+ ObservableEmitter<T> serialize() 
+ void dispose() 
+ boolean isDisposed() 
+ void setDisposable(Disposable s) 
~    final ObservableOnSubscribe<T> source;
~        final ObservableEmitter<T> emitter;
~        final AtomicThrowable error;
~        final SpscLinkedArrayQueue<T> queue;
 
}
class io.reactivex.internal.operators.observable.ObservableCreateTest {
 + void nullArgument() 
+ void basic() 
+ void basicWithCancellable() 
+ void basicWithError() 
+ void basicSerialized() 
+ void basicWithErrorSerialized() 
+ void wrap() 
+ void unsafe() 
+ void unsafeWithObservable() 
+ void createNullValue() 
+ void subscribe(ObservableEmitter<Integer> e) 
+ void createNullValueSerialized() 
+ void callbackThrows() 
+ void nullValue() 
+ void nullThrowable() 
+ void nullValueSync() 
+ void nullThrowableSync() 
+ void onErrorCrash() 
+ void onSubscribe(Disposable d) 
+ void onNext(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onCompleteCrash() 
+ void serialized() 
+ void cancel() 
+ void serializedConcurrentOnNext() 
+ void serializedConcurrentOnNextOnError() 
+ void run() 
+ void serializedConcurrentOnNextOnComplete() 
+ void onErrorRace() 
+ void onCompleteRace() 
+ void tryOnError() 
+ void subscribe(ObservableEmitter<Object> e) 
+ void tryOnErrorSerialized() 
 
}
class io.reactivex.internal.operators.observable.ObservableDebounce {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(U t) 
~            final long index;
~            final T value;
 
}
class io.reactivex.internal.operators.observable.ObservableDebounceTest {
 + void before() 
+ void testDebounceWithCompleted() 
+ void testDebounceNeverEmits() 
+ void testDebounceWithError() 
+ void run() 
+ void debounceSelectorNormal1() 
+ void debounceSelectorFuncThrows() 
+ void debounceSelectorObservableThrows() 
+ void debounceTimedLastIsNotLost() 
+ void debounceSelectorLastIsNotLost() 
+ void debounceWithTimeBackpressure() 
+ void debounceDefault() 
+ void dispose() 
+ void badSource() 
+ void badSourceSelector() 
+ Object apply(final Observable<Integer> o) 
+ void debounceWithEmpty() 
    - TestScheduler scheduler;
    - Observer<String> observer;
 
}
class io.reactivex.internal.operators.observable.ObservableDebounceTimed {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ void setResource(Disposable d) 
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long timeout;
~        final TimeUnit unit;
~        final T value;
~        final long idx;
~        final DebounceTimedObserver<T> parent;
 
}
class io.reactivex.internal.operators.observable.ObservableDefaultIfEmptyTest {
 + void testDefaultIfEmpty() 
+ void testDefaultIfEmptyWithEmpty() 
+ void testEmptyButClientThrows() 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableDefer {
 + void subscribeActual(Observer<? super T> s) 
 
}
class io.reactivex.internal.operators.observable.ObservableDeferTest {
 + void testDefer() 
+ void testDeferFunctionThrows() 
 
}
class io.reactivex.internal.operators.observable.ObservableDelay {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(final T t) 
+ void onError(final Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final boolean delayError;
~        final long delay;
~        final TimeUnit unit;
~        final boolean delayError;
            - final T t;
            - final Throwable throwable;
 
}
class io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther {
 + void subscribeActual(final Observer<? super T> child) 
+ void onSubscribe(Disposable d) 
+ void onNext(U t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onNext(T value) 
~    final ObservableSource<U> other;
~        final SequentialDisposable serial;
 
}
class io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOtherTest {
 + void testNoPrematureSubscription() 
+ void testNoMultipleSubscriptions() 
+ void testCompleteTriggersSubscription() 
+ void testNoPrematureSubscriptionToError() 
+ void testNoSubscriptionIfOtherErrors() 
+ void badSourceOther() 
+ void afterDelayNoInterrupt() 
+ void subscribe(ObservableEmitter<Boolean> emitter) 
 
}
class io.reactivex.internal.operators.observable.ObservableDelayTest {
 + void before() 
+ void testDelay() 
+ void testLongDelay() 
+ void testDelayWithError() 
+ void testDelayWithMultipleSubscriptions() 
+ void testDelaySubscription() 
+ void testDelaySubscriptionDisposeBeforeTime() 
+ void testDelayWithObservableNormal1() 
+ Observable<Integer> apply(Integer t1) 
+ void testDelayWithObservableSingleSend1() 
+ void testDelayWithObservableSourceThrows() 
+ void testDelayWithObservableDelayFunctionThrows() 
+ void testDelayWithObservableDelayThrows() 
+ void testDelayWithObservableSubscriptionNormal() 
+ void testDelayWithObservableSubscriptionFunctionThrows() 
+ void testDelayWithObservableSubscriptionThrows() 
+ void testDelayWithObservableEmptyDelayer() 
+ void testDelayWithObservableSubscriptionRunCompletion() 
+ void testDelayWithObservableAsTimed() 
+ void testDelayWithObservableReorder() 
+ void testDelayEmitsEverything() 
+ void testBackpressureWithTimedDelay() 
+ void testBackpressureWithSubscriptionTimedDelay() 
+ void testBackpressureWithSelectorDelay() 
+ Integer apply(Integer t) 
+ void testBackpressureWithSelectorDelayAndSubscriptionDelay() 
+ void testErrorRunsBeforeOnNext() 
+ void testDelaySupplierSimple() 
+ void testDelaySupplierCompletes() 
+ void testDelaySupplierErrors() 
+ void delayWithTimeDelayError() 
+ void testOnErrorCalledOnScheduler() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ ObservableSource<Object> apply(Observable<Object> o) 
+ void onCompleteFinal() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onErrorFinal() 
    - Observer<Long> observer;
    - Observer<Long> observer2;
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableDematerialize {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(Notification<T> t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableDematerializeTest {
 + void testDematerialize1() 
+ void testDematerialize2() 
+ void testDematerialize3() 
+ void testErrorPassThru() 
+ void testCompletePassThru() 
+ void testHonorsContractWhenCompleted() 
+ void testHonorsContractWhenThrows() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void eventsAfterDematerializedTerminal() 
 
}
class io.reactivex.internal.operators.observable.ObservableDetach {
 # void subscribeActual(Observer<? super T> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableDetachTest {
 + void just() 
+ void error() 
+ void empty() 
+ void range() 
+ void backpressured() 
+ void justUnsubscribed() 
+ void deferredUpstreamProducer() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.observable.ObservableDistinct {
 # void subscribeActual(Observer<? super T> observer) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ int requestFusion(int mode) 
+ T poll() 
+ void clear() 
 
}
class io.reactivex.internal.operators.observable.ObservableDistinctTest {
 + String apply(String s) 
+ void before() 
+ void testDistinctOfNone() 
+ void testDistinctOfNoneWithKeySelector() 
+ void testDistinctOfNormalSource() 
+ void testDistinctOfNormalSourceWithKeySelector() 
+ void testDistinctOfSourceWithNulls() 
+ void testDistinctOfSourceWithExceptionsFromKeySelector() 
+ void error() 
+ void fusedSync() 
+ void fusedAsync() 
+ void fusedClear() 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void collectionSupplierThrows() 
+ void collectionSupplierIsNull() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.observable.ObservableDistinctUntilChanged {
 # void subscribeActual(Observer<? super T> s) 
+ void onNext(T t) 
+ int requestFusion(int mode) 
+ T poll() 
 
}
class io.reactivex.internal.operators.observable.ObservableDistinctUntilChangedTest {
 + String apply(String s) 
+ void before() 
+ void testDistinctUntilChangedOfNone() 
+ void testDistinctUntilChangedOfNoneWithKeySelector() 
+ void testDistinctUntilChangedOfNormalSource() 
+ void testDistinctUntilChangedOfNormalSourceWithKeySelector() 
+ void testDistinctUntilChangedOfSourceWithNulls() 
+ void testDistinctUntilChangedOfSourceWithExceptionsFromKeySelector() 
+ void customComparator() 
+ void customComparatorThrows() 
+ void fused() 
+ void fusedAsync() 
+ void ignoreCancel() 
+ boolean test(Integer a, Integer b) 
+ void mutableWithSelector() 
 
}
class io.reactivex.internal.operators.observable.ObservableDoAfterNext {
 # void subscribeActual(Observer<? super T> s) 
+ void onNext(T t) 
+ int requestFusion(int mode) 
+ T poll() 
 
}
class io.reactivex.internal.operators.observable.ObservableDoAfterNextTest {
 + void accept(Integer e) 
+ void onNext(Integer t) 
+ void just() 
+ void range() 
+ void error() 
+ void empty() 
+ void syncFused() 
+ void asyncFusedRejected() 
+ void asyncFused() 
+ void consumerNull() 
+ void justConditional() 
+ void rangeConditional() 
+ void errorConditional() 
+ void emptyConditional() 
+ void syncFusedConditional() 
+ void asyncFusedRejectedConditional() 
+ void asyncFusedConditional() 
+ void consumerThrows() 
+ void consumerThrowsConditional() 
+ void consumerThrowsConditional2() 
 
}
class io.reactivex.internal.operators.observable.ObservableDoFinally {
 # void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
+ T poll() 
~    final Action onFinally;
~        final Action onFinally;
 
}
class io.reactivex.internal.operators.observable.ObservableDoFinallyTest {
 + void run() 
+ void normalJust() 
+ void normalEmpty() 
+ void normalError() 
+ void normalTake() 
+ void doubleOnSubscribe() 
+ Observable<Object> apply(Observable<Object> f) 
+ void syncFused() 
+ void syncFusedBoundary() 
+ void asyncFused() 
+ void asyncFusedBoundary() 
+ void normalJustConditional() 
+ void normalEmptyConditional() 
+ void normalErrorConditional() 
+ void normalTakeConditional() 
+ void syncFusedConditional() 
+ void nonFused() 
+ void nonFusedConditional() 
+ void syncFusedBoundaryConditional() 
+ void asyncFusedConditional() 
+ void asyncFusedBoundaryConditional() 
+ void nullAction() 
+ void actionThrows() 
+ void actionThrowsConditional() 
+ void clearIsEmpty() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void clearIsEmptyConditional() 
+ void eventOrdering() 
+ void accept(Object v) 
+ void accept(Throwable e) 
+ void eventOrdering2() 
 
}
class io.reactivex.internal.operators.observable.ObservableDoOnEach {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Action onComplete;
~    final Action onAfterTerminate;
~        final Action onComplete;
~        final Action onAfterTerminate;
 
}
class io.reactivex.internal.operators.observable.ObservableDoOnEachTest {
 + void before() 
+ void testDoOnEach() 
+ void testDoOnEachWithError() 
+ void testDoOnEachWithErrorInCallback() 
+ void testIssue1451Case1() 
+ void accept(List<Boolean> booleans) 
+ void testIssue1451Case2() 
+ void testFatalError() 
+ void accept(Object o) 
+ void onErrorThrows() 
+ void ignoreCancel() 
+ void accept(Object e) 
+ void onErrorAfterCrash() 
+ void run() 
+ void onCompleteAfterCrash() 
+ void onCompleteCrash() 
+ void ignoreCancelConditional() 
+ void onErrorAfterCrashConditional() 
+ void onCompleteAfter() 
+ void onCompleteAfterCrashConditional() 
+ void onCompleteCrashConditional() 
+ void onErrorOnErrorCrashConditional() 
+ void fused() 
+ void accept(Integer v) 
+ void fusedOnErrorCrash() 
+ void fusedConditional() 
+ void fusedOnErrorCrashConditional() 
+ void fusedAsync() 
+ void fusedAsyncConditional() 
+ void fusedAsyncConditional2() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.observable.ObservableDoOnLifecycle {
 # void subscribeActual(Observer<? super T> observer) 
    - final Action onDispose;
 
}
class io.reactivex.internal.operators.observable.ObservableDoOnSubscribeTest {
 + void testDoOnSubscribe() 
+ void testDoOnSubscribe2() 
+ void accept(Disposable s) 
+ void testDoOnUnSubscribeWorksWithRefCount() 
+ void onSubscribeCrash() 
 
}
class io.reactivex.internal.operators.observable.ObservableDoOnUnsubscribeTest {
 + void testDoOnUnsubscribe() 
+ void accept(Long aLong) 
+ void run() 
+ void testDoOnUnSubscribeWorksWithRefCount() 
 
}
class io.reactivex.internal.operators.observable.ObservableElementAt {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final long index;
~    final T defaultValue;
~    final boolean errorOnFewer;
~        final long index;
~        final T defaultValue;
~        final boolean errorOnFewer;
 
}
class io.reactivex.internal.operators.observable.ObservableElementAtMaybe {
 + void subscribeActual(MaybeObserver<? super T> t) 
+ Observable<T> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
~    final long index;
~        final long index;
 
}
class io.reactivex.internal.operators.observable.ObservableElementAtSingle {
 + void subscribeActual(SingleObserver<? super T> t) 
+ Observable<T> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
~    final long index;
~    final T defaultValue;
~        final long index;
~        final T defaultValue;
 
}
class io.reactivex.internal.operators.observable.ObservableElementAtTest {
 + void testElementAtObservable() 
+ void testElementAtWithIndexOutOfBoundsObservable() 
+ void testElementAtOrDefaultObservable() 
+ void testElementAtOrDefaultWithIndexOutOfBoundsObservable() 
+ void testElementAt() 
+ void testElementAtWithMinusIndex() 
+ void testElementAtWithIndexOutOfBounds() 
+ void testElementAtOrDefault() 
+ void testElementAtOrDefaultWithIndexOutOfBounds() 
+ void testElementAtOrDefaultWithMinusIndex() 
+ void elementAtOrErrorNegativeIndex() 
+ void elementAtOrErrorNoElement() 
+ void elementAtOrErrorOneElement() 
+ void elementAtOrErrorMultipleElements() 
+ void elementAtOrErrorInvalidIndex() 
+ void elementAtOrErrorError() 
+ void elementAtIndex0OnEmptySource() 
+ void elementAtIndex0WithDefaultOnEmptySource() 
+ void elementAtIndex1OnEmptySource() 
+ void elementAtIndex1WithDefaultOnEmptySource() 
+ void elementAtOrErrorIndex1OnEmptySource() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ MaybeSource<Object> apply(Observable<Object> o) 
+ SingleSource<Object> apply(Observable<Object> o) 
+ void elementAtIndex1WithDefaultOnEmptySourceObservable() 
+ void errorObservable() 
+ void badSourceObservable() 
+ void badSource() 
+ void badSource2() 
 
}
class io.reactivex.internal.operators.observable.ObservableEmpty {
 # void subscribeActual(Observer<? super Object> o) 
+ Object call() 
 
}
class io.reactivex.internal.operators.observable.ObservableError {
 + void subscribeActual(Observer<? super T> s) 
 
}
class io.reactivex.internal.operators.observable.ObservableFilter {
 + void subscribeActual(Observer<? super T> s) 
+ void onNext(T t) 
+ int requestFusion(int mode) 
+ T poll() 
 
}
class io.reactivex.internal.operators.observable.ObservableFilterTest {
 + void testFilter() 
+ void testFatalError() 
+ void accept(Integer t) 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void fusedSync() 
+ void fusedAsync() 
+ void fusedReject() 
+ void filterThrows() 
 
}
class io.reactivex.internal.operators.observable.ObservableFinallyTest {
 + void before() 
- void checkActionCalled(Observable<String> input) 
+ void testFinallyCalledOnComplete() 
+ void testFinallyCalledOnError() 
    - Action aAction0;
    - Observer<String> observer;
 
}
class io.reactivex.internal.operators.observable.ObservableFirstTest {
 + boolean test(String value) 
+ void before() 
+ void testFirstOrElseOfNoneObservable() 
+ void testFirstOrElseOfSomeObservable() 
+ void testFirstOrElseWithPredicateOfNoneMatchingThePredicateObservable() 
+ void testFirstOrElseWithPredicateOfSomeObservable() 
+ void testFirstObservable() 
+ void testFirstWithOneElementObservable() 
+ void testFirstWithEmptyObservable() 
+ void testFirstWithPredicateObservable() 
+ void testFirstWithPredicateAndOneElementObservable() 
+ void testFirstWithPredicateAndEmptyObservable() 
+ void testFirstOrDefaultObservable() 
+ void testFirstOrDefaultWithOneElementObservable() 
+ void testFirstOrDefaultWithEmptyObservable() 
+ void testFirstOrDefaultWithPredicateObservable() 
+ void testFirstOrDefaultWithPredicateAndOneElementObservable() 
+ void testFirstOrDefaultWithPredicateAndEmptyObservable() 
+ void testFirstOrElseOfNone() 
+ void testFirstOrElseOfSome() 
+ void testFirstOrElseWithPredicateOfNoneMatchingThePredicate() 
+ void testFirstOrElseWithPredicateOfSome() 
+ void testFirst() 
+ void testFirstWithOneElement() 
+ void testFirstWithEmpty() 
+ void testFirstWithPredicate() 
+ void testFirstWithPredicateAndOneElement() 
+ void testFirstWithPredicateAndEmpty() 
+ void testFirstOrDefault() 
+ void testFirstOrDefaultWithOneElement() 
+ void testFirstOrDefaultWithEmpty() 
+ void testFirstOrDefaultWithPredicate() 
+ void testFirstOrDefaultWithPredicateAndOneElement() 
+ void testFirstOrDefaultWithPredicateAndEmpty() 
+ void firstOrErrorNoElement() 
+ void firstOrErrorOneElement() 
+ void firstOrErrorMultipleElements() 
+ void firstOrErrorError() 
+ void firstOrErrorNoElementObservable() 
+ void firstOrErrorOneElementObservable() 
+ void firstOrErrorMultipleElementsObservable() 
+ void firstOrErrorErrorObservable() 
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMap {
 + void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(U t) 
~    final boolean delayErrors;
~    final int maxConcurrency;
~    final int bufferSize;
~        final boolean delayErrors;
~        final int maxConcurrency;
~        final int bufferSize;
~        final long id;
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapCompletable {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ int requestFusion(int mode) 
~    final boolean delayErrors;
~        final AtomicThrowable errors;
~        final boolean delayErrors;
~        final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable {
 # void subscribeActual(CompletableObserver observer) 
+ Observable<T> fuseToObservable() 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final ObservableSource<T> source;
~    final boolean delayErrors;
~        final CompletableObserver actual;
~        final AtomicThrowable errors;
~        final boolean delayErrors;
~        final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapCompletableTest {
 + void normalObservable() 
+ void mapperThrowsObservable() 
+ void mapperReturnsNullObservable() 
+ void normalDelayErrorObservable() 
+ void normalAsyncObservable() 
+ void normalDelayErrorAllObservable() 
+ void normalDelayInnerErrorAllObservable() 
+ void normalNonDelayErrorOuterObservable() 
+ void fusedObservable() 
+ void disposedObservable() 
+ void normal() 
+ void mapperThrows() 
+ void mapperReturnsNull() 
+ void normalDelayError() 
+ void normalAsync() 
+ void normalDelayErrorAll() 
+ void normalDelayInnerErrorAll() 
+ void normalNonDelayErrorOuter() 
+ void fused() 
+ void disposed() 
+ void innerObserver() 
+ void badSource() 
+ void fusedInternalsObservable() 
+ void onSubscribe(Disposable d) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void innerObserverObservable() 
+ void badSourceObservable() 
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapMaybe {
 # void subscribeActual(Observer<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSuccess(R value) 
+ void onError(Throwable e) 
~    final boolean delayErrors;
~        final boolean delayErrors;
~        final CompositeDisposable set;
~        final AtomicInteger active;
~        final AtomicThrowable errors;
~        final AtomicReference<SpscLinkedArrayQueue<R>> queue;
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapMaybeTest {
 + void normal() 
+ void normalEmpty() 
+ void normalDelayError() 
+ void normalAsync() 
+ void mapperThrowsObservable() 
+ void mapperReturnsNullObservable() 
+ void normalDelayErrorAll() 
+ void takeAsync() 
+ void take() 
+ void middleError() 
+ MaybeSource<Integer> apply(final String s) 
+ void asyncFlatten() 
+ void asyncFlattenNone() 
+ void successError() 
+ void completeError() 
+ void disposed() 
+ void innerSuccessCompletesAfterMain() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void badInnerSource() 
+ void emissionQueueTrigger() 
+ MaybeSource<Integer> apply(PublishSubject<Integer> v) 
+ void emissionQueueTrigger2() 
+ void disposeInner() 
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapSingle {
 # void subscribeActual(Observer<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSuccess(R value) 
+ void onError(Throwable e) 
~    final boolean delayErrors;
~        final boolean delayErrors;
~        final CompositeDisposable set;
~        final AtomicInteger active;
~        final AtomicThrowable errors;
~        final AtomicReference<SpscLinkedArrayQueue<R>> queue;
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapSingleTest {
 + void normal() 
+ void normalDelayError() 
+ void normalAsync() 
+ void mapperThrowsObservable() 
+ void mapperReturnsNullObservable() 
+ void normalDelayErrorAll() 
+ void takeAsync() 
+ void take() 
+ void middleError() 
+ SingleSource<Integer> apply(final String s) 
+ void asyncFlatten() 
+ void successError() 
+ void disposed() 
+ void innerSuccessCompletesAfterMain() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void badInnerSource() 
+ void emissionQueueTrigger() 
+ SingleSource<Integer> apply(PublishSubject<Integer> v) 
+ void disposeInner() 
 
}
class io.reactivex.internal.operators.observable.ObservableFlatMapTest {
 + void testNormal() 
+ Integer apply(Integer t1, Integer t2) 
+ void testCollectionFunctionThrows() 
+ void testResultFunctionThrows() 
+ void testMergeError() 
+ R apply(T t1) 
+ R call() 
+ void testFlatMapTransformsNormal() 
+ void testFlatMapTransformsException() 
+ R apply(T t) 
+ void testFlatMapTransformsOnNextFuncThrows() 
+ void testFlatMapTransformsOnErrorFuncThrows() 
+ void testFlatMapTransformsOnCompletedFuncThrows() 
+ void testFlatMapTransformsMergeException() 
+ void accept(Disposable s) 
+ void run() 
+ void testFlatMapMaxConcurrent() 
+ void testFlatMapSelectorMaxConcurrent() 
+ void testFlatMapTransformsMaxConcurrentNormalLoop() 
+ void testFlatMapTransformsMaxConcurrentNormal() 
+ void flatMapRangeAsyncLoop() 
+ Observable<Integer> apply(Integer t) 
+ void flatMapRangeMixedAsyncLoop() 
+ void flatMapIntPassthruAsync() 
+ void flatMapTwoNestedSync() 
+ void flatMapBiMapper() 
+ Integer apply(Integer a, Integer b) 
+ void flatMapBiMapperWithError() 
+ void flatMapBiMapperMaxConcurrency() 
+ void flatMapEmpty() 
+ void mergeScalar() 
+ void mergeScalar2() 
+ void mergeScalarEmpty() 
+ void mergeScalarError() 
+ void scalarReentrant() 
+ void scalarReentrant2() 
+ void innerCompleteCancelRace() 
+ void fusedInnerThrows() 
+ void fusedInnerThrows2() 
+ void noCrossBoundaryFusion() 
+ Object apply(Integer v) 
+ void cancelScalarDrainRace() 
+ void cancelDrainRace() 
 
}
class io.reactivex.internal.operators.observable.ObservableFlattenIterable {
 # void subscribeActual(Observer<? super R> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.observable.ObservableFlattenIterableTest {
 + void dispose() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.observable.ObservableForEachTest {
 + void forEachWile() 
+ boolean test(Integer v) 
+ void forEachWileWithError() 
+ void accept(Throwable e) 
+ void badSource() 
+ void dispose() 
+ void whilePredicateThrows() 
+ void whileErrorThrows() 
+ void whileCompleteThrows() 
 
}
class io.reactivex.internal.operators.observable.ObservableFromArray {
 + void subscribeActual(Observer<? super T> s) 
+ int requestFusion(int mode) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ void dispose() 
+ boolean isDisposed() 
~    final T[] array;
~        final T[] array;
 
}
class io.reactivex.internal.operators.observable.ObservableFromCallable {
 + void subscribeActual(Observer<? super T> s) 
+ T call() 
 
}
class io.reactivex.internal.operators.observable.ObservableFromCompletableTest {
 + void disposedOnArrival() 
+ Object call() 
+ void disposedOnCall() 
+ void disposedOnCallThrows() 
+ void take() 
 
}
class io.reactivex.internal.operators.observable.ObservableFromFuture {
 + void subscribeActual(Observer<? super T> s) 
~    final long timeout;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.observable.ObservableFromIterable {
 + void subscribeActual(Observer<? super T> s) 
+ int requestFusion(int mode) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.observable.ObservableFromIterableTest {
 + void testNull() 
+ void testListIterable() 
+ void testRawIterable() 
+ String next() 
+ void remove() 
+ void testObservableFromIterable() 
+ void testNoBackpressure() 
+ void testSubscribeMultipleTimes() 
+ void testDoesNotCallIteratorHasNextMoreThanRequiredWithBackpressure() 
+ boolean hasNext() 
+ Integer next() 
+ void testDoesNotCallIteratorHasNextMoreThanRequiredFastPath() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void fusionWithConcatMap() 
+ void iteratorThrows() 
+ void hasNext2Throws() 
+ void hasNextCancels() 
+ void fusionRejected() 
+ void fusionClear() 
+ void onNext(Integer value) 
 
}
class io.reactivex.internal.operators.observable.ObservableFromPublisher {
 # void subscribeActual(final Observer<? super T> o) 
+ void onComplete() 
+ void onError(Throwable t) 
+ void onNext(T t) 
+ void onSubscribe(Subscription s) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.observable.ObservableFromTest {
 + void fromFutureTimeout() 
+ void fromPublisher() 
+ void just10() 
+ void fromArrayEmpty() 
+ void fromArraySingle() 
+ void fromPublisherDispose() 
+ void fromPublisherDoubleOnSubscribe() 
+ void fusionRejected() 
 
}
class io.reactivex.internal.operators.observable.ObservableFromUnsafeSource {
 # void subscribeActual(Observer<? super T> observer) 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableGenerate {
 + void subscribeActual(Observer<? super T> s) 
+ void run() 
- void dispose(S s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Callable<S> stateSupplier;
 
}
class io.reactivex.internal.operators.observable.ObservableGenerateTest {
 + void statefulBiconsumer() 
+ void accept(Object s, Emitter<Object> e) 
+ void accept(Object d) 
+ void stateSupplierThrows() 
+ void generatorThrows() 
+ void disposerThrows() 
+ void dispose() 
+ void nullError() 
+ void accept(Integer s, Emitter<Object> e) 
+ void multipleOnNext() 
+ void multipleOnError() 
+ void multipleOnComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableGroupBy {
 + void subscribeActual(Observer<? super GroupedObservable<K, V>> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void cancel(K key) 
# void subscribeActual(Observer<? super T> observer) 
+ void onError(Throwable e) 
+ void subscribe(Observer<? super T> s) 
~    final int bufferSize;
~    final boolean delayError;
~        final int bufferSize;
~        final boolean delayError;
~        final K key;
~        final SpscLinkedArrayQueue<T> queue;
 
}
class io.reactivex.internal.operators.observable.ObservableGroupByTest {
 + Integer apply(String s) 
+ void testGroupBy() 
+ void testGroupByWithElementSelector() 
+ void testGroupByWithElementSelector2() 
+ void testEmpty() 
+ void testError() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void accept(final GroupedObservable<K, V> o) 
+ void testGroupedEventStream() 
+ Integer apply(Event e) 
+ Observable<String> apply(GroupedObservable<Integer, Event> eventGroupedObservable) 
+ void onNext(String outputMessage) 
+ void testUnsubscribeOnNestedTakeAndSyncInfiniteStream() 
+ void testUnsubscribeOnNestedTakeAndAsyncInfiniteStream() 
- void doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(Observable<Event> es, AtomicInteger subscribeCounter) 
+ void testUnsubscribeViaTakeOnGroupThenMergeAndTake() 
+ void accept(String s) 
+ void testUnsubscribeViaTakeOnGroupThenTakeOnInner() 
+ String apply(Event event) 
+ void testStaggeredCompletion() 
+ Observable<Integer> apply(GroupedObservable<Integer, Integer> group) 
+ void onNext(Integer s) 
+ void testCompletionIfInnerNotSubscribed() 
+ void onNext(GroupedObservable<Integer, Integer> s) 
+ void testIgnoringGroups() 
+ void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete() 
+ Integer apply(Integer t) 
+ Observable<String> apply(final GroupedObservable<Integer, Integer> group) 
+ void run() 
+ String apply(Integer t1) 
+ void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes() 
+ void accept(Notification<String> t1) 
+ void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenObservesOnAndDelaysAndThenCompletes() 
+ void testGroupsWithNestedSubscribeOn() 
+ void testGroupsWithNestedObserveOn() 
+ String toString() 
+ void subscribe(final Observer<? super Event> op) 
+ void testGroupByOnAsynchronousSourceAcceptsMultipleSubscriptions() 
+ Boolean apply(Long n) 
+ Boolean apply(Integer n) 
+ void testGroupByBackpressure() 
+ R apply(T t1) 
+ T apply(Integer t1) 
+ Integer apply(Integer t1) 
+ Integer apply(Integer v) 
+ void normalBehavior() 
+ String apply(String t1) 
+ Observable<String> apply(final GroupedObservable<String, String> g) 
+ void keySelectorThrows() 
+ void valueSelectorThrows() 
+ void innerEscapeCompleted() 
+ void testExceptionIfSubscribeToChildMoreThanOnce() 
+ void testError2() 
+ void testgroupByBackpressure() 
+ String apply(Integer l) 
+ void testgroupByBackpressure2() 
+ Observable<Integer> apply(GroupedObservable<Integer, Integer> t) 
+ void testGroupByWithNullKey() 
+ String apply(String value) 
+ void accept(GroupedObservable<String, String> groupedObservable) 
+ void testGroupByUnsubscribe() 
+ Integer apply(Integer integer) 
+ void testGroupByShouldPropagateError() 
+ void onNext(GroupedObservable<Integer, Integer> o) 
+ void subscribe(Observer<? super Integer> observer) 
+ Integer apply(Integer i) 
+ void keySelectorAndDelayError() 
+ void keyAndValueSelectorAndDelayError() 
+ void dispose() 
+ void reentrantComplete() 
+ void reentrantCompleteCancel() 
+ void delayErrorSimpleComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableGroupJoin {
 # void subscribeActual(Observer<? super R> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void innerError(Throwable ex) 
+ void innerComplete(LeftRightObserver sender) 
+ void innerValue(boolean isLeft, Object o) 
+ void innerClose(boolean isLeft, LeftRightEndObserver index) 
+ void innerCloseError(Throwable ex) 
+ void onSubscribe(Disposable s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final SpscLinkedArrayQueue<Object> queue;
~        final CompositeDisposable disposables;
~        final AtomicReference<Throwable> error;
~        final AtomicInteger active;
~        final JoinSupport parent;
~        final boolean isLeft;
~        final int index;
 
}
class io.reactivex.internal.operators.observable.ObservableGroupJoinTest {
 + Integer apply(Integer t1, Integer t2) 
+ Observable<T> apply(Integer t1) 
+ Observable<R> apply(T t1) 
+ Observable<Integer> apply(final Integer leftValue, Observable<Integer> rightValues) 
+ void before() 
+ void behaveAsJoin() 
+ void normal1() 
+ void onNext(final PPF ppf) 
+ void accept(PersonFruit t1) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(Disposable s) 
+ void leftThrows() 
+ void rightThrows() 
+ void leftDurationThrows() 
+ void rightDurationThrows() 
+ void leftDurationSelectorThrows() 
+ void rightDurationSelectorThrows() 
+ void resultSelectorThrows() 
+ void dispose() 
+ ObservableSource<Object> apply(Integer right) 
+ Object apply(Integer r, Observable<Integer> l) 
+ void innerCompleteLeft() 
+ Observable<Integer> apply(Integer r, Observable<Integer> l) 
+ void innerErrorLeft() 
+ void innerCompleteRight() 
+ void innerErrorRight() 
+ void innerErrorRace() 
+ void run() 
+ void outerErrorRace() 
+ ObservableSource<Object> apply(Object right) 
+ Observable<Object> apply(Object r, Observable<Object> l) 
+ void rightEmission() 
~        final int id;
~        final String name;
~        final int personId;
~        final String fruit;
~        final Person person;
~        final Observable<PersonFruit> fruits;
 
}
class io.reactivex.internal.operators.observable.ObservableHide {
 # void subscribeActual(Observer<? super T> o) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableHideTest {
 + void testHiding() 
+ void testHidingError() 
 
}
class io.reactivex.internal.operators.observable.ObservableIgnoreElements {
 + void subscribeActual(final Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T v) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable {
 + void subscribeActual(final CompletableObserver t) 
+ Observable<T> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void onNext(T v) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final ObservableSource<T> source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.observable.ObservableIgnoreElementsTest {
 + void testWithEmptyObservable() 
+ void testWithNonEmptyObservable() 
+ void testUpstreamIsProcessedButIgnoredObservable() 
+ void testCompletedOkObservable() 
+ void testErrorReceivedObservable() 
+ void testUnsubscribesFromUpstreamObservable() 
+ void testWithEmpty() 
+ void testWithNonEmpty() 
+ void testUpstreamIsProcessedButIgnored() 
+ void testCompletedOk() 
+ void testErrorReceived() 
+ void testUnsubscribesFromUpstream() 
+ void cancel() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.observable.ObservableInternalHelper {
 + S apply(S t1, Emitter<T> t2) 
+ ObservableSource<T> apply(final T v) 
+ void accept(T v) 
+ void accept(Throwable v) 
+ void run() 
+ R apply(U w) 
+ ObservableSource<R> apply(final T t) 
+ ObservableSource<U> apply(T t) 
+ Object apply(Object t) 
+ Throwable apply(Notification<Object> t) 
+ boolean test(Notification<Object> t) 
+ Observable<R> apply(T t) 
+ ConnectableObservable<T> call() 
+ ObservableSource<R> apply(Observable<T> t) 
~        final Consumer<Emitter<T>> consumer;
~        final Observer<T> observer;
        - final T t;
        - final Observable<T> parent;
        - final int bufferSize;
        - final long time;
        - final TimeUnit unit;
        - final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableInternalHelperTest {
 + void utilityClass() 
+ void enums() 
+ void mapToInt() 
 
}
class io.reactivex.internal.operators.observable.ObservableInterval {
 + void subscribeActual(Observer<? super Long> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ void setResource(Disposable d) 
~    final Scheduler scheduler;
~    final long initialDelay;
~    final long period;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.observable.ObservableIntervalRange {
 + void subscribeActual(Observer<? super Long> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ void setResource(Disposable d) 
~    final Scheduler scheduler;
~    final long start;
~    final long end;
~    final long initialDelay;
~    final long period;
~    final TimeUnit unit;
~        final long end;
 
}
class io.reactivex.internal.operators.observable.ObservableIntervalRangeTest {
 + void simple() 
+ void customScheduler() 
+ void countZero() 
+ void countNegative() 
+ void longOverflow() 
+ void dispose() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.observable.ObservableIntervalTest {
 + void dispose() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.observable.ObservableJoin {
 # void subscribeActual(Observer<? super R> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void innerError(Throwable ex) 
+ void innerComplete(LeftRightObserver sender) 
+ void innerValue(boolean isLeft, Object o) 
+ void innerClose(boolean isLeft, LeftRightEndObserver index) 
+ void innerCloseError(Throwable ex) 
~        final SpscLinkedArrayQueue<Object> queue;
~        final CompositeDisposable disposables;
~        final AtomicReference<Throwable> error;
~        final AtomicInteger active;
 
}
class io.reactivex.internal.operators.observable.ObservableJoinTest {
 + Integer apply(Integer t1, Integer t2) 
+ Observable<T> apply(Integer t1) 
+ void before() 
+ void normal1() 
+ void normal1WithDuration() 
+ void normal2() 
+ void leftThrows() 
+ void rightThrows() 
+ void leftDurationThrows() 
+ void rightDurationThrows() 
+ void leftDurationSelectorThrows() 
+ void rightDurationSelectorThrows() 
+ void resultSelectorThrows() 
+ void dispose() 
+ void take() 
+ void rightClose() 
+ void resultSelectorThrows2() 
+ void badOuterSource() 
+ Integer apply(Integer a, Integer b) 
+ void badEndSource() 
# void subscribeActual(Observer<? super Integer> observer) 
 
}
class io.reactivex.internal.operators.observable.ObservableJust {
 # void subscribeActual(Observer<? super T> s) 
+ T call() 
    - final T value;
 
}
class io.reactivex.internal.operators.observable.ObservableLastMaybe {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableLastSingle {
 # void subscribeActual(SingleObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
~    final T defaultItem;
~        final T defaultItem;
 
}
class io.reactivex.internal.operators.observable.ObservableLastTest {
 + void testLastWithElements() 
+ void testLastWithNoElements() 
+ void testLastMultiSubscribe() 
+ void testLastViaObservable() 
+ void testLast() 
+ void testLastWithOneElement() 
+ void testLastWithEmpty() 
+ void testLastWithPredicate() 
+ void testLastWithPredicateAndOneElement() 
+ void testLastWithPredicateAndEmpty() 
+ void testLastOrDefault() 
+ void testLastOrDefaultWithOneElement() 
+ void testLastOrDefaultWithEmpty() 
+ void testLastOrDefaultWithPredicate() 
+ void testLastOrDefaultWithPredicateAndOneElement() 
+ void testLastOrDefaultWithPredicateAndEmpty() 
+ void lastOrErrorNoElement() 
+ void lastOrErrorOneElement() 
+ void lastOrErrorMultipleElements() 
+ void lastOrErrorError() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ ObservableSource<Object> apply(Observable<Object> o) 
+ SingleSource<Object> apply(Observable<Object> o) 
+ void error() 
+ void errorLastOrErrorObservable() 
+ void emptyLastOrErrorObservable() 
 
}
class io.reactivex.internal.operators.observable.ObservableLift {
 + void subscribeActual(Observer<? super R> s) 
 
}
class io.reactivex.internal.operators.observable.ObservableLiftTest {
 + void callbackCrash() 
 
}
class io.reactivex.internal.operators.observable.ObservableMap {
 + void subscribeActual(Observer<? super U> t) 
+ void onNext(T t) 
+ int requestFusion(int mode) 
+ U poll() 
 
}
class io.reactivex.internal.operators.observable.ObservableMapNotification {
 + void subscribeActual(Observer<? super ObservableSource<? extends R>> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableMapNotification.MapNotificationObserver
class io.reactivex.internal.operators.observable.ObservableMapNotificationTest {
 + void testJust() 
+ Observable<Object> apply(Throwable e) 
+ Observable<Object> call() 
+ void dispose() 
# void subscribeActual(Observer<? super Integer> observer) 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.observable.ObservableMapTest {
 + String apply(String value, Integer index) 
+ void before() 
+ void testMap() 
+ void testMapMany() 
+ String apply(Map<String, String> map) 
+ void testMapMany2() 
+ void testMapWithError() 
+ void accept(Throwable t1) 
+ void testMapWithIssue417() 
+ void testMapWithErrorInFuncAndThreadPoolScheduler() 
+ void testErrorPassesThruMap() 
+ void testErrorPassesThruMap2() 
+ void testMapWithErrorInFunc() 
+ void verifyExceptionIsThrownIfThereIsNoExceptionHandler() 
+ Observable<Object> apply(Object object) 
+ Object apply(Object object) 
+ void accept(Object object) 
+ void testShouldNotSwallowOnErrorNotImplementedException() 
+ Observable<String> apply(String s) 
+ void accept(String s) 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void fusedSync() 
+ void fusedAsync() 
+ void fusedReject() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.observable.ObservableMaterialize {
 + void subscribeActual(Observer<? super Notification<T>> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableMaterializeTest {
 + void testMaterialize1() 
+ void testMaterialize2() 
+ void testMultipleSubscribes() 
+ void testWithCompletionCausingError() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Notification<String> value) 
+ void subscribe(final Observer<? super String> observer) 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.observable.ObservableMergeDelayErrorTest {
 + void before() 
+ void testErrorDelayed1() 
+ void testErrorDelayed2() 
+ void testErrorDelayed3() 
+ void testErrorDelayed4() 
+ void testErrorDelayed4WithThreading() 
+ void testCompositeErrorDelayed1() 
+ void testCompositeErrorDelayed2() 
+ void testMergeObservableOfObservables() 
+ void testMergeArray() 
+ void testMergeList() 
+ void testMergeArrayWithThreading() 
+ void testSynchronousError() 
+ void onError(Throwable e) 
+ void onNext(String s) 
+ void subscribe(Observer<? super String> observer) 
+ void subscribe(final Observer<? super String> observer) 
+ void onComplete() 
+ void onNext(String args) 
+ void testMergeSourceWhichDoesntPropagateExceptionBack() 
+ void onNext(Integer t) 
+ void testErrorInParentObservable() 
+ void testErrorInParentObservableDelayed() 
+ void mergeIterableDelayError() 
+ void mergeArrayDelayError() 
+ void mergeIterableDelayErrorWithError() 
+ void mergeDelayError() 
+ void mergeDelayErrorWithError() 
+ void mergeDelayErrorMaxConcurrency() 
+ void mergeDelayErrorWithErrorMaxConcurrency() 
+ void mergeIterableDelayErrorMaxConcurrency() 
+ void mergeIterableDelayErrorWithErrorMaxConcurrency() 
+ void mergeDelayError3() 
+ void mergeDelayError3WithError() 
 
}
class io.reactivex.internal.operators.observable.ObservableMergeMaxConcurrentTest {
 + void before() 
+ void testWhenMaxConcurrentIsOne() 
+ void testMaxConcurrent() 
+ void subscribe(final Observer<? super String> t1) 
+ void testMergeALotOfSourcesOneByOneSynchronously() 
+ void testMergeALotOfSourcesOneByOneSynchronouslyTakeHalf() 
+ void testSimple() 
+ void testSimpleOneLess() 
+ void testSimpleAsyncLoop() 
+ void testSimpleAsync() 
+ void testSimpleOneLessAsyncLoop() 
+ void testSimpleOneLessAsync() 
+ void testTake() 
        - final AtomicInteger subscriptionCount;
        - final int maxConcurrent;
 
}
class io.reactivex.internal.operators.observable.ObservableMergeTest {
 + void before() 
+ void after() 
+ void testMergeObservableOfObservables() 
+ void testMergeArray() 
+ void testMergeList() 
+ void testUnSubscribeObservableOfObservables() 
+ void run() 
+ void accept(Long v) 
+ void testMergeArrayWithThreading() 
+ void testSynchronizationOfMultipleSequencesLoop() 
+ void testSynchronizationOfMultipleSequences() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void testError1() 
+ void testError2() 
+ void testThrownErrorHandling() 
+ void subscribe(Observer<? super String> observer) 
+ void subscribe(final Observer<? super String> observer) 
+ void testUnsubscribeAsObservablesComplete() 
+ void testEarlyUnsubscribe() 
- Observable<Long> createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(final Scheduler scheduler, final AtomicBoolean unsubscribed) 
+ void onNext(Long t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void testConcurrency() 
+ void testConcurrencyWithSleeping() 
+ void testConcurrencyWithBrokenOnCompleteContract() 
+ void testBackpressureUpstream() 
+ void testBackpressureUpstream2InLoop() 
+ void testBackpressureUpstream2() 
+ void testBackpressureDownstreamWithConcurrentStreams() 
+ void testBackpressureBothUpstreamAndDownstreamWithRegularObservables() 
+ void onNext(Integer t) 
+ void mergeWithNullValues() 
+ void mergeWithTerminalEventAfterUnsubscribe() 
+ void mergingNullObservable() 
+ void merge1AsyncStreamOf1() 
+ void merge1AsyncStreamOf1000() 
+ void merge10AsyncStreamOf1000() 
+ void merge1000AsyncStreamOf1000() 
+ void merge2000AsyncStreamOf100() 
+ void merge100AsyncStreamOf1() 
- Observable<Integer> mergeNAsyncStreamsOfN(final int outerSize, final int innerSize) 
+ void merge1SyncStreamOf1() 
+ void merge1SyncStreamOf1000000() 
+ void merge1000SyncStreamOf1000() 
+ void merge10000SyncStreamOf10() 
+ void merge1000000SyncStreamOf1() 
- Observable<Integer> mergeNSyncStreamsOfN(final int outerSize, final int innerSize) 
- Observable<Integer> createInfiniteObservable(final AtomicInteger generated) 
+ Integer next() 
+ boolean hasNext() 
+ void mergeManyAsyncSingle() 
+ Observable<Integer> apply(Integer v) 
+ Observable<Integer> apply(Integer t) 
+ void testFastMergeFullScalar() 
+ void testFastMergeHiddenScalar() 
+ void testSlowMergeFullScalar() 
+ void testSlowMergeHiddenScalar() 
+ void mergeArray() 
+ void mergeErrors() 
 
}
class io.reactivex.internal.operators.observable.ObservableMulticastTest {
 + void testMulticast() 
+ void testMulticastConnectTwice() 
+ void testMulticastDisconnect() 
 
}
class io.reactivex.internal.operators.observable.ObservableNever {
 # void subscribeActual(Observer<? super Object> o) 
 
}
class io.reactivex.internal.operators.observable.ObservableObserveOn {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ int requestFusion(int mode) 
+ T poll() 
+ void clear() 
+ boolean isEmpty() 
~    final Scheduler scheduler;
~    final boolean delayError;
~    final int bufferSize;
~        final boolean delayError;
~        final int bufferSize;
 
}
class io.reactivex.internal.operators.observable.ObservableObserveOn.ObserveOnObserver
class io.reactivex.internal.operators.observable.ObservableObserveOnTest {
 + void testObserveOn() 
+ void testOrdering() 
+ void testThreadName() 
+ void accept(String t1) 
+ void run() 
+ void observeOnTheSameSchedulerTwice() 
+ void observeSameOnMultipleSchedulers() 
+ void testObserveOnWithNewThreadScheduler() 
+ void accept(Integer t1) 
+ void testObserveOnWithThreadPoolScheduler() 
+ void testObserveOnOrderingConcurrency() 
+ void testNonBlockingOuterWhileBlockingOnNext() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
- {static} int randomIntFrom0to100() 
+ void testDelayedErrorDeliveryWhenSafeSubscriberUnsubscribes() 
+ void testAfterUnsubscribeCalledThenObserverOnNextNeverCalled() 
+ void testBackpressureWithTakeBefore() 
+ Integer next() 
+ boolean hasNext() 
+ void testAsyncChild() 
+ void delayError() 
+ void trampolineScheduler() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
+ void inputSyncFused() 
+ void inputAsyncFused() 
+ void inputAsyncFusedError() 
+ void inputAsyncFusedErrorDelayed() 
+ void outputFused() 
+ void outputFusedReject() 
+ void inputOutputAsyncFusedError() 
+ void inputOutputAsyncFusedErrorDelayed() 
+ void outputFusedCancelReentrant() 
+ void onNext(Integer value) 
+ void onComplete() 
+ void nonFusedPollThrows() 
+ boolean offer(Integer v1, Integer v2) 
+ Integer poll() 
+ boolean isEmpty() 
+ void clear() 
 
}
class io.reactivex.internal.operators.observable.ObservableOnErrorNext {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final boolean allowFatal;
~        final boolean allowFatal;
~        final SequentialDisposable arbiter;
 
}
class io.reactivex.internal.operators.observable.ObservableOnErrorResumeNextViaFunctionTest {
 + void testResumeNextWithSynchronousExecution() 
+ Observable<String> apply(Throwable t1) 
+ void testResumeNextWithAsyncExecution() 
+ void testFunctionThrowsError() 
+ void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperator() 
+ void testOnErrorResumeReceivesErrorFromPreviousNonProtectedOperatorOnNext() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testMapResumeAsyncNext() 
+ void subscribe(final Observer<? super String> observer) 
+ void testBackpressure() 
+ Integer apply(Integer t1) 
+ void badOtherSource() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.observable.ObservableOnErrorResumeNextViaObservableTest {
 + void testResumeNext() 
+ void testMapResumeAsyncNext() 
+ void testResumeNextWithFailureOnSubscribe() 
+ void testResumeNextWithFailureOnSubscribeAsync() 
+ void subscribe(final Observer<? super String> observer) 
+ void testBackpressure() 
~        final Disposable s;
~        final String[] values;
 
}
class io.reactivex.internal.operators.observable.ObservableOnErrorReturn {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableOnErrorReturnTest {
 + void testResumeNext() 
+ void testFunctionThrowsError() 
+ void testMapResumeAsyncNext() 
+ String apply(Throwable t1) 
+ void testBackpressure() 
+ Integer apply(Integer t1) 
+ void subscribe(final Observer<? super String> observer) 
+ void returnItem() 
+ void dispose() 
+ void doubleOnSubscribe() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.observable.ObservableOnExceptionResumeNextViaObservableTest {
 + void testResumeNextWithException() 
+ void testResumeNextWithRuntimeException() 
+ void testThrowablePassesThru() 
+ void testErrorPassesThru() 
+ void testMapResumeAsyncNext() 
+ void testBackpressure() 
+ void subscribe(final Observer<? super String> observer) 
~        final String[] values;
 
}
class io.reactivex.internal.operators.observable.ObservablePublish {
 + ObservableSource<T> source() 
# void subscribeActual(Observer<? super T> observer) 
+ void connect(Consumer<? super Disposable> connection) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void subscribe(Observer<? super T> child) 
~    final ObservableSource<T> source;
~    final AtomicReference<PublishObserver<T>> current;
~    final ObservableSource<T> onSubscribe;
~        final AtomicReference<PublishObserver<T>> current;
~        final AtomicReference<InnerDisposable<T>[]> observers;
~        final AtomicBoolean shouldConnect;
        - final AtomicReference<PublishObserver<T>> curr;
 
}
class io.reactivex.internal.operators.observable.ObservablePublishSelector {
 # void subscribeActual(Observer<? super R> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onNext(R value) 
+ void dispose() 
+ boolean isDisposed() 
~        final PublishSubject<T> subject;
~        final AtomicReference<Disposable> target;
 
}
class io.reactivex.internal.operators.observable.ObservablePublishTest {
 + void testPublish() 
+ void accept(String v) 
+ void testBackpressureFastSlow() 
+ Integer apply(Integer i) 
+ void run() 
+ void testTakeUntilWithPublishedStreamUsingSelector() 
+ Observable<Integer> apply(Observable<Integer> xs) 
+ void testTakeUntilWithPublishedStream() 
+ void testBackpressureTwoConsumers() 
+ void onNext(Integer t) 
+ void testConnectWithNoSubscriber() 
+ void testSubscribeAfterDisconnectThenConnect() 
+ void testNoSubscriberRetentionOnCompleted() 
+ void testNonNullConnection() 
+ void testNoDisconnectSomeoneElse() 
~{static} boolean checkPublishDisposed(Disposable d) 
+ void testConnectIsIdempotent() 
+ void testObserveOn() 
+ void preNextConnect() 
+ void connectRace() 
+ void selectorCrash() 
+ void source() 
+ void connectThrows() 
+ void addRemoveRace() 
+ void disposeOnArrival() 
+ void dispose() 
+ void empty() 
+ void take() 
+ void just() 
+ void nextCancelRace() 
+ void badSource() 
+ void noErrorLoss() 
+ void subscribeDisconnectRace() 
+ void selectorDisconnectsIndependentSource() 
+ void selectorLatecommer() 
+ void mainError() 
+ void selectorInnerError() 
+ void delayedUpstreamOnSubscribe() 
# void subscribeActual(Observer<? super Integer> s) 
 
}
class io.reactivex.internal.operators.observable.ObservableRange {
 # void subscribeActual(Observer<? super Integer> o) 
+ Integer poll() 
+ boolean isEmpty() 
+ void clear() 
+ void dispose() 
+ boolean isDisposed() 
+ int requestFusion(int mode) 
    - final int start;
    - final long end;
~        final long end;
 
}
class io.reactivex.internal.operators.observable.ObservableRangeLong {
 # void subscribeActual(Observer<? super Long> o) 
+ Long poll() 
+ boolean isEmpty() 
+ void clear() 
+ void dispose() 
+ boolean isDisposed() 
+ int requestFusion(int mode) 
    - final long start;
    - final long count;
~        final long end;
 
}
class io.reactivex.internal.operators.observable.ObservableRangeLongTest {
 + void testRangeStartAt2Count3() 
+ void testRangeUnsubscribe() 
+ void testRangeWithZero() 
+ void testRangeWithOverflow2() 
+ void testRangeWithOverflow3() 
+ void testRangeWithOverflow4() 
+ void testRangeWithOverflow5() 
+ void testNoBackpressure() 
+ void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long t) 
+ void testNearMaxValueWithoutBackpressure() 
+ void negativeCount() 
+ void countOne() 
+ void noOverflow() 
+ void fused() 
+ void fusedReject() 
+ void disposed() 
+ void fusedClearIsEmpty() 
 
}
class io.reactivex.internal.operators.observable.ObservableRangeTest {
 + void testRangeStartAt2Count3() 
+ void testRangeUnsubscribe() 
+ void testRangeWithZero() 
+ void testRangeWithOverflow2() 
+ void testRangeWithOverflow3() 
+ void testRangeWithOverflow4() 
+ void testRangeWithOverflow5() 
+ void testNoBackpressure() 
+ void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testNearMaxValueWithoutBackpressure() 
+ void negativeCount() 
+ void requestWrongFusion() 
 
}
class io.reactivex.internal.operators.observable.ObservableRedoTest {
 + void redoCancel() 
+ void managerThrows() 
 
}
class io.reactivex.internal.operators.observable.ObservableReduceMaybe {
 # void subscribeActual(MaybeObserver<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableReduceSeedSingle {
 # void subscribeActual(SingleObserver<? super R> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final ObservableSource<T> source;
~    final R seed;
 
}
class io.reactivex.internal.operators.observable.ObservableReduceSeedSingle.ReduceSeedObserver
class io.reactivex.internal.operators.observable.ObservableReduceTest {
 + void before() 
+ Integer apply(Integer t1, Integer t2) 
+ void testAggregateAsIntSumObservable() 
+ void testAggregateAsIntSumSourceThrowsObservable() 
+ void testAggregateAsIntSumAccumulatorThrowsObservable() 
+ Integer apply(Integer v) 
+ void testAggregateAsIntSumResultSelectorThrowsObservable() 
+ void testBackpressureWithNoInitialValueObservable() 
+ void testBackpressureWithInitialValueObservable() 
+ void testAggregateAsIntSum() 
+ void testAggregateAsIntSumSourceThrows() 
+ void testAggregateAsIntSumAccumulatorThrows() 
+ void testAggregateAsIntSumResultSelectorThrows() 
+ void testBackpressureWithNoInitialValue() 
+ void testBackpressureWithInitialValue() 
 
}
class io.reactivex.internal.operators.observable.ObservableReduceWithSingle {
 # void subscribeActual(SingleObserver<? super R> observer) 
~    final ObservableSource<T> source;
~    final Callable<R> seedSupplier;
 
}
class io.reactivex.internal.operators.observable.ObservableRefCount {
 + void subscribeActual(final Observer<? super T> subscriber) 
- Consumer<Disposable> onSubscribe(final Observer<? super T> observer,
            final AtomicBoolean writeLocked) 
- Disposable disconnect(final CompositeDisposable current) 
+ void onSubscribe(Disposable s) 
+ void onError(Throwable e) 
+ void onNext(T t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void accept(Disposable subscription) 
+ void run() 
~        final CompositeDisposable currentBase;
~        final Disposable resource;
        - final AtomicBoolean writeLocked;
        - final CompositeDisposable current;
 
}
class io.reactivex.internal.operators.observable.ObservableRefCountTest {
 + void testRefCountAsync() 
+ void accept(Long l) 
+ void testRefCountSynchronous() 
+ void accept(Integer l) 
+ void testRefCountSynchronousTake() 
+ void testRepeat() 
+ void run() 
+ void testConnectUnsubscribe() 
+ void testConnectUnsubscribeRaceConditionLoop() 
+ void testConnectUnsubscribeRaceCondition() 
+ void accept(Disposable s) 
- Observable<Long> synchronousInterval() 
+ void onlyFirstShouldSubscribeAndLastUnsubscribe() 
+ void testRefCount() 
+ void accept(Long t1) 
+ void testAlreadyUnsubscribedClient() 
+ void testAlreadyUnsubscribedInterleavesWithClient() 
+ void testConnectDisconnectConnectAndSubjectState() 
+ void testUpstreamErrorAllowsRetry() 
+ Observable<String> apply(Long t1) 
+ Observable<String> apply(Throwable t1) 
+ void accept(Throwable t1) 
+ void accept(String t1) 
+ void onSubscribe(Disposable d) 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void disposed() 
+ void noOpConnect() 
+ void connect(Consumer<? super Disposable> connection) 
# void subscribeActual(Observer<? super Integer> observer) 
+ void replayNoLeak() 
+ void replayNoLeak2() 
+ void publishNoLeak() 
+ void publishNoLeak2() 
+ void replayIsUnsubscribed() 
        + final Object data;
 
}
class io.reactivex.internal.operators.observable.ObservableRepeat {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final long count;
~        final SequentialDisposable sd;
 
}
class io.reactivex.internal.operators.observable.ObservableRepeatTest {
 + void testRepetition() 
+ void testRepeatTake() 
+ void testNoStackOverFlow() 
+ void testRepeatTakeWithSubscribeOn() 
+ Integer apply(Integer t1) 
+ void testRepeatAndTake() 
+ void testRepeatLimited() 
+ void testRepeatError() 
+ void testRepeatZero() 
+ void testRepeatOne() 
+ void testRepeatAndDistinctUnbounded() 
+ void testRepeatRetarget() 
+ void repeatUntil() 
+ void repeatLongPredicateInvalid() 
+ void repeatUntilError() 
+ void repeatUntilFalse() 
+ void repeatUntilSupplierCrash() 
+ void shouldDisposeInnerObservable() 
+ void testRepeatWhen() 
+ void whenTake() 
+ void handlerError() 
 
}
class io.reactivex.internal.operators.observable.ObservableRepeatUntil {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final BooleanSupplier until;
~        final SequentialDisposable sd;
~        final BooleanSupplier stop;
 
}
class io.reactivex.internal.operators.observable.ObservableRepeatWhen {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
+ void onNext(Object t) 
~        final AtomicInteger wip;
~        final AtomicThrowable error;
~        final Subject<Object> signaller;
~        final InnerRepeatObserver inner;
~        final AtomicReference<Disposable> d;
~        final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableReplay {
 + ObservableSource<T> source() 
+ void dispose() 
+ boolean isDisposed() 
# void subscribeActual(Observer<? super T> observer) 
+ void connect(Consumer<? super Disposable> connection) 
+ void onSubscribe(Disposable p) 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void next(T value) 
+ void error(Throwable e) 
+ void complete() 
+ void replay(InnerDisposable<T> output) 
~final void addLast(Node n) 
~final void removeFirst() 
~final void removeSome(int n) 
~final void setFirst(Node n) 
+ final void next(T value) 
+ final void error(Throwable e) 
+ final void complete() 
+ final void replay(InnerDisposable<T> output) 
~{abstract} void truncate()
+ ReplayBuffer<Object> call() 
+ void accept(Disposable r) 
+ ReplayBuffer<T> call() 
+ void subscribe(Observer<? super T> child) 
# void subscribeActual(Observer<? super R> child) 
~    final ObservableSource<T> source;
~    final AtomicReference<ReplayObserver<T>> current;
~    final BufferSupplier<T> bufferFactory;
~    final ObservableSource<T> onSubscribe;
~        final ReplayBuffer<T> buffer;
~        final AtomicReference<InnerDisposable[]> observers;
~        final AtomicBoolean shouldConnect;
~        final ReplayObserver<T> parent;
~        final Object value;
~        final int limit;
~        final Scheduler scheduler;
~        final long maxAge;
~        final TimeUnit unit;
        - final ObserverResourceWrapper<R> srw;
        - final int bufferSize;
        - final long maxAge;
        - final TimeUnit unit;
        - final Scheduler scheduler;
        - final AtomicReference<ReplayObserver<T>> curr;
        - final BufferSupplier<T> bufferFactory;
        - final ConnectableObservable<T> co;
        - final Observable<T> observable;
 
}
class io.reactivex.internal.operators.observable.ObservableReplayTest {
 + void testBufferedReplay() 
+ void testBufferedWindowReplay() 
+ void testWindowedReplay() 
+ void testReplaySelector() 
+ Observable<Integer> apply(Observable<Integer> t1) 
+ void testBufferedReplaySelector() 
+ void testWindowedReplaySelector() 
+ void testBufferedReplayError() 
+ void testWindowedReplayError() 
+ void testSynchronousDisconnect() 
+ Observable<Integer> apply(Observable<Integer> o) 
+ void accept(Integer t1) 
+ void accept(Throwable t1) 
+ void run() 
+ void testIssue2191_UnsubscribeSource() 
+ void testIssue2191_SchedulerUnsubscribe() 
+ void testIssue2191_SchedulerUnsubscribeOnError() 
- {static} void verifyObserverMock(Observer<Integer> mock, int numSubscriptions, int numItemsExpected) 
- {static} void verifyObserver(Observer<Integer> mock, int numSubscriptions, int numItemsExpected, Throwable error) 
+ {static} Worker workerSpy(final Disposable mockDisposable) 
+ Disposable schedule(@NonNull Runnable action) 
+ Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) 
+ void dispose() 
+ boolean isDisposed() 
+ void testBoundedReplayBuffer() 
+ void testTimedAndSizedTruncation() 
+ void testTimedAndSizedTruncationError() 
+ void testSizedTruncation() 
+ void testColdReplayNoBackpressure() 
+ void testCache() 
+ void accept(String v) 
+ void testUnsubscribeSource() 
+ void testTake() 
+ void testAsync() 
+ void testAsyncComeAndGo() 
+ void testNoMissingBackpressureException() 
+ void testValuesAndThenError() 
+ void unsafeChildThrows() 
+ void onNext(Integer t) 
+ void replayScheduler() 
+ void replayTime() 
+ void replaySizeScheduler() 
+ void replaySizeAndTime() 
+ void replaySelectorSizeScheduler() 
+ void replaySelectorScheduler() 
+ void replaySelectorTime() 
+ void replayMaxInt() 
+ void source() 
+ void connectRace() 
+ void subscribeRace() 
+ void addRemoveRace() 
+ void cancelOnArrival() 
+ void cancelOnArrival2() 
+ void connectConsumerThrows() 
+ void badSource() 
+ void subscribeOnNextRace() 
+ void unsubscribeOnNextRace() 
+ void unsubscribeReplayRace() 
+ void reentrantOnNext() 
+ void reentrantOnNextBound() 
+ void reentrantOnNextCancel() 
+ void reentrantOnNextCancelBounded() 
+ void delayedUpstreamOnSubscribe() 
# void subscribeActual(Observer<? super Integer> s) 
+ void timedNoOutdatedData() 
        - final Disposable mockDisposable;
        + boolean unsubscribed;
 
}
class io.reactivex.internal.operators.observable.ObservableResourceWrapperTest {
 + void disposed() 
+ void doubleOnSubscribe() 
+ void onErrorDisposes() 
 
}
class io.reactivex.internal.operators.observable.ObservableRetryBiPredicate {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final SequentialDisposable sa;
 
}
class io.reactivex.internal.operators.observable.ObservableRetryPredicate {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final long count;
~        final SequentialDisposable sa;
 
}
class io.reactivex.internal.operators.observable.ObservableRetryTest {
 + void iterativeBackoff() 
+ Observable<Object> apply(Observable<? extends Throwable> attempts) 
+ Tuple apply(Tuple t, Tuple n) 
+ Observable<Long> apply(Tuple t) 
+ void testRetryIndefinitely() 
+ void testSchedulingNotificationHandler() 
+ void accept(Throwable e) 
+ void testOnNextFromNotificationHandler() 
+ void testOnCompletedFromNotificationHandler() 
+ void testOnErrorFromNotificationHandler() 
+ void testSingleSubscriptionOnFirst() 
+ Void apply(Throwable o, Integer integer) 
+ void testOriginFails() 
+ void testRetryFail() 
+ void testRetrySuccess() 
+ void testInfiniteRetry() 
+ void testRetrySubscribesAgainAfterError() 
+ void subscribe(final Observer<? super String> o) 
+ void testUnsubscribeFromRetry() 
+ void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubscribed() 
+ void testSourceObservableCallsUnsubscribe() 
+ void testSourceObservableRetry1() 
+ void testSourceObservableRetry0() 
+ void subscribe(final Observer<? super Long> observer) 
+ void run() 
+ void await() 
+ void onComplete() 
+ void onError(Throwable t) 
+ void onNext(T v) 
+ void testUnsubscribeAfterError() 
+ void testTimeoutWithRetry() 
+ void testRetryWithBackpressure() 
+ void testRetryWithBackpressureParallel() 
+ void testIssue1900() 
+ String apply(String t1) 
+ Observable<String> apply(GroupedObservable<String, String> t1) 
+ void testIssue1900SourceNotSupportingBackpressure() 
+ void retryPredicate() 
+ void retryUntil() 
+ void retryLongPredicateInvalid() 
+ void shouldDisposeInnerObservable() 
        - final int numFailures;
~        final AtomicInteger nextBeforeFailure;
        - final int emitDelay;
        # Observer<T> target;
 
}
class io.reactivex.internal.operators.observable.ObservableRetryWhen {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
+ void onNext(Object t) 
~        final AtomicInteger wip;
~        final AtomicThrowable error;
~        final Subject<Throwable> signaller;
~        final InnerRepeatObserver inner;
~        final AtomicReference<Disposable> d;
~        final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableRetryWithPredicateTest {
 + boolean test(Integer t1, Throwable t2) 
+ void testWithNothingToRetry() 
+ void testRetryTwice() 
+ void testRetryTwiceAndGiveUp() 
+ void testRetryOnSpecificException() 
+ void testRetryOnSpecificExceptionAndNotOther() 
+ void testUnsubscribeFromRetry() 
+ void testUnsubscribeAfterError() 
+ void testTimeoutWithRetry() 
+ void testIssue2826() 
+ void testJustAndRetry() 
+ void testIssue3008RetryWithPredicate() 
+ void accept(Long t) 
+ void testIssue3008RetryInfinite() 
+ void predicateThrows() 
+ void dontRetry() 
+ void retryDisposeRace() 
+ void run() 
+ void bipredicateThrows() 
+ void retryBiPredicateDisposeRace() 
 
}
class io.reactivex.internal.operators.observable.ObservableSampleTest {
 + void before() 
+ void testSample() 
+ void run() 
+ void sampleWithSamplerNormal() 
+ void sampleWithSamplerNoDuplicates() 
+ void sampleWithSamplerTerminatingEarly() 
+ void sampleWithSamplerEmitAndTerminate() 
+ void sampleWithSamplerEmptySource() 
+ void sampleWithSamplerSourceThrows() 
+ void sampleWithSamplerThrows() 
+ void testSampleUnsubscribe() 
+ void dispose() 
+ void error() 
+ void emitLastTimed() 
+ void emitLastTimedEmpty() 
+ void emitLastTimedCustomScheduler() 
+ void emitLastTimedRunCompleteRace() 
+ void emitLastOther() 
+ void emitLastOtherEmpty() 
+ void emitLastOtherRunCompleteRace() 
+ void emitLastOtherCompleteCompleteRace() 
    - TestScheduler scheduler;
    - Observer<Long> observer;
    - Observer<Object> observer2;
 
}
class io.reactivex.internal.operators.observable.ObservableSampleTimed {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~{abstract} void complete()
+ void run() 
~    final long period;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final boolean emitLast;
~        final long period;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.observable.ObservableSampleWithObservable {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void error(Throwable e) 
+ void complete() 
~{abstract} void completeMain()
+ void onNext(Object t) 
~    final boolean emitLast;
~        final SampleMainObserver<T> parent;
~        final AtomicInteger wip;
 
}
class io.reactivex.internal.operators.observable.ObservableScalarXMap {
 + void subscribeActual(Observer<? super R> s) 
+ boolean offer(T value) 
+ boolean offer(T v1, T v2) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ void dispose() 
+ boolean isDisposed() 
+ int requestFusion(int mode) 
+ void run() 
~        final T value;
 
}
class io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarDisposable
class io.reactivex.internal.operators.observable.ObservableScalarXMapTest {
 + void utilityClass() 
+ void subscribe(Observer<? super Integer> s) 
+ Integer call() 
+ void tryScalarXMap() 
+ void emptyXMap() 
+ void mapperCrashes() 
+ void mapperToJust() 
+ void mapperToEmpty() 
+ void mapperToCrashingCallable() 
+ void scalarMapToEmpty() 
+ void scalarMapToCrashingCallable() 
+ void scalarDisposableStateCheck() 
+ void scalarDisposableRunDisposeRace() 
+ void run() 
 
}
class io.reactivex.internal.operators.observable.ObservableScan {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableScanSeed {
 + void subscribeActual(Observer<? super R> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Callable<R> seedSupplier;
 
}
class io.reactivex.internal.operators.observable.ObservableScanTest {
 + void testScanIntegersWithInitialValue() 
+ void testScanIntegersWithoutInitialValue() 
+ void testScanIntegersWithoutInitialValueAndOnlyOneValue() 
+ void shouldNotEmitUntilAfterSubscription() 
+ boolean test(Integer t1) 
+ void testNoBackpressureWithInitialValue() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testSeedFactory() 
+ void accept(List<Integer> list, Integer t2) 
+ void testScanWithRequestOne() 
+ void testInitialValueEmittedNoProducer() 
+ void dispose() 
+ Integer apply(Integer a, Integer b) 
+ void doubleOnSubscribe() 
+ ObservableSource<Object> apply(Observable<Object> o) 
+ void error() 
+ void badSource() 
+ void testScanFunctionThrowsAndUpstreamErrorsDoesNotResultInTwoTerminalEvents() 
+ void subscribe(Observer<? super Integer> o) 
+ Integer apply(Integer t1, Integer t2) 
+ void testScanFunctionThrowsAndUpstreamCompletesDoesNotResultInTwoTerminalEvents() 
+ void testScanFunctionThrowsAndUpstreamEmitsOnNextResultsInScanFunctionBeingCalledOnlyOnce() 
 
}
class io.reactivex.internal.operators.observable.ObservableSequenceEqual {
 + void subscribeActual(Observer<? super Boolean> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int bufferSize;
~        final ArrayCompositeDisposable resources;
~        final EqualObserver<T>[] observers;
~        final EqualCoordinator<T> parent;
~        final SpscLinkedArrayQueue<T> queue;
~        final int index;
 
}
class io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle {
 + void subscribeActual(SingleObserver<? super Boolean> s) 
+ Observable<Boolean> fuseToObservable() 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int bufferSize;
~        final ArrayCompositeDisposable resources;
~        final EqualObserver<T>[] observers;
~        final EqualCoordinator<T> parent;
~        final SpscLinkedArrayQueue<T> queue;
~        final int index;
 
}
class io.reactivex.internal.operators.observable.ObservableSequenceEqualTest {
 + void test1Observable() 
+ void test2Observable() 
+ void test3Observable() 
+ void testWithError1Observable() 
+ void testWithError2Observable() 
+ void testWithError3Observable() 
+ void testWithEmpty1Observable() 
+ void testWithEmpty2Observable() 
+ void testWithEmpty3Observable() 
+ void testWithNull1Observable() 
+ void testWithNull2Observable() 
+ void testWithEqualityErrorObservable() 
- void verifyResult(Single<Boolean> o, boolean result) 
- void verifyError(Observable<Boolean> observable) 
- void verifyError(Single<Boolean> observable) 
+ void prefetchObservable() 
+ void disposedObservable() 
+ void test1() 
+ void test2() 
+ void test3() 
+ void testWithError1() 
+ void testWithError2() 
+ void testWithError3() 
+ void testWithEmpty1() 
+ void testWithEmpty2() 
+ void testWithEmpty3() 
+ void testWithNull1() 
+ void testWithNull2() 
+ void testWithEqualityError() 
- void verifyResult(Observable<Boolean> o, boolean result) 
+ void prefetch() 
+ void disposed() 
+ void simpleInequal() 
+ void simpleInequalObservable() 
+ void onNextCancelRace() 
+ void run() 
+ void onNextCancelRaceObservable() 
 
}
class io.reactivex.internal.operators.observable.ObservableSerializeTest {
 + void before() 
+ void testSingleThreadedBasic() 
+ void testMultiThreadedBasic() 
+ void testMultiThreadedWithNPE() 
+ void testMultiThreadedWithNPEinMiddle() 
+ void run() 
+ void subscribe(final Observer<? super String> observer) 
+ void waitToFinish() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(String args) 
        - final DefaultObserver<String> observer;
        - final int numStringsToSend;
        - final TestConcurrencyobserverEvent event;
~        final String[] values;
        - Thread t;
 
}
class io.reactivex.internal.operators.observable.ObservableSerialized {
 # void subscribeActual(Observer<? super T> observer) 
 
}
class io.reactivex.internal.operators.observable.ObservableSingleMaybe {
 + void subscribeActual(MaybeObserver<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
 
}
class io.reactivex.internal.operators.observable.ObservableSingleSingle {
 + void subscribeActual(SingleObserver<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final T defaultValue;
~        final T defaultValue;
 
}
class io.reactivex.internal.operators.observable.ObservableSingleTest {
 + void testSingleObservable() 
+ void testSingleWithTooManyElementsObservable() 
+ void testSingleWithEmptyObservable() 
+ void testSingleWithPredicateObservable() 
+ void testSingleWithPredicateAndTooManyElementsObservable() 
+ void testSingleWithPredicateAndEmptyObservable() 
+ void testSingleOrDefaultObservable() 
+ void testSingleOrDefaultWithTooManyElementsObservable() 
+ void testSingleOrDefaultWithEmptyObservable() 
+ void testSingleOrDefaultWithPredicateObservable() 
+ void testSingleOrDefaultWithPredicateAndTooManyElementsObservable() 
+ void testSingleOrDefaultWithPredicateAndEmptyObservable() 
+ void testIssue1527Observable() 
+ void testSingle() 
+ void testSingleWithTooManyElements() 
+ void testSingleWithEmpty() 
+ void testSingleWithPredicate() 
+ void testSingleWithPredicateAndTooManyElements() 
+ void testSingleWithPredicateAndEmpty() 
+ void testSingleOrDefault() 
+ void testSingleOrDefaultWithTooManyElements() 
+ void testSingleOrDefaultWithEmpty() 
+ void testSingleOrDefaultWithPredicate() 
+ void testSingleOrDefaultWithPredicateAndTooManyElements() 
+ void testSingleOrDefaultWithPredicateAndEmpty() 
+ void testIssue1527() 
+ void singleElementOperatorDoNotSwallowExceptionWhenDone() 
+ void subscribe(final Observer<? super Integer> observer) 
+ void singleOrErrorNoElement() 
+ void singleOrErrorOneElement() 
+ void singleOrErrorMultipleElements() 
+ void singleOrErrorError() 
+ void badSource() 
+ Object apply(Observable<Object> o) 
+ void doubleOnSubscribe() 
+ MaybeSource<Object> apply(Observable<Object> o) 
 
}
class io.reactivex.internal.operators.observable.ObservableSkip {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final long n;
 
}
class io.reactivex.internal.operators.observable.ObservableSkipLast {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int skip;
~        final int skip;
 
}
class io.reactivex.internal.operators.observable.ObservableSkipLastTest {
 + void testSkipLastEmpty() 
+ void testSkipLast1() 
+ void testSkipLast2() 
+ void testSkipLastWithZeroCount() 
+ void testSkipLastWithNull() 
+ void testSkipLastWithBackpressure() 
+ void testSkipLastWithNegativeCount() 
+ void dispose() 
+ void error() 
 
}
class io.reactivex.internal.operators.observable.ObservableSkipLastTimed {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final long time;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final int bufferSize;
~    final boolean delayError;
~        final long time;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final SpscLinkedArrayQueue<Object> queue;
~        final boolean delayError;
 
}
class io.reactivex.internal.operators.observable.ObservableSkipLastTimedTest {
 + void testSkipLastTimed() 
+ void testSkipLastTimedErrorBeforeTime() 
+ void testSkipLastTimedCompleteBeforeTime() 
+ void testSkipLastTimedWhenAllElementsAreValid() 
+ void skipLastTimedDefaultScheduler() 
+ void skipLastTimedDefaultSchedulerDelayError() 
+ void skipLastTimedCustomSchedulerDelayError() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void onNextDisposeRace() 
+ void run() 
+ void errorDelayed() 
+ void take() 
 
}
class io.reactivex.internal.operators.observable.ObservableSkipTest {
 + void testSkipNegativeElements() 
+ void testSkipZeroElements() 
+ void testSkipOneElement() 
+ void testSkipTwoElements() 
+ void testSkipEmptyStream() 
+ void testSkipMultipleObservers() 
+ void testSkipError() 
+ void testRequestOverflowDoesNotOccur() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.observable.ObservableSkipTimedTest {
 + void testSkipTimed() 
+ void testSkipTimedFinishBeforeTime() 
+ void testSkipTimedErrorBeforeTime() 
+ void testSkipTimedErrorAfterTime() 
+ void skipTimedDefaultScheduler() 
 
}
class io.reactivex.internal.operators.observable.ObservableSkipUntil {
 + void subscribeActual(Observer<? super T> child) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void onNext(U t) 
~    final ObservableSource<U> other;
~        final ArrayCompositeDisposable frc;
        - final ArrayCompositeDisposable frc;
        - final SkipUntilObserver<T> sus;
        - final SerializedObserver<T> serial;
 
}
class io.reactivex.internal.operators.observable.ObservableSkipUntilTest {
 + void before() 
+ void normal1() 
+ void otherNeverFires() 
+ void otherEmpty() 
+ void otherFiresAndCompletes() 
+ void sourceThrows() 
+ void otherThrowsImmediately() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ ObservableSource<Object> apply(Observable<Object> o) 
 
}
class io.reactivex.internal.operators.observable.ObservableSkipWhile {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableSkipWhileTest {
 + boolean test(Integer v) 
+ boolean test(Integer value) 
+ void testSkipWithIndex() 
+ void testSkipEmpty() 
+ void testSkipEverything() 
+ void testSkipNothing() 
+ void testSkipSome() 
+ void testSkipError() 
+ void testSkipManySubscribers() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
 
}
class io.reactivex.internal.operators.observable.ObservableSubscribeOn {
 + void subscribeActual(final Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final Scheduler scheduler;
~        final AtomicReference<Disposable> s;
        - final SubscribeOnObserver<T> parent;
 
}
class io.reactivex.internal.operators.observable.ObservableSubscribeOnTest {
 + void testIssue813() 
+ void testThrownErrorHandling() 
+ void testOnError() 
+ Worker createWorker() 
+ void dispose() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull final Runnable action) 
+ Disposable schedule(@NonNull final Runnable action, final long delayTime, @NonNull final TimeUnit delayUnit) 
+ void testUnsubscribeInfiniteStream() 
+ void cancelBeforeActualSubscribe() 
~        final Scheduler actual;
~        final long delay;
~        final TimeUnit unit;
 
}
class io.reactivex.internal.operators.observable.ObservableSwitchIfEmpty {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final SequentialDisposable arbiter;
 
}
class io.reactivex.internal.operators.observable.ObservableSwitchIfEmptyTest {
 + void testSwitchWhenNotEmpty() 
+ void testSwitchWhenEmpty() 
+ void testSwitchTriggerUnsubscribe() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Long aLong) 
+ void testSwitchShouldTriggerUnsubscribe() 
 
}
class io.reactivex.internal.operators.observable.ObservableSwitchMap {
 + void subscribeActual(Observer<? super R> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(R t) 
+ void cancel() 
~    final int bufferSize;
~    final boolean delayErrors;
~        final int bufferSize;
~        final boolean delayErrors;
~        final AtomicThrowable errors;
~        final long index;
~        final SpscLinkedArrayQueue<R> queue;
 
}
class io.reactivex.internal.operators.observable.ObservableSwitchTest {
 + void before() 
+ void testSwitchWhenOuterCompleteBeforeInner() 
+ void testSwitchWhenInnerCompleteBeforeOuter() 
+ void subscribe(Observer<? super String> innerObserver) 
+ void testSwitchWithComplete() 
+ void subscribe(final Observer<? super String> innerObserver) 
+ void testSwitchWithError() 
+ void testSwitchWithSubsequenceComplete() 
+ void testSwitchWithSubsequenceError() 
+ void subscribe(Observer<? super String> observer) 
+ void run() 
+ void testSwitchIssue737() 
+ void testUnsubscribe() 
+ void testIssue2654() 
+ void onNext(String t) 
+ void delayErrors() 
+ void switchOnNextDelayError() 
+ void switchOnNextDelayErrorWithError() 
+ void switchOnNextDelayErrorBufferSize() 
+ void switchMapDelayErrorEmptySource() 
+ void switchMapDelayErrorJustSource() 
+ void switchMapErrorEmptySource() 
+ void switchMapJustSource() 
+ void switchMapInnerCancelled() 
+ void switchMapSingleJustSource() 
+ void switchMapSingleMapperReturnsNull() 
+ void switchMapSingleMapperIsNull() 
+ void switchMapSingleFunctionDoesntReturnSingle() 
+ void switchMapSingleDelayErrorJustSource() 
+ void accept(Integer n) 
+ void scalarMap() 
+ void scalarMapDelayError() 
+ void dispose() 
+ void nextSourceErrorRace() 
+ void outerInnerErrorRace() 
+ void nextCancelRace() 
+ void mapperThrows() 
+ void badMainSource() 
+ void emptyInner() 
+ void justInner() 
+ void badInnerSource() 
+ void innerCompletesReentrant() 
+ void innerErrorsReentrant() 
    - TestScheduler scheduler;
    - Observer<String> observer;
 
}
class io.reactivex.internal.operators.observable.ObservableTake {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final long limit;
 
}
class io.reactivex.internal.operators.observable.ObservableTakeLast {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final int count;
~        final int count;
 
}
class io.reactivex.internal.operators.observable.ObservableTakeLastOne {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeLastOneTest {
 + void testLastOfManyReturnsLast() 
+ void testLastOfEmptyReturnsEmpty() 
+ void testLastOfOneReturnsLast() 
+ void testUnsubscribesFromUpstream() 
+ void testTakeLastZeroProcessesAllItemsButIgnoresThem() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeLastTest {
 + void testTakeLastEmpty() 
+ void testTakeLast1() 
+ void testTakeLast2() 
+ void testTakeLastWithZeroCount() 
+ void testTakeLastWithNull() 
+ void testTakeLastWithNegativeCount() 
+ void testBackpressure1() 
+ void testBackpressure2() 
+ Integer apply(Integer i) 
+ void testIssue1522() 
+ void testUnsubscribeTakesEffectEarlyOnFastPath() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer integer) 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
+ void takeLastTake() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeLastTimed {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final long count;
~    final long time;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final int bufferSize;
~    final boolean delayError;
~        final long count;
~        final long time;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final SpscLinkedArrayQueue<Object> queue;
~        final boolean delayError;
 
}
class io.reactivex.internal.operators.observable.ObservableTakeLastTimedTest {
 + void testTakeLastTimedWithNegativeCount() 
+ void takeLastTimed() 
+ void takeLastTimedDelayCompletion() 
+ void takeLastTimedWithCapacity() 
+ void takeLastTimedThrowingSource() 
+ void takeLastTimedWithZeroCapacity() 
+ void takeLastTimeAndSize() 
+ void takeLastTime() 
+ void takeLastTimeDelayError() 
+ void takeLastTimeDelayErrorCustomScheduler() 
+ void disposed() 
+ void observeOn() 
+ void cancelCompleteRace() 
+ void run() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeTest {
 + void testTake1() 
+ void testTake2() 
+ void testTakeWithError() 
+ void testTakeWithErrorHappeningInOnNext() 
+ void testTakeWithErrorHappeningInTheLastOnNext() 
+ void testTakeDoesntLeakErrors() 
+ void testTakeZeroDoesntLeakError() 
+ void testUnsubscribeAfterTake() 
+ void testUnsubscribeFromSynchronousInfiniteObservable() 
+ void testMultiTake() 
+ void accept(Integer t1) 
+ void subscribe(final Observer<? super String> observer) 
+ void subscribe(Observer<? super Long> op) 
+ void testTakeObserveOn() 
+ void testInterrupt() 
+ void takeFinalValueThrows() 
+ void testReentrantTake() 
+ void takeNegative() 
+ void takeZero() 
+ void dispose() 
+ void doubleOnSubscribe() 
~        final String[] values;
 
}
class io.reactivex.internal.operators.observable.ObservableTakeTimedTest {
 + void testTakeTimed() 
+ void testTakeTimedErrorBeforeTime() 
+ void testTakeTimedErrorAfterTime() 
+ void timedDefaultScheduler() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeUntil {
 + void subscribeActual(Observer<? super T> child) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void onNext(U t) 
~        final ArrayCompositeDisposable frc;
        - final ArrayCompositeDisposable frc;
        - final SerializedObserver<T> serial;
 
}
class io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeUntilPredicateTest {
 + void takeEmpty() 
+ void takeAll() 
+ void takeFirst() 
+ void takeSome() 
+ void functionThrows() 
+ void sourceThrows() 
+ void testErrorIncludesLastValueAsCause() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeUntilTest {
 + void testTakeUntil() 
+ void testTakeUntilSourceCompleted() 
+ void testTakeUntilSourceError() 
+ void testTakeUntilOtherError() 
+ void testTakeUntilOtherCompleted() 
+ void sendOnCompleted() 
+ void sendOnNext(String value) 
+ void sendOnError(Throwable e) 
+ void subscribe(Observer<? super String> observer) 
+ void testUntilFires() 
+ void testMainCompletes() 
+ void testDownstreamUnsubscribes() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeWhile {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.observable.ObservableTakeWhileTest {
 + void testTakeWhile1() 
+ void testTakeWhileOnSubject1() 
+ void testTakeWhile2() 
+ void testTakeWhileDoesntLeakErrors() 
+ boolean test(String s) 
+ void testTakeWhileProtectsPredicateCall() 
+ void testUnsubscribeAfterTake() 
+ void subscribe(final Observer<? super String> observer) 
+ void testNoUnsubscribeDownstream() 
+ void testErrorCauseIncludesLastValue() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void badSource() 
~        final Disposable s;
~        final String[] values;
 
}
class io.reactivex.internal.operators.observable.ObservableThrottleFirstTest {
 + void before() 
+ void testThrottlingWithCompleted() 
+ void testThrottlingWithError() 
+ void run() 
+ void testThrottle() 
+ void throttleFirstDefaultScheduler() 
+ void dispose() 
+ void badSource() 
    - TestScheduler scheduler;
    - Observer<String> observer;
 
}
class io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void run() 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long timeout;
~        final TimeUnit unit;
 
}
class io.reactivex.internal.operators.observable.ObservableTimeInterval {
 + void subscribeActual(Observer<? super Timed<T>> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Scheduler scheduler;
~    final TimeUnit unit;
~        final TimeUnit unit;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableTimeIntervalTest {
 + void setUp() 
+ void testTimeInterval() 
+ void timeIntervalDefault() 
+ Long apply(Timed<Integer> v) 
+ void timeIntervalDefaultSchedulerCustomUnit() 
+ void dispose() 
+ void error() 
    - Observer<Timed<Integer>> observer;
    - TestScheduler testScheduler;
    - PublishSubject<Integer> subject;
    - Observable<Timed<Integer>> observable;
 
}
class io.reactivex.internal.operators.observable.ObservableTimeout {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void timeout(long idx) 
+ void innerError(Throwable e) 
+ void onNext(Object t) 
~    final ObservableSource<U> firstTimeoutIndicator;
~        final ObservableSource<U> firstTimeoutIndicator;
~        final OnTimeout parent;
~        final long index;
~        final ObserverFullArbiter<T> arbiter;
 
}
class io.reactivex.internal.operators.observable.ObservableTimeoutTests {
 + void setUp() 
+ void shouldNotTimeoutIfOnNextWithinTimeout() 
+ void shouldNotTimeoutIfSecondOnNextWithinTimeout() 
+ void shouldTimeoutIfOnNextNotWithinTimeout() 
+ void shouldTimeoutIfSecondOnNextNotWithinTimeout() 
+ void shouldCompleteIfUnderlyingComletes() 
+ void shouldErrorIfUnderlyingErrors() 
+ void shouldSwitchToOtherIfOnNextNotWithinTimeout() 
+ void shouldSwitchToOtherIfOnErrorNotWithinTimeout() 
+ void shouldSwitchToOtherIfOnCompletedNotWithinTimeout() 
+ void shouldSwitchToOtherAndCanBeUnsubscribedIfOnNextNotWithinTimeout() 
+ void shouldTimeoutIfSynchronizedObservableEmitFirstOnNextNotWithinTimeout()
            
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnTimeout() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyComplete() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyErrored() 
+ void shouldUnsubscribeFromUnderlyingSubscriptionOnDispose() 
+ void timedAndOther() 
+ void disposed() 
+ void timedErrorOther() 
+ void timedError() 
+ void timedEmptyOther() 
+ void timedEmpty() 
+ void newTimer() 
+ void badSource() 
+ void badSourceOther() 
+ void timedTake() 
+ void timedFallbackTake() 
    - PublishSubject<String> underlyingSubject;
    - TestScheduler testScheduler;
    - Observable<String> withTimeout;
 
}
class io.reactivex.internal.operators.observable.ObservableTimeoutTimed {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~        final long timeout;
~        final TimeUnit unit;
~        final ObserverFullArbiter<T> arbiter;
            - final long idx;
 
}
class io.reactivex.internal.operators.observable.ObservableTimeoutWithSelectorTest {
 + void testTimeoutSelectorNormal1() 
+ void testTimeoutSelectorTimeoutFirst() 
+ void testTimeoutSelectorFirstThrows() 
+ Observable<Integer> call() 
+ void testTimeoutSelectorSubsequentThrows() 
+ void testTimeoutSelectorFirstObservableThrows() 
+ void testTimeoutSelectorSubsequentObservableThrows() 
+ void testTimeoutSelectorWithFirstTimeoutFirstAndNoOtherObservable() 
+ void testTimeoutSelectorWithTimeoutFirstAndNoOtherObservable() 
+ void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() 
+ Void answer(InvocationOnMock invocation) 
+ void run() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ ObservableSource<Object> apply(Observable<Object> o) 
+ void empty() 
+ void error() 
+ void emptyInner() 
+ void badInnerSource() 
+ void badInnerSourceOther() 
+ void withOtherMainError() 
+ void badSourceTimeout() 
+ void selectorTake() 
+ void selectorFallbackTake() 
 
}
class io.reactivex.internal.operators.observable.ObservableTimer {
 + void subscribeActual(Observer<? super Long> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ void setResource(Disposable d) 
~    final Scheduler scheduler;
~    final long delay;
~    final TimeUnit unit;
 
}
class io.reactivex.internal.operators.observable.ObservableTimerTest {
 + void before() 
+ void testTimerOnce() 
+ void testTimerPeriodically() 
+ void testInterval() 
+ void testWithMultipleSubscribersStartingAtSameTime() 
+ void testWithMultipleStaggeredSubscribers() 
+ void testWithMultipleStaggeredSubscribersAndPublish() 
+ void testOnceObserverThrows() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testPeriodicObserverThrows() 
+ void disposed() 
+ void timerDelayZero() 
+ void timerInterruptible() 
+ Long apply(Long v) 
 
}
class io.reactivex.internal.operators.observable.ObservableTimestampTest {
 + void before() 
+ void timestampWithScheduler() 
+ void timestampWithScheduler2() 
+ void timeIntervalDefault() 
+ Long apply(Timed<Integer> v) 
+ void timeIntervalDefaultSchedulerCustomUnit() 
 
}
class io.reactivex.internal.operators.observable.ObservableToFutureTest {
 + void testSuccess() 
+ void testSuccessOperatesOnSuppliedScheduler() 
+ void testFailure() 
+ void testCancelledBeforeSubscribe() 
+ void testCancellationDuringFutureGet() 
+ boolean isCancelled() 
+ boolean isDone() 
+ Object get() 
+ Object get(long timeout, TimeUnit unit) 
 
}
class io.reactivex.internal.operators.observable.ObservableToList {
 + void subscribeActual(Observer<? super U> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Callable<U> collectionSupplier;
 
}
class io.reactivex.internal.operators.observable.ObservableToListSingle {
 + void subscribeActual(SingleObserver<? super U> t) 
+ Observable<U> fuseToObservable() 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ObservableSource<T> source;
~    final Callable<U> collectionSupplier;
 
}
class io.reactivex.internal.operators.observable.ObservableToListTest {
 + void testListObservable() 
+ void testListViaObservableObservable() 
+ void testListMultipleSubscribersObservable() 
+ void testListWithNullValueObservable() 
+ void testListWithBlockingFirstObservable() 
+ void capacityHintObservable() 
+ void testList() 
+ void testListViaObservable() 
+ void testListMultipleSubscribers() 
+ void testListWithNullValue() 
+ void testListWithBlockingFirst() 
~{static} void await(CyclicBarrier cb) 
+ void capacityHint() 
+ void dispose() 
+ void error() 
+ void errorSingle() 
+ void collectionSupplierThrows() 
+ void collectionSupplierReturnsNull() 
+ void singleCollectionSupplierThrows() 
+ void singleCollectionSupplierReturnsNull() 
 
}
class io.reactivex.internal.operators.observable.ObservableToMapTest {
 + void before() 
+ Integer apply(String t1) 
+ String apply(String t1) 
+ void testToMapObservable() 
+ void testToMapWithValueSelectorObservable() 
+ void testToMapWithErrorObservable() 
+ void testToMapWithErrorInValueSelectorObservable() 
+ void testToMapWithFactoryObservable() 
+ String apply(String v) 
+ void testToMapWithErrorThrowingFactoryObservable() 
+ void testToMap() 
+ void testToMapWithValueSelector() 
+ void testToMapWithError() 
+ void testToMapWithErrorInValueSelector() 
+ void testToMapWithFactory() 
+ void testToMapWithErrorThrowingFactory() 
 
}
class io.reactivex.internal.operators.observable.ObservableToMultimapTest {
 + void before() 
+ Integer apply(String t1) 
+ String apply(String t1) 
+ void testToMultimapObservable() 
+ void testToMultimapWithValueSelectorObservable() 
+ void testToMultimapWithMapFactoryObservable() 
+ String apply(String v) 
+ Collection<String> apply(Integer v) 
+ void testToMultimapWithCollectionFactoryObservable() 
+ void testToMultimapWithErrorObservable() 
+ void testToMultimapWithErrorInValueSelectorObservable() 
+ void testToMultimapWithMapThrowingFactoryObservable() 
+ void testToMultimapWithThrowingCollectionFactoryObservable() 
+ void testToMultimap() 
+ void testToMultimapWithValueSelector() 
+ void testToMultimapWithMapFactory() 
+ void testToMultimapWithCollectionFactory() 
+ void testToMultimapWithError() 
+ void testToMultimapWithErrorInValueSelector() 
+ void testToMultimapWithMapThrowingFactory() 
+ void testToMultimapWithThrowingCollectionFactory() 
 
}
class io.reactivex.internal.operators.observable.ObservableToSortedListTest {
 + void testSortedListObservable() 
+ void testSortedListWithCustomFunctionFlowable() 
+ void testWithFollowingFirstObservable() 
~{static} void await(CyclicBarrier cb) 
+ void sorted() 
+ void sortedComparator() 
+ void toSortedListCapacityObservable() 
+ void toSortedListComparatorCapacityObservable() 
+ void testSortedList() 
+ void testSortedListWithCustomFunction() 
+ void testWithFollowingFirst() 
+ void toSortedListCapacity() 
+ void toSortedListComparatorCapacity() 
 
}
class io.reactivex.internal.operators.observable.ObservableToXTest {
 + void toFlowableBuffer() 
+ void toFlowableDrop() 
+ void toFlowableLatest() 
+ void toFlowableError1() 
+ void toFlowableError2() 
+ void toFlowableMissing() 
 
}
class io.reactivex.internal.operators.observable.ObservableUnsubscribeOn {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final Scheduler scheduler;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableUnsubscribeOnTest {
 + void unsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnSameThread() 
+ void unsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnDifferentThreads() 
+ void dispose() 
+ boolean isDisposed() 
+ Thread getThread() 
+ void run() 
+ Worker createWorker() 
+ void normal() 
+ void error() 
+ void signalAfterDispose() 
        - final Scheduler eventLoop;
 
}
class io.reactivex.internal.operators.observable.ObservableUsing {
 + void subscribeActual(Observer<? super T> s) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final boolean eager;
~        final D resource;
~        final boolean eager;
 
}
class io.reactivex.internal.operators.observable.ObservableUsingTest {
 + void accept(Resource r) 
+ void accept(Disposable s) 
+ void testUsing() 
+ void testUsingEagerly() 
- void performTestUsing(boolean disposeEagerly) 
+ Observable<String> apply(Resource res) 
+ void testUsingWithSubscribingTwice() 
+ void testUsingWithSubscribingTwiceDisposeEagerly() 
- void performTestUsingWithSubscribingTwice(boolean disposeEagerly) 
+ void dispose() 
+ void testUsingWithResourceFactoryError() 
+ void testUsingWithResourceFactoryErrorDisposeEagerly() 
- void performTestUsingWithResourceFactoryError(boolean disposeEagerly) 
+ Observable<Integer> apply(Disposable s) 
+ void testUsingWithObservableFactoryError() 
+ void testUsingWithObservableFactoryErrorDisposeEagerly() 
- void performTestUsingWithObservableFactoryError(boolean disposeEagerly) 
+ Observable<Integer> apply(Disposable subscription) 
+ void testUsingWithObservableFactoryErrorInOnSubscribe() 
+ void testUsingWithObservableFactoryErrorInOnSubscribeDisposeEagerly() 
- void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean disposeEagerly) 
+ void testUsingDisposesEagerlyBeforeCompletion() 
+ void testUsingDoesNotDisposesEagerlyBeforeCompletion() 
+ void testUsingDisposesEagerlyBeforeError() 
+ void testUsingDoesNotDisposesEagerlyBeforeError() 
- {static} Action createUnsubAction(final List<String> events) 
- {static} Consumer<Throwable> createOnErrorAction(final List<String> events) 
- {static} Callable<Resource> createResourceFactory(final List<String> events) 
- {static} Action createOnCompletedAction(final List<String> events) 
+ ObservableSource<Object> apply(Object v) 
+ void supplierDisposerCrash() 
+ void accept(Object e) 
+ void eagerOnErrorDisposerCrash() 
+ void eagerOnCompleteDisposerCrash() 
+ void nonEagerDisposerCrash() 
 
}
class io.reactivex.internal.operators.observable.ObservableWindow {
 + void subscribeActual(Observer<? super Observable<T>> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final long count;
~    final long skip;
~    final int capacityHint;
~        final long count;
~        final int capacityHint;
~        final long skip;
~        final ArrayDeque<UnicastSubject<T>> windows;
 
}
class io.reactivex.internal.operators.observable.ObservableWindowBoundary {
 + void subscribeActual(Observer<? super Observable<T>> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(B t) 
~    final ObservableSource<B> other;
~    final int bufferSize;
~        final ObservableSource<B> other;
~        final int bufferSize;
 
}
class io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector {
 + void subscribeActual(Observer<? super Observable<T>> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void accept(Observer<? super Observable<T>> a, Object v) 
+ void onNext(B t) 
+ void onNext(V t) 
~    final ObservableSource<B> open;
~    final int bufferSize;
~        final ObservableSource<B> open;
~        final int bufferSize;
~        final CompositeDisposable resources;
~        final List<UnicastSubject<T>> ws;
~        final UnicastSubject<T> w;
~        final B open;
 
}
class io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier {
 + void subscribeActual(Observer<? super Observable<T>> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(B t) 
~    final int bufferSize;
~        final int bufferSize;
 
}
class io.reactivex.internal.operators.observable.ObservableWindowTimed {
 + void subscribeActual(Observer<? super Observable<T>> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final long timespan;
~    final long timeskip;
~    final TimeUnit unit;
~    final Scheduler scheduler;
~    final long maxSize;
~    final int bufferSize;
~    final boolean restartTimerOnMaxSize;
~        final long timespan;
~        final TimeUnit unit;
~        final Scheduler scheduler;
~        final int bufferSize;
~        final boolean restartTimerOnMaxSize;
~        final long maxSize;
~            final long index;
~        final long timeskip;
~        final List<UnicastSubject<T>> windows;
~            final UnicastSubject<T> w;
~            final boolean open;
            - final UnicastSubject<T> w;
 
}
class io.reactivex.internal.operators.observable.ObservableWindowWithObservableTest {
 + void testWindowViaObservableNormal1() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testWindowViaObservableBoundaryCompletes() 
+ void testWindowViaObservableBoundaryThrows() 
+ void testWindowViaObservableSourceThrows() 
+ void testWindowNoDuplication() 
+ void onNext(Observable<Integer> t) 
+ Observable<Object> call() 
+ void testWindowViaObservableNoUnsubscribe() 
+ void testBoundaryUnsubscribedOnMainCompletion() 
+ void testMainUnsubscribedOnBoundaryCompletion() 
+ void testChildUnsubscribed() 
+ void newBoundaryCalledAfterWindowClosed() 
+ void boundaryDispose() 
+ void boundaryDispose2() 
+ void boundaryOnError() 
+ void mainError() 
+ void innerBadSource() 
+ Object apply(Observable<Integer> o) 
+ void reentrant() 
+ ObservableSource<Integer> apply(Observable<Integer> v) 
+ void reentrantCallable() 
+ Observable<Integer> call() 
+ void badSource() 
+ void badSourceCallable() 
 
}
class io.reactivex.internal.operators.observable.ObservableWindowWithSizeTest {
 + Observable<List<T>> apply(Observable<T> xs) 
+ void accept(List<T> xs) 
+ void testNonOverlappingWindows() 
+ void testSkipAndCountGaplessWindows() 
+ void testOverlappingWindows() 
+ void testSkipAndCountWindowsWithGaps() 
+ void testWindowUnsubscribeNonOverlapping() 
+ void testWindowUnsubscribeNonOverlappingAsyncSource() 
+ void testWindowUnsubscribeOverlapping() 
+ void testWindowUnsubscribeOverlappingAsyncSource() 
- List<String> list(String... args) 
+ {static} Observable<Integer> hotStream() 
+ void testTakeFlatMapCompletes() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ ObservableSource<Observable<Object>> apply(Observable<Object> o) 
+ void errorExact() 
+ void errorSkip() 
+ void errorOverlap() 
+ void errorExactInner() 
+ void accept(Observable<Integer> w) 
+ void errorSkipInner() 
+ void errorOverlapInner() 
 
}
class io.reactivex.internal.operators.observable.ObservableWindowWithStartEndObservableTest {
 + void before() 
+ void testObservableBasedOpenerAndCloser() 
+ void subscribe(Observer<? super Object> innerObserver) 
+ Observable<Object> apply(Object opening) 
+ void testObservableBasedCloser() 
+ Observable<Object> call() 
- List<String> list(String... args) 
+ void run() 
- void complete(final Observer<?> observer, int delay) 
- Consumer<Observable<String>> observeWindow(final List<String> list, final List<List<String>> lists) 
+ void onError(Throwable e) 
+ void onNext(String args) 
+ void testNoUnsubscribeAndNoLeak() 
+ void testUnsubscribeAll() 
+ void boundarySelectorNormal() 
+ void startError() 
+ void endError() 
+ void dispose() 
+ void reentrant() 
+ ObservableSource<Integer> apply(Observable<Integer> v) 
+ void badSourceCallable() 
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableWindowWithTimeTest {
 + void before() 
+ void testTimedAndCount() 
+ void testTimed() 
- List<String> list(String... args) 
+ void run() 
- void complete(final Observer<?> observer, int delay) 
+ void accept(Observable<T> stringObservable) 
+ void onError(Throwable e) 
+ void onNext(T args) 
+ void testExactWindowSize() 
+ void testTakeFlatMapCompletes() 
+ Observable<Integer> apply(Observable<Integer> w) 
+ void accept(Integer pv) 
+ void timespanTimeskipDefaultScheduler() 
+ void timespanTimeskipCustomScheduler() 
+ void timespanTimeskipCustomSchedulerBufferSize() 
+ void timespanDefaultSchedulerSize() 
+ void timespanDefaultSchedulerSizeRestart() 
+ void invalidSpan() 
+ void timeskipJustOverlap() 
+ void timeskipJustSkip() 
+ void timeskipSkipping() 
+ void timeskipOverlapping() 
+ void exactOnError() 
+ void overlappingOnError() 
+ void skipOnError() 
+ void dispose() 
+ void restartTimer() 
+ void exactBoundaryError() 
+ void restartTimerMany() 
+ void exactUnboundedReentrant() 
+ ObservableSource<Integer> apply(Observable<Integer> v) 
+ void exactBoundedReentrant() 
+ void exactBoundedReentrant2() 
+ void skipReentrant() 
+ void sizeTimeTimeout() 
+ void periodicWindowCompletion() 
+ void periodicWindowCompletionRestartTimer() 
+ void periodicWindowCompletionBounded() 
+ void periodicWindowCompletionRestartTimerBounded() 
+ void periodicWindowCompletionRestartTimerBoundedSomeData() 
+ void countRestartsOnTimeTick() 
    - TestScheduler scheduler;
 
}
class io.reactivex.internal.operators.observable.ObservableWithLatestFrom {
 + void subscribeActual(Observer<? super R> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean setOther(Disposable o) 
+ void otherError(Throwable e) 
+ void onNext(U t) 
 
}
class io.reactivex.internal.operators.observable.ObservableWithLatestFromMany {
 # void subscribeActual(Observer<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
+ void onNext(Object t) 
+ R apply(T t) 
~        final WithLatestInnerObserver[] observers;
~        final AtomicReferenceArray<Object> values;
~        final AtomicReference<Disposable> d;
~        final AtomicThrowable error;
~        final int index;
 
}
class io.reactivex.internal.operators.observable.ObservableWithLatestFromTest {
 + Integer apply(Integer t1, Integer t2) 
+ void testSimple() 
+ void testEmptySource() 
+ void testEmptyOther() 
+ void testUnsubscription() 
+ void testSourceThrows() 
+ void testOtherThrows() 
+ void testFunctionThrows() 
+ void testNoDownstreamUnsubscribe() 
+ String apply(Object[] args) 
+ void manySources() 
+ void manySourcesIterable() 
+ void manySourcesIterableSweep() 
+ void backpressureNoSignal() 
+ void backpressureWithSignal() 
+ void withEmpty() 
+ void withError() 
+ void withMainError() 
+ void with2Others() 
+ void with3Others() 
+ void with4Others() 
+ void dispose() 
+ Object apply(Integer a, Integer b, Integer c) 
+ void manyIteratorThrows() 
+ Object apply(Object[] a) 
+ void manyCombinerThrows() 
+ void manyErrors() 
+ void combineToNull1() 
+ void combineToNull2() 
 
}
class io.reactivex.internal.operators.observable.ObservableZip {
 + void subscribeActual(Observer<? super R> s) 
+ void subscribe(ObservableSource<? extends T>[] sources, int bufferSize) 
+ void dispose() 
+ boolean isDisposed() 
+ void drain() 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int bufferSize;
~    final boolean delayError;
~        final T[] row;
~        final boolean delayError;
~        final SpscLinkedArrayQueue<T> queue;
 
}
class io.reactivex.internal.operators.observable.ObservableZipCompletionTest {
 + void setUp() 
+ void testFirstCompletesThenSecondInfinite() 
+ void testSecondInfiniteThenFirstCompletes() 
+ void testSecondCompletesThenFirstInfinite() 
+ void testFirstInfiniteThenSecondCompletes() 
 
}
class io.reactivex.internal.operators.observable.ObservableZipIterable {
 + void subscribeActual(Observer<? super V> t) 
+ void onSubscribe(Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final Iterable<U> other;
~        final Iterator<U> iterator;
 
}
class io.reactivex.internal.operators.observable.ObservableZipIterableTest {
 + void setUp() 
+ String apply(Object t1, Object t2) 
+ String apply(Object t1, Object t2, Object t3) 
+ void testZipIterableSameSize() 
+ void testZipIterableEmptyFirstSize() 
+ void testZipIterableEmptySecond() 
+ void testZipIterableFirstShorter() 
+ void testZipIterableSecondShorter() 
+ void testZipIterableFirstThrows() 
+ void testZipIterableIteratorThrows() 
+ void testZipIterableHasNextThrows() 
+ String next() 
+ void remove() 
+ void testZipIterableNextThrows() 
+ void accept(String pv) 
+ String apply(Integer t1) 
+ void testTake2() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void iteratorThrows() 
+ void badSource() 
+ Object apply(Integer a, Integer b) 
 
}
class io.reactivex.internal.operators.observable.ObservableZipTest {
 + void setUp() 
+ void testCollectionSizeDifferentThanFunction() 
+ void testStartpingDifferentLengthObservableSequences1() 
+ void testStartpingDifferentLengthObservableSequences2() 
+ String apply(Object t1, Object t2) 
+ String apply(Object t1, Object t2, Object t3) 
+ void testAggregatorSimple() 
+ void testAggregatorDifferentSizedResultsWithOnComplete() 
+ void testAggregateMultipleTypes() 
+ void testAggregate3Types() 
+ void testAggregatorsWithDifferentSizesAndTiming() 
+ void testAggregatorError() 
+ void testAggregatorUnsubscribe() 
+ void testAggregatorEarlyCompletion() 
+ void testStart2Types() 
+ void testStart3Types() 
+ void testOnNextExceptionInvokesOnError() 
+ void testOnFirstCompletion() 
+ void testOnErrorTermination() 
+ String apply(String t1, String t2) 
+ Integer apply(Integer i1, Integer i2) 
+ String apply(String a1, String a2, String a3) 
+ String apply(String s, Integer i) 
+ String apply(String s, Integer i, int[] iArray) 
- {static} String getStringValue(Object o) 
+ void subscribe(Observer<? super String> observer) 
+ void testFirstCompletesThenSecondInfinite() 
+ void testSecondInfiniteThenFirstCompletes() 
+ void testSecondCompletesThenFirstInfinite() 
+ void testFirstInfiniteThenSecondCompletes() 
+ void testFirstFails() 
+ void testSecondFails() 
+ void testStartWithOnCompletedTwice() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer args) 
+ void testStart() 
+ void accept(String s) 
+ void testStartAsync() 
+ void testStartInfiniteAndFinite() 
+ void onNext(String s) 
+ void testEmitNull() 
~{static} String kind(Notification notification) 
~{static} String value(Notification notification) 
+ void testEmitMaterializedNotifications() 
+ void testStartEmptyObservables() 
+ void testStartEmptyList() 
+ void testStartEmptyListBlocking() 
+ void testDownstreamBackpressureRequestsWithFiniteSyncObservables() 
- Observable<Integer> createInfiniteObservable(final AtomicInteger generated) 
+ Integer next() 
+ boolean hasNext() 
+ void subscribe(final Observer<? super Integer> o) 
+ void testIssue1812() 
+ void testZipRace() 
+ void zip2() 
+ void zip3() 
+ void zip4() 
+ void zip5() 
+ void zip6() 
+ void zip7() 
+ void zip8() 
+ void zip9() 
+ void zip2DelayError() 
+ void zip2Prefetch() 
+ void zip2DelayErrorPrefetch() 
+ void zipArrayEmpty() 
+ void zipArrayMany() 
+ void dispose() 
+ void noCrossBoundaryFusion() 
+ Object apply(Integer v) 
+ List<Object> apply(Object t1, Object t2) 
+ void eagerDispose() 
+ Integer apply(Integer t1, Integer t2) 
 
}
class io.reactivex.internal.operators.observable.ObserverResourceWrapper {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void setResource(Disposable resource) 
 
}
class io.reactivex.internal.operators.observable.Single
class io.reactivex.internal.operators.parallel.Flowable
class io.reactivex.internal.operators.parallel.ParallelCollect {
 + void subscribe(Subscriber<? super C>[] subscribers) 
+ int parallelism() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
 
}
class io.reactivex.internal.operators.parallel.ParallelConcatMap {
 + int parallelism() 
+ void subscribe(Subscriber<? super R>[] subscribers) 
~    final ParallelFlowable<T> source;
~    final int prefetch;
~    final ErrorMode errorMode;
 
}
class io.reactivex.internal.operators.parallel.ParallelDoOnNextTry {
 + void subscribe(Subscriber<? super T>[] subscribers) 
+ int parallelism() 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ boolean tryOnNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ParallelFlowable<T> source;
 
}
class io.reactivex.internal.operators.parallel.ParallelFilter {
 + void subscribe(Subscriber<? super T>[] subscribers) 
+ int parallelism() 
+ final void request(long n) 
+ final void cancel() 
+ final void onNext(T t) 
+ void onSubscribe(Subscription s) 
+ boolean tryOnNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ParallelFlowable<T> source;
 
}
class io.reactivex.internal.operators.parallel.ParallelFilterTry {
 + void subscribe(Subscriber<? super T>[] subscribers) 
+ int parallelism() 
+ final void request(long n) 
+ final void cancel() 
+ final void onNext(T t) 
+ void onSubscribe(Subscription s) 
+ boolean tryOnNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ParallelFlowable<T> source;
 
}
class io.reactivex.internal.operators.parallel.ParallelFlatMap {
 + int parallelism() 
+ void subscribe(Subscriber<? super R>[] subscribers) 
~    final ParallelFlowable<T> source;
~    final boolean delayError;
~    final int maxConcurrency;
~    final int prefetch;
 
}
class io.reactivex.internal.operators.parallel.ParallelFlowable
class io.reactivex.internal.operators.parallel.ParallelFromArray {
 + int parallelism() 
+ void subscribe(Subscriber<? super T>[] subscribers) 
~    final Publisher<T>[] sources;
 
}
class io.reactivex.internal.operators.parallel.ParallelFromPublisher {
 + int parallelism() 
+ void subscribe(Subscriber<? super T>[] subscribers) 
+ void onSubscribe(Subscription s) 
+ void request(long n) 
+ void cancel() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final int parallelism;
~    final int prefetch;
~        final AtomicLongArray requests;
~        final long[] emissions;
~        final int prefetch;
~        final int limit;
~            final int j;
~            final int m;
 
}
class io.reactivex.internal.operators.parallel.ParallelJoin {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
~{abstract} void onNext(JoinInnerSubscriber<T> inner, T value)
+ void onNext(JoinInnerSubscriber<T> inner, T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void requestOne() 
+ boolean cancel() 
~    final int prefetch;
~    final boolean delayErrors;
~        final JoinInnerSubscriber<T>[] subscribers;
~        final JoinSubscriptionBase<T> parent;
~        final int prefetch;
~        final int limit;
 
}
class io.reactivex.internal.operators.parallel.ParallelMap {
 + void subscribe(Subscriber<? super R>[] subscribers) 
+ int parallelism() 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean tryOnNext(T t) 
~    final ParallelFlowable<T> source;
 
}
class io.reactivex.internal.operators.parallel.ParallelMapTry {
 + void subscribe(Subscriber<? super R>[] subscribers) 
+ int parallelism() 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ boolean tryOnNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ParallelFlowable<T> source;
 
}
class io.reactivex.internal.operators.parallel.ParallelPeek {
 + void subscribe(Subscriber<? super T>[] subscribers) 
+ int parallelism() 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ParallelFlowable<T> source;
~    final Action onComplete;
~    final Action onAfterTerminated;
~    final LongConsumer onRequest;
~    final Action onCancel;
~        final ParallelPeek<T> parent;
 
}
class io.reactivex.internal.operators.parallel.ParallelReduce {
 + void subscribe(Subscriber<? super R>[] subscribers) 
+ int parallelism() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
~    final Callable<R> initialSupplier;
 
}
class io.reactivex.internal.operators.parallel.ParallelReduceFull {
 # void subscribeActual(Subscriber<? super T> s) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~        final ParallelReduceFullInnerSubscriber<T>[] subscribers;
~        final ParallelReduceFullMainSubscriber<T> parent;
 
}
class io.reactivex.internal.operators.parallel.ParallelRunOn {
 + void subscribe(Subscriber<? super T>[] subscribers) 
+ int parallelism() 
+ final void onNext(T t) 
+ final void onError(Throwable t) 
+ final void onComplete() 
+ final void request(long n) 
+ final void cancel() 
~final void schedule() 
+ void onSubscribe(Subscription s) 
+ void run() 
~    final Scheduler scheduler;
~    final int prefetch;
~        final int prefetch;
~        final int limit;
~        final SpscArrayQueue<T> queue;
~        final Worker worker;
 
}
class io.reactivex.internal.operators.parallel.ParallelSortedJoin {
 # void subscribeActual(Subscriber<? super T> s) 
+ void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(List<T> t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final ParallelFlowable<List<T>> source;
~        final SortedJoinInnerSubscriber<T>[] subscribers;
~        final List<T>[] lists;
~        final int[] indexes;
~        final SortedJoinSubscription<T> parent;
~        final int index;
 
}
class io.reactivex.internal.operators.single.Completable
class io.reactivex.internal.operators.single.Flowable
class io.reactivex.internal.operators.single.Observable
class io.reactivex.internal.operators.single.Single
class io.reactivex.internal.operators.single.SingleAmb {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~        final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.single.SingleAmbTest {
 + void ambWithFirstFires() 
+ void ambWithSecondFires() 
+ void ambIterableWithFirstFires() 
+ void ambIterableWithSecondFires() 
+ void ambArrayEmpty() 
+ void ambSingleSource() 
+ void error() 
+ void nullSourceSuccessRace() 
+ void run() 
+ void multipleErrorRace() 
+ void successErrorRace() 
+ void manySources() 
+ void ambWithOrder() 
+ void ambIterableOrder() 
+ void ambArrayOrder() 
 
}
class io.reactivex.internal.operators.single.SingleCache {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ boolean isDisposed() 
+ void dispose() 
~    final AtomicInteger wip;
~    final AtomicReference<CacheDisposable<T>[]> observers;
~        final SingleCache<T> parent;
 
}
class io.reactivex.internal.operators.single.SingleCacheTest {
 + void cancelImmediately() 
+ void addRemoveRace() 
+ void run() 
+ void doubleDispose() 
+ void onSuccess(Integer value) 
+ void onError(Throwable e) 
 
}
class io.reactivex.internal.operators.single.SingleConcatPublisherTest {
 + void scalar() 
+ void callable() 
 
}
class io.reactivex.internal.operators.single.SingleConcatTest {
 + void concatWith() 
+ void concat2() 
+ void concat3() 
+ void concat4() 
+ void concatArray() 
+ void concatObservable() 
+ void noSubsequentSubscription() 
+ void subscribe(SingleEmitter<Integer> s) 
+ void noSubsequentSubscriptionIterable() 
 
}
class io.reactivex.internal.operators.single.SingleContains {
 # void subscribeActual(final SingleObserver<? super Boolean> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T v) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
~    final Object value;
 
}
class io.reactivex.internal.operators.single.SingleContainstTest {
 + void comparerThrows() 
+ void error() 
 
}
class io.reactivex.internal.operators.single.SingleCreate {
 # void subscribeActual(SingleObserver<? super T> s) 
+ void onSuccess(T value) 
+ void onError(Throwable t) 
+ boolean tryOnError(Throwable t) 
+ void setDisposable(Disposable d) 
+ void setCancellable(Cancellable c) 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleOnSubscribe<T> source;
 
}
class io.reactivex.internal.operators.single.SingleCreateTest {
 + void nullArgument() 
+ void basic() 
+ void basicWithCancellable() 
+ void basicWithError() 
+ void unsafeCreate() 
+ void createCallbackThrows() 
+ void dispose() 
+ void createNullSuccess() 
+ void createNullError() 
+ void createConsumerThrows() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void createConsumerThrowsResource() 
+ void createConsumerThrowsOnError() 
+ void createConsumerThrowsResourceOnError() 
+ void tryOnError() 
+ void subscribe(SingleEmitter<Object> e) 
 
}
class io.reactivex.internal.operators.single.SingleDefer {
 # void subscribeActual(SingleObserver<? super T> s) 
 
}
class io.reactivex.internal.operators.single.SingleDeferTest {
 + void normal() 
 
}
class io.reactivex.internal.operators.single.SingleDelay {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(final T value) 
+ void onError(final Throwable e) 
+ void run() 
~    final long time;
~    final TimeUnit unit;
~    final Scheduler scheduler;
        - final SequentialDisposable sd;
            - final T value;
            - final Throwable e;
 
}
class io.reactivex.internal.operators.single.SingleDelayTest {
 + void delay() 
+ void delayError() 
+ void delaySubscriptionCompletable() 
+ void delaySubscriptionObservable() 
+ void delaySubscriptionFlowable() 
+ void delaySubscriptionSingle() 
+ void delaySubscriptionTime() 
+ void delaySubscriptionTimeCustomScheduler() 
+ void testOnErrorCalledOnScheduler() 
+ void withPublisherDispose() 
+ void withPublisherError() 
+ void withPublisherError2() 
+ void withObservableDispose() 
+ void withObservableError() 
+ void withObservableError2() 
+ void withSingleErrors() 
+ void withSingleDispose() 
+ void withCompletableDispose() 
 
}
class io.reactivex.internal.operators.single.SingleDelayWithCompletable {
 # void subscribeActual(SingleObserver<? super T> subscriber) 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
~    final CompletableSource other;
~        final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDelayWithObservable {
 # void subscribeActual(SingleObserver<? super T> subscriber) 
+ void onSubscribe(Disposable d) 
+ void onNext(U value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
~    final ObservableSource<U> other;
~        final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDelayWithPublisher {
 # void subscribeActual(SingleObserver<? super T> subscriber) 
+ void onSubscribe(Subscription s) 
+ void onNext(U value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
~    final Publisher<U> other;
~        final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDelayWithSingle {
 # void subscribeActual(SingleObserver<? super T> subscriber) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(U value) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
~    final SingleSource<U> other;
~        final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDoAfterSuccess {
 # void subscribeActual(SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T t) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDoAfterSuccessTest {
 + void accept(Integer e) 
+ void onNext(Integer t) 
+ void just() 
+ void error() 
+ void consumerNull() 
+ void justConditional() 
+ void errorConditional() 
+ void consumerThrows() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.single.SingleDoAfterTerminate {
 # void subscribeActual(SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T t) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
- void onAfterTerminate() 
~    final SingleSource<T> source;
~    final Action onAfterTerminate;
~        final Action onAfterTerminate;
 
}
class io.reactivex.internal.operators.single.SingleDoAfterTerminateTest {
 + void run() 
+ void just() 
+ void error() 
+ void afterTerminateActionNull() 
+ void justConditional() 
+ void errorConditional() 
+ void actionThrows() 
+ void dispose() 
+ void doubleOnSubscribe() 
- void assertAfterTerminateCalledOnce() 
 
}
class io.reactivex.internal.operators.single.SingleDoFinally {
 # void subscribeActual(SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T t) 
+ void onError(Throwable t) 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
~    final Action onFinally;
~        final Action onFinally;
 
}
class io.reactivex.internal.operators.single.SingleDoFinallyTest {
 + void run() 
+ void normalJust() 
+ void normalError() 
+ void doubleOnSubscribe() 
+ void nullAction() 
+ void actionThrows() 
+ void disposed() 
 
}
class io.reactivex.internal.operators.single.SingleDoOnDispose {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
~    final Action onDispose;
 
}
class io.reactivex.internal.operators.single.SingleDoOnError {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDoOnEvent {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDoOnSubscribe {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDoOnSuccess {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleDoOnTest {
 + void doOnDispose() 
+ void run() 
+ void doOnError() 
+ void accept(Throwable e) 
+ void doOnSubscribe() 
+ void accept(Disposable d) 
+ void doOnSuccess() 
+ void accept(Integer e) 
+ void doOnSubscribeNormal() 
+ void accept(Disposable s) 
+ void doOnSubscribeError() 
+ void doOnSubscribeJustCrash() 
+ void doOnSubscribeErrorCrash() 
+ void onErrorSuccess() 
+ void accept(Throwable v) 
+ void onErrorCrashes() 
+ void doOnEventThrowsSuccess() 
+ void doOnEventThrowsError() 
+ void doOnDisposeDispose() 
+ void doOnDisposeSuccess() 
+ void doOnDisposeError() 
+ void doOnDisposeDoubleOnSubscribe() 
+ void doOnDisposeCrash() 
+ void doOnSuccessErrors() 
+ void accept(Object v) 
+ void doOnSuccessCrash() 
+ void onSubscribeCrash() 
 
}
class io.reactivex.internal.operators.single.SingleEquals {
 # void subscribeActual(final SingleObserver<? super Boolean> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~        final int index;
~        final CompositeDisposable set;
~        final Object[] values;
~        final AtomicInteger count;
 
}
class io.reactivex.internal.operators.single.SingleEqualsTest {
 + void bothError() 
 
}
class io.reactivex.internal.operators.single.SingleError {
 # void subscribeActual(SingleObserver<? super T> s) 
 
}
class io.reactivex.internal.operators.single.SingleErrorTest {
 + void errorCallableThrows() 
 
}
class io.reactivex.internal.operators.single.SingleFlatMap {
 # void subscribeActual(SingleObserver<? super R> actual) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onSubscribe(final Disposable d) 
+ void onSuccess(final R value) 
+ void onError(final Throwable e) 
~            final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.operators.single.SingleFlatMapCompletable {
 # void subscribeActual(CompletableObserver s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
~    final SingleSource<T> source;
~        final CompletableObserver actual;
 
}
class io.reactivex.internal.operators.single.SingleFlatMapCompletableTest {
 + void dispose() 
 
}
class io.reactivex.internal.operators.single.SingleFlatMapIterableFlowable {
 # void subscribeActual(Subscriber<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void request(long n) 
+ void cancel() 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
+ R poll() 
~    final SingleSource<T> source;
~        final AtomicLong requested;
 
}
class io.reactivex.internal.operators.single.SingleFlatMapIterableFlowableTest {
 + void normal() 
+ void emptyIterable() 
+ void error() 
+ void backpressure() 
+ void take() 
+ void fused() 
+ void fusedNoSync() 
+ void iteratorCrash() 
+ void hasNextCrash() 
+ void nextCrash() 
+ void hasNextCrash2() 
+ void async1() 
+ void async2() 
+ void async3() 
+ void async4() 
+ void fusedEmptyCheck() 
+ void onSubscribe(Subscription d) 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void hasNextThrowsUnbounded() 
+ void nextThrowsUnbounded() 
+ void hasNextThrows() 
+ void nextThrows() 
+ void requestBefore() 
+ void requestCreateInnerRace() 
+ void run() 
+ void cancelCreateInnerRace() 
+ void slowPathCancelAfterHasNext() 
+ Integer next() 
+ void remove() 
+ void fastPathCancelAfterHasNext() 
+ void requestIteratorRace() 
 
}
class io.reactivex.internal.operators.single.SingleFlatMapIterableObservable {
 # void subscribeActual(Observer<? super R> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
+ int requestFusion(int mode) 
+ void clear() 
+ boolean isEmpty() 
+ R poll() 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleFlatMapIterableObservableTest {
 + void normal() 
+ void emptyIterable() 
+ void error() 
+ void take() 
+ void fused() 
+ void fusedNoSync() 
+ void iteratorCrash() 
+ void hasNextCrash() 
+ void nextCrash() 
+ void hasNextCrash2() 
+ void doubleOnSubscribe() 
+ void dispose() 
+ void async1() 
+ void async2() 
+ void async3() 
+ void async4() 
+ void fusedEmptyCheck() 
+ void onSubscribe(Disposable d) 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
 
}
class io.reactivex.internal.operators.single.SingleFlatMapMaybe {
 # void subscribeActual(MaybeObserver<? super R> actual) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onSubscribe(final Disposable d) 
+ void onSuccess(final R value) 
+ void onError(final Throwable e) 
+ void onComplete() 
~        final AtomicReference<Disposable> parent;
 
}
class io.reactivex.internal.operators.single.SingleFlatMapMaybeTest {
 + void flatMapMaybeNull() 
+ void flatMapMaybeValue() 
+ void flatMapMaybeValueDifferentType() 
+ void flatMapMaybeValueNull() 
+ void flatMapMaybeValueErrorThrown() 
+ void flatMapMaybeError() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void mapsToError() 
+ void mapsToEmpty() 
 
}
class io.reactivex.internal.operators.single.SingleFlatMapTest {
 + void normal() 
+ Completable apply(Integer t) 
+ void error() 
+ void mapperThrows() 
+ void mapperReturnsNull() 
+ void flatMapObservable() 
+ void flatMapPublisher() 
+ void flatMapNull() 
+ void flatMapValue() 
+ void flatMapValueDifferentType() 
+ void flatMapValueNull() 
+ void flatMapValueErrorThrown() 
+ void flatMapError() 
+ void dispose() 
+ void mappedSingleOnError() 
 
}
class io.reactivex.internal.operators.single.SingleFromCallable {
 # void subscribeActual(SingleObserver<? super T> s) 
 
}
class io.reactivex.internal.operators.single.SingleFromCallableTest {
 + void fromCallableValue() 
+ void fromCallableError() 
+ void fromCallableNull() 
 
}
class io.reactivex.internal.operators.single.SingleFromPublisher {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean isDisposed() 
+ void dispose() 
 
}
class io.reactivex.internal.operators.single.SingleFromPublisherTest {
 + void just() 
+ void range() 
+ void empty() 
+ void error() 
+ void dispose() 
+ void isDisposed() 
+ void badSource() 
 
}
class io.reactivex.internal.operators.single.SingleFromTest {
 + void fromFuture() 
+ void fromFutureTimeout() 
+ void fromPublisher() 
 
}
class io.reactivex.internal.operators.single.SingleFromUnsafeSource {
 # void subscribeActual(SingleObserver<? super T> observer) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleHide {
 # void subscribeActual(SingleObserver<? super T> subscriber) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
 
}
class io.reactivex.internal.operators.single.SingleHideTest {
 + void error() 
+ void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.single.SingleInternalHelper {
 + NoSuchElementException call() 
+ Publisher apply(SingleSource v) 
+ boolean hasNext() 
+ Flowable<T> next() 
+ void remove() 
+ Iterator<Flowable<T>> iterator() 
+ Observable apply(SingleSource v) 
 
}
class io.reactivex.internal.operators.single.SingleInternalHelperTest {
 + void utilityClass() 
+ void noSuchElementCallableEnum() 
+ void toFlowableEnum() 
+ void toObservableEnum() 
+ void singleIterableToFlowableIterable() 
 
}
class io.reactivex.internal.operators.single.SingleJust {
 # void subscribeActual(SingleObserver<? super T> s) 
~    final T value;
 
}
class io.reactivex.internal.operators.single.SingleLift {
 # void subscribeActual(SingleObserver<? super R> s) 
~    final SingleSource<T> source;
 
}
class io.reactivex.internal.operators.single.SingleLiftTest {
 + void normal() 
+ void onSuccess(Integer value) 
+ void onError(Throwable e) 
 
}
class io.reactivex.internal.operators.single.SingleMap {
 # void subscribeActual(final SingleObserver<? super R> t) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
 
}
class io.reactivex.internal.operators.single.SingleMapTest {
 + void mapNull() 
+ void mapValue() 
+ void mapValueNull() 
+ void mapValueErrorThrown() 
+ void mapError() 
 
}
class io.reactivex.internal.operators.single.SingleMergeTest {
 + void mergeSingleSingle() 
+ void merge2() 
+ void merge3() 
+ void merge4() 
+ void mergeErrors() 
 
}
class io.reactivex.internal.operators.single.SingleMiscTest {
 + void never() 
+ void timer() 
+ void wrap() 
+ void cast() 
+ void contains() 
+ void compose() 
+ void hide() 
+ void onErrorResumeNext() 
+ void onErrorReturnValue() 
+ void repeat() 
+ void repeatTimes() 
+ void repeatUntil() 
+ boolean getAsBoolean() 
+ void retry() 
+ void retryBiPredicate() 
+ boolean test(Integer i, Throwable e) 
+ void retryTimes() 
+ void retryPredicate() 
+ boolean test(Throwable e) 
+ void timeout() 
+ void timeoutOther() 
+ void toCompletable() 
+ void toObservable() 
+ void equals() 
 
}
class io.reactivex.internal.operators.single.SingleNever {
 # void subscribeActual(SingleObserver<? super Object> s) 
 
}
class io.reactivex.internal.operators.single.SingleObserveOn {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
~    final SingleSource<T> source;
~    final Scheduler scheduler;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.single.SingleObserveOnTest {
 + void dispose() 
+ void doubleOnSubscribe() 
+ void error() 
 
}
class io.reactivex.internal.operators.single.SingleOnErrorReturn {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
~    final T value;
 
}
class io.reactivex.internal.operators.single.SingleOnErrorXTest {
 + void returnSuccess() 
+ void resumeThrows() 
+ void resumeErrors() 
+ void resumeDispose() 
+ void resumeDoubleOnSubscribe() 
+ void resumeSuccess() 
 
}
class io.reactivex.internal.operators.single.SingleResumeNext {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.single.SingleSubscribeOn {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final Scheduler scheduler;
~        final SequentialDisposable task;
 
}
class io.reactivex.internal.operators.single.SingleSubscribeOnTest {
 + void normal() 
+ void dispose() 
+ void error() 
 
}
class io.reactivex.internal.operators.single.SingleTakeUntil {
 # void subscribeActual(SingleObserver<? super T> observer) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final SingleSource<T> source;
~    final Publisher<U> other;
~        final TakeUntilOtherSubscriber other;
 
}
class io.reactivex.internal.operators.single.SingleTakeUntilTest {
 + void mainSuccessPublisher() 
+ void mainSuccessSingle() 
+ void mainSuccessCompletable() 
+ void mainErrorPublisher() 
+ void mainErrorSingle() 
+ void mainErrorCompletable() 
+ void otherOnNextPublisher() 
+ void otherOnNextSingle() 
+ void otherOnNextCompletable() 
+ void otherOnCompletePublisher() 
+ void otherOnCompleteCompletable() 
+ void otherErrorPublisher() 
+ void otherErrorSingle() 
+ void otherErrorCompletable() 
+ void withPublisherDispose() 
+ void onErrorRace() 
+ void run() 
+ void otherSignalsAndCompletes() 
 
}
class io.reactivex.internal.operators.single.SingleTimeout {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void run() 
+ void onError(Throwable e) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
~    final SingleSource<T> source;
~    final long timeout;
~    final TimeUnit unit;
~    final Scheduler scheduler;
        - final AtomicBoolean once;
~        final CompositeDisposable set;
        - final CompositeDisposable set;
 
}
class io.reactivex.internal.operators.single.SingleTimeoutTest {
 + void shouldUnsubscribeFromUnderlyingSubscriptionOnDispose() 
+ void otherErrors() 
+ void mainSuccess() 
+ void mainError() 
 
}
class io.reactivex.internal.operators.single.SingleTimer {
 # void subscribeActual(final SingleObserver<? super Long> s) 
+ void run() 
+ void dispose() 
+ boolean isDisposed() 
~    final long delay;
~    final TimeUnit unit;
~    final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.single.SingleTimerTest {
 + void disposed() 
+ void timerInterruptible() 
+ Long apply(Long v) 
 
}
class io.reactivex.internal.operators.single.SingleToFlowable {
 + void subscribeActual(final Subscriber<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void cancel() 
 
}
class io.reactivex.internal.operators.single.SingleToObservable {
 + void subscribeActual(final Observer<? super T> s) 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.operators.single.SingleToObservableTest {
 + void dispose() 
+ void doubleOnSubscribe() 
 
}
class io.reactivex.internal.operators.single.SingleUnsubscribeOn {
 # void subscribeActual(SingleObserver<? super T> observer) 
+ void dispose() 
+ void run() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final SingleSource<T> source;
~    final Scheduler scheduler;
~        final Scheduler scheduler;
 
}
class io.reactivex.internal.operators.single.SingleUnsubscribeOnTest {
 + void normal() 
+ void run() 
+ void just() 
+ void error() 
+ void dispose() 
+ void doubleOnSubscribe() 
+ void disposeRace() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(Integer value) 
+ void onError(Throwable e) 
 
}
class io.reactivex.internal.operators.single.SingleUsing {
 # void subscribeActual(final SingleObserver<? super T> s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
~    final Callable<U> resourceSupplier;
~    final boolean eager;
~        final boolean eager;
 
}
class io.reactivex.internal.operators.single.SingleUsingTest {
 + Single<Integer> apply(Disposable d) 
+ void accept(Disposable d) 
+ void resourceSupplierThrows() 
+ void normalEager() 
+ void normalNonEager() 
+ void errorEager() 
+ void errorNonEager() 
+ void eagerMapperThrowsDisposerThrows() 
+ void noneagerMapperThrowsDisposerThrows() 
+ void resourceDisposedIfMapperCrashes() 
+ void resourceDisposedIfMapperCrashesNonEager() 
+ void dispose() 
+ void disposerThrowsEager() 
+ void disposerThrowsNonEager() 
+ void errorAndDisposerThrowsEager() 
+ void errorAndDisposerThrowsNonEager() 
+ void successDisposeRace() 
+ void run() 
+ void doubleOnSubscribe() 
+ void errorDisposeRace() 
 
}
class io.reactivex.internal.operators.single.SingleZipArray {
 # void subscribeActual(SingleObserver<? super R> observer) 
+ boolean isDisposed() 
+ void dispose() 
+ void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ R apply(T t) 
~        final ZipSingleObserver<T>[] observers;
~        final Object[] values;
~        final int index;
 
}
class io.reactivex.internal.operators.single.SingleZipArray.ZipCoordinator
class io.reactivex.internal.operators.single.SingleZipArrayTest {
 + Object apply(Object a, Object b) 
+ Object apply(Object a, Object b, Object c) 
+ void firstError() 
+ void secondError() 
+ void dispose() 
+ void zipperThrows() 
+ void zipperReturnsNull() 
+ void middleError() 
+ void innerErrorRace() 
+ void run() 
+ void zipArrayOneIsNull() 
+ void emptyArray() 
+ void oneArray() 
 
}
class io.reactivex.internal.operators.single.SingleZipIterable {
 # void subscribeActual(SingleObserver<? super R> observer) 
+ R apply(T t) 
 
}
class io.reactivex.internal.operators.single.SingleZipIterableTest {
 + Object apply(Object[] a) 
+ void firstError() 
+ void secondError() 
+ void dispose() 
+ void zipperThrows() 
+ void zipperReturnsNull() 
+ void middleError() 
+ void innerErrorRace() 
+ void run() 
+ void iteratorThrows() 
+ void hasNextThrows() 
+ void nextThrows() 
+ void zipIterableOneIsNull() 
+ void zipIterableTwoIsNull() 
+ void emptyIterable() 
+ void oneIterable() 
 
}
class io.reactivex.internal.operators.single.SingleZipTest {
 + void zip2() 
+ void zip3() 
+ void zip4() 
+ void zip5() 
+ void zip6() 
+ void zip7() 
+ void zip8() 
+ void zip9() 
+ void noDisposeOnAllSuccess() 
+ Integer apply(Integer a, Integer b) 
+ void noDisposeOnAllSuccess2() 
+ Integer apply(Object[] o) 
 
}
class io.reactivex.internal.queue.AtomicReferenceArray
class io.reactivex.internal.queue.MpscLinkedQueue {
 + boolean offer(final T e) 
+ T poll() 
+ boolean offer(T v1, T v2) 
+ void clear() 
+ boolean isEmpty() 
+ E getAndNullValue() 
+ E lpValue() 
+ void spValue(E newValue) 
+ void soNext(LinkedQueueNode<E> n) 
+ LinkedQueueNode<E> lvNext() 
    - final AtomicReference<LinkedQueueNode<T>> producerNode;
    - final AtomicReference<LinkedQueueNode<T>> consumerNode;
        - E value;
 
}
class io.reactivex.internal.queue.SimpleQueueTest {
 + void spscArrayQueueNull() 
+ void spscLinkedArrayQueueNull() 
+ void mpscLinkedQueueNull() 
+ void spscArrayQueueBiOffer() 
+ void spscLinkedArrayQueueBiOffer() 
+ void mpscLinkedQueueBiOffer() 
+ void spscBiOfferCapacity() 
+ void spscLinkedNewBufferPeek() 
+ void mpscOfferPollRace() 
+ void run() 
 
}
class io.reactivex.internal.queue.SpscArrayQueue {
 + boolean offer(E e) 
+ boolean offer(E v1, E v2) 
+ E poll() 
+ boolean isEmpty() 
+ void clear() 
~    final int mask;
~    final AtomicLong producerIndex;
~    final AtomicLong consumerIndex;
~    final int lookAheadStep;
 
}
class io.reactivex.internal.queue.SpscLinkedArrayQueue {
 + boolean offer(final T e) 
- boolean writeToQueue(final AtomicReferenceArray<Object> buffer, final T e, final long index, final int offset) 
- void resize(final AtomicReferenceArray<Object> oldBuffer, final long currIndex, final int offset, final T e,
            final long mask) 
- void soNext(AtomicReferenceArray<Object> curr, AtomicReferenceArray<Object> next) 
- AtomicReferenceArray<Object> lvNext(AtomicReferenceArray<Object> curr) 
+ T poll() 
- T newBufferPoll(AtomicReferenceArray<Object> nextBuffer, final long index, final int mask) 
+ T peek() 
- T newBufferPeek(AtomicReferenceArray<Object> nextBuffer, final long index, final int mask) 
+ void clear() 
+ int size() 
+ boolean isEmpty() 
- void adjustLookAheadStep(int capacity) 
- long lvProducerIndex() 
- long lvConsumerIndex() 
- long lpProducerIndex() 
- long lpConsumerIndex() 
- void soProducerIndex(long v) 
- void soConsumerIndex(long v) 
- {static} int calcWrappedOffset(long index, int mask) 
- {static} int calcDirectOffset(int index) 
- {static} void soElement(AtomicReferenceArray<Object> buffer, int offset, Object e) 
+ boolean offer(T first, T second) 
~    final int producerMask;
~    final int consumerMask;
 
}
class io.reactivex.internal.schedulers.AbstractDirectTaskTest {
 + void cancelSetFuture() 
+ boolean cancel(boolean mayInterruptIfRunning) 
+ void cancelSetFutureCurrentThread() 
+ void setFutureCancel() 
+ void setFutureCancelSameThread() 
+ void finished() 
+ void finishedCancel() 
+ void disposeSetFutureRace() 
+ void run() 
 
}
class io.reactivex.internal.schedulers.ComputationScheduler {
 ~{static} int cap(int cpuCount, int paramThreads) 
+ PoolWorker getEventLoop() 
+ void shutdown() 
+ Worker createWorker() 
+ Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) 
+ Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit) 
+ void start() 
+ void dispose() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull Runnable action) 
+ Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) 
~    {static} final FixedSchedulerPool NONE;
~    {static} final RxThreadFactory THREAD_FACTORY;
~    {static} final int MAX_THREADS;
~    {static} final PoolWorker SHUTDOWN_WORKER;
~    final ThreadFactory threadFactory;
~    final AtomicReference<FixedSchedulerPool> pool;
~        final int cores;
~        final PoolWorker[] eventLoops;
        - final ListCompositeDisposable serial;
        - final CompositeDisposable timed;
        - final ListCompositeDisposable both;
        - final PoolWorker poolWorker;
 
}
class io.reactivex.internal.schedulers.ComputationSchedulerInternalTest {
 + void capPoolSize() 
 
}
class io.reactivex.internal.schedulers.DisposeOnCancel {
 + boolean cancel(boolean mayInterruptIfRunning) 
+ boolean isCancelled() 
+ boolean isDone() 
+ Object get() 
+ Object get(long timeout, TimeUnit unit)
            
~    final Disposable d;
 
}
class io.reactivex.internal.schedulers.DisposeOnCancelTest {
 + void basicCoverage() 
 
}
class io.reactivex.internal.schedulers.ExecutorScheduler {
 + Worker createWorker() 
+ Disposable scheduleDirect(@NonNull Runnable run) 
+ Disposable scheduleDirect(@NonNull Runnable run, final long delay, final TimeUnit unit) 
+ Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit) 
+ Disposable schedule(@NonNull Runnable run) 
+ Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
~    final Executor executor;
~        final Executor executor;
~        final MpscLinkedQueue<Runnable> queue;
~            final Runnable actual;
            - final SequentialDisposable mar;
            - final Runnable decoratedRun;
~        final SequentialDisposable timed;
~        final SequentialDisposable direct;
        - final DelayedRunnable dr;
 
}
class io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.BooleanRunnable
class io.reactivex.internal.schedulers.ImmediateThinScheduler {
 + Disposable scheduleDirect(@NonNull Runnable run) 
+ Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) 
+ Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit) 
+ Worker createWorker() 
+ void dispose() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull Runnable run) 
+ Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) 
+ Disposable schedulePeriodically(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit) 
~    {static} final Disposable DISPOSED;
 
}
class io.reactivex.internal.schedulers.ImmediateThinSchedulerTest {
 + void scheduleDirect() 
+ void run() 
+ void scheduleDirectTimed() 
+ void scheduleDirectPeriodic() 
+ void schedule() 
+ void scheduleTimed() 
+ void schedulePeriodic() 
 
}
class io.reactivex.internal.schedulers.IoScheduler {
 + void run() 
+ void start() 
+ void shutdown() 
+ Worker createWorker() 
+ int size() 
+ void dispose() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) 
+ long getExpirationTime() 
+ void setExpirationTime(long expirationTime) 
~    {static} final RxThreadFactory WORKER_THREAD_FACTORY;
~    {static} final RxThreadFactory EVICTOR_THREAD_FACTORY;
~    {static} final ThreadWorker SHUTDOWN_THREAD_WORKER;
~    final ThreadFactory threadFactory;
~    final AtomicReference<CachedWorkerPool> pool;
~    {static} final CachedWorkerPool NONE;
        - final long keepAliveTime;
        - final ConcurrentLinkedQueue<ThreadWorker> expiringWorkerQueue;
~        final CompositeDisposable allWorkers;
        - final ScheduledExecutorService evictorService;
        - final ThreadFactory threadFactory;
        - final CompositeDisposable tasks;
        - final CachedWorkerPool pool;
        - final ThreadWorker threadWorker;
        - long expirationTime;
 
}
class io.reactivex.internal.schedulers.NewThreadScheduler {
 + Worker createWorker() 
~    final ThreadFactory threadFactory;
    - {static} final RxThreadFactory THREAD_FACTORY;
 
}
class io.reactivex.internal.schedulers.NewThreadWorker {
 + Disposable schedule(@NonNull final Runnable run) 
+ Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) 
+ Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) 
+ Disposable schedulePeriodicallyDirect(final Runnable run, long initialDelay, long period, TimeUnit unit) 
+ ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) 
+ void dispose() 
+ void shutdown() 
+ boolean isDisposed() 
    - final ScheduledExecutorService executor;
 
}
class io.reactivex.internal.schedulers.RxThreadFactory {
 + Thread newThread(Runnable r) 
+ String toString() 
~    final String prefix;
~    final int priority;
~    final boolean nonBlocking;
 
}
class io.reactivex.internal.schedulers.RxThreadFactoryTest {
 + void normal() 
 
}
class io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask {
 + void run() 
 
}
class io.reactivex.internal.schedulers.ScheduledDirectPeriodicTaskTest {
 + void runnableThrows() 
 
}
class io.reactivex.internal.schedulers.ScheduledDirectTask {
 + Void call() 
 
}
class io.reactivex.internal.schedulers.ScheduledRunnable {
 + Object call() 
+ void run() 
+ void setFuture(Future<?> f) 
+ void dispose() 
+ boolean isDisposed() 
~    final Runnable actual;
 
}
class io.reactivex.internal.schedulers.ScheduledRunnableTest {
 + void dispose() 
+ void disposeRun() 
+ void setFutureCancelRace() 
+ void run() 
+ void setFutureRunRace() 
+ void disposeRace() 
+ void runDispose() 
+ void pluginCrash() 
+ void crashReported() 
+ void withoutParentDisposed() 
+ void withParentDisposed() 
+ void withFutureDisposed() 
+ void withFutureDisposed2() 
+ void withFutureDisposed3() 
+ void runFuture() 
 
}
class io.reactivex.internal.schedulers.SchedulerPoolFactory {
 + {static} void start() 
+ {static} void shutdown() 
+ {static} ScheduledExecutorService create(ThreadFactory factory) 
+ void run() 
    + {static} final boolean PURGE_ENABLED;
    + {static} final int PURGE_PERIOD_SECONDS;
 
}
class io.reactivex.internal.schedulers.SchedulerPoolFactoryTest {
 + void utilityClass() 
 
}
class io.reactivex.internal.schedulers.SchedulerWhen {
 + void dispose() 
+ boolean isDisposed() 
+ Worker createWorker() 
# {abstract} Disposable callActual(Worker actualWorker, CompletableObserver actionCompletable)
# Disposable callActual(Worker actualWorker, CompletableObserver actionCompletable) 
+ void run() 
+ Completable apply(final ScheduledAction action) 
# void subscribeActual(CompletableObserver actionCompletable) 
+ Disposable schedule(@NonNull final Runnable action, final long delayTime, @NonNull final TimeUnit unit) 
+ Disposable schedule(@NonNull final Runnable action) 
    - final Scheduler actualScheduler;
    - final FlowableProcessor<Flowable<Completable>> workerProcessor;
    - Disposable disposable;
        - final Runnable action;
        - final long delayTime;
        - final TimeUnit unit;
~        final CompletableObserver actionCompletable;
~        final Runnable action;
~        final Worker actualWorker;
~            final ScheduledAction action;
        - final AtomicBoolean unsubscribed;
        - final FlowableProcessor<ScheduledAction> actionProcessor;
        - final Worker actualWorker;
 
}
class io.reactivex.internal.schedulers.SchedulerWhenTest {
 + void testAsyncMaxConcurrent() 
+ void testAsyncDelaySubscription() 
+ void testSyncMaxConcurrent() 
+ void testSyncDelaySubscription() 
- Flowable<Long> asyncWork(final Scheduler sched) 
- Flowable<Long> syncWork(final Scheduler sched) 
- SchedulerWhen maxConcurrentScheduler(TestScheduler tSched) 
- SchedulerWhen throttleScheduler(final TestScheduler tSched) 
+ Completable apply(Completable worker) 
+ void testRaceConditions() 
 
}
class io.reactivex.internal.schedulers.SingleScheduler {
 ~{static} ScheduledExecutorService createExecutor(ThreadFactory threadFactory) 
+ void start() 
+ void shutdown() 
+ Worker createWorker() 
+ Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) 
+ Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit) 
+ Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) 
+ void dispose() 
+ boolean isDisposed() 
~    final ThreadFactory threadFactory;
~    {static} final RxThreadFactory SINGLE_THREAD_FACTORY;
~    {static} final ScheduledExecutorService SHUTDOWN;
~        final ScheduledExecutorService executor;
~        final CompositeDisposable tasks;
 
}
class io.reactivex.internal.schedulers.SingleScheduler.ScheduledWorker
class io.reactivex.internal.schedulers.SingleSchedulerTest {
 + void shutdownRejects() 
+ void run() 
+ void startRace() 
+ void runnableDisposedAsync() 
+ void runnableDisposedAsyncCrash() 
+ void runnableDisposedAsyncTimed() 
 
}
class io.reactivex.internal.schedulers.TrampolineScheduler {
 + {static} TrampolineScheduler instance() 
+ Worker createWorker() 
+ Disposable scheduleDirect(@NonNull Runnable run) 
+ Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) 
+ Disposable schedule(@NonNull Runnable action) 
+ Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) 
+ void dispose() 
+ boolean isDisposed() 
+ void run() 
+ int compareTo(TimedRunnable that) 
~            final TimedRunnable timedRunnable;
~        final Runnable run;
~        final long execTime;
~        final int count;
        - final Runnable run;
        - final TrampolineWorker worker;
        - final long execTime;
 
}
class io.reactivex.internal.schedulers.TrampolineSchedulerInternalTest {
 + void scheduleDirectInterrupt() 
+ void run() 
+ void dispose() 
+ void reentrantScheduleDispose() 
+ void reentrantScheduleShutdown() 
+ void reentrantScheduleShutdown2() 
+ void reentrantScheduleInterrupt() 
 
}
class io.reactivex.internal.subscribers.AtomicInteger
class io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriberTest {
 + void offerThrows() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean tryOnNext(Integer t) 
+ int requestFusion(int mode) 
+ Integer poll() 
 
}
class io.reactivex.internal.subscribers.BasicFuseableSubscriberTest {
 + void offerThrows() 
+ int requestFusion(int mode) 
+ Integer poll() 
 
}
class io.reactivex.internal.subscribers.BlockingFirstSubscriber {
 + void onNext(T t) 
+ void onError(Throwable t) 
 
}
class io.reactivex.internal.subscribers.BlockingLastSubscriber {
 + void onNext(T t) 
+ void onError(Throwable t) 
 
}
class io.reactivex.internal.subscribers.BlockingSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
+ boolean isCancelled() 
~    final Queue<Object> queue;
 
}
class io.reactivex.internal.subscribers.BlockingSubscriberTest {
 + void doubleOnSubscribe() 
+ void cancel() 
+ void blockingFirstDoubleOnSubscribe() 
+ void blockingFirstTimeout() 
+ void blockingFirstTimeout2() 
+ void cancelOnRequest() 
+ void cancelUpfront() 
 
}
class io.reactivex.internal.subscribers.CountDownLatch
class io.reactivex.internal.subscribers.DeferredScalarSubscriberTest {
 + void completeFirst() 
+ void requestFirst() 
+ void empty() 
+ void error() 
+ void unsubscribeComposes() 
+ void emptySource() 
+ void justSource() 
+ void rangeSource() 
+ void completeAfterNext() 
+ void completeAfterNextViaRequest() 
+ void doubleComplete() 
+ void doubleComplete2() 
+ void doubleRequest() 
+ void negativeRequest() 
+ void callsAfterUnsubscribe() 
+ void emissionRequestRace() 
+ void emissionRequestRace2() 
+ void run() 
+ void onNext(Integer t) 
+ void setupDownstream() 
+ void subscribeTo(Publisher<Integer> p) 
+ void downstreamRequest(long n) 
 
}
class io.reactivex.internal.subscribers.DeferredScalarSubscription
class io.reactivex.internal.subscribers.EmptyComponentTest {
 + void normal() 
 
}
class io.reactivex.internal.subscribers.ForEachWhileSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final Action onComplete;
 
}
class io.reactivex.internal.subscribers.FullArbiterSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final FullArbiter<T> arbiter;
 
}
class io.reactivex.internal.subscribers.FutureSubscriber {
 + boolean cancel(boolean mayInterruptIfRunning) 
+ boolean isCancelled() 
+ boolean isDone() 
+ T get() 
+ T get(long timeout, TimeUnit unit) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void cancel() 
+ void request(long n) 
~    final AtomicReference<Subscription> s;
 
}
class io.reactivex.internal.subscribers.FutureSubscriberTest {
 + void before() 
+ void cancel() 
+ void onError() 
+ void onNext() 
+ void onSubscribe() 
+ void cancelRace() 
+ void await() 
+ void onErrorCancelRace() 
+ void run() 
+ void onCompleteCancelRace() 
+ void onErrorOnComplete() 
+ void onCompleteOnError() 
+ void cancelOnError() 
+ void cancelOnComplete() 
+ void onNextThenOnCompleteTwice() 
+ void completeAsync() 
 
}
class io.reactivex.internal.subscribers.InnerQueuedSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void requestOne() 
+ void cancel() 
+ boolean isDone() 
+ void setDone() 
+ SimpleQueue<T> queue() 
~    final InnerQueuedSubscriberSupport<T> parent;
~    final int prefetch;
~    final int limit;
 
}
class io.reactivex.internal.subscribers.InnerQueuedSubscriberTest {
 + void requestInBatches() 
+ void innerError(InnerQueuedSubscriber<Integer> inner, Throwable e) 
+ void innerComplete(InnerQueuedSubscriber<Integer> inner) 
+ void drain() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.internal.subscribers.LambdaSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ void request(long n) 
+ void cancel() 
~    final Action onComplete;
 
}
class io.reactivex.internal.subscribers.LambdaSubscriberTest {
 + void onSubscribeThrows() 
+ void accept(Throwable e) 
+ void run() 
+ void accept(Subscription s) 
+ void onNextThrows() 
+ void onErrorThrows() 
+ void onCompleteThrows() 
+ void badSourceOnSubscribe() 
+ void accept(Object v) 
+ void badSourceEmitAfterDone() 
+ void onNextThrowsCancelsUpstream() 
+ void onSubscribeThrowsCancelsUpstream() 
 
}
class io.reactivex.internal.subscribers.QueueDrainSubscriberPad4
class io.reactivex.internal.subscribers.SinglePostCompleteSubscriberTest {
 + void requestCompleteRace() 
+ void onError(Throwable t) 
+ void onComplete() 
+ void run() 
 
}
class io.reactivex.internal.subscribers.StrictSubscriber {
 + void request(long n) 
+ void cancel() 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
~    final AtomicThrowable error;
~    final AtomicLong requested;
~    final AtomicReference<Subscription> s;
~    final AtomicBoolean once;
 
}
class io.reactivex.internal.subscribers.StrictSubscriberTest {
 + void strictMode() 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
# void subscribeActual(Subscriber<? super Object> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void normalOnNext() 
+ void normalOnNextBackpressured() 
+ void normalOnError() 
+ void deferredRequest() 
+ void requestZero() 
+ void requestNegative() 
+ void cancelAfterOnComplete() 
+ void cancelAfterOnError() 
+ void doubleOnSubscribe() 
~        final TestSubscriber<T> tester;
 
}
class io.reactivex.internal.subscribers.SubscriberResourceWrapper {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void dispose() 
+ boolean isDisposed() 
+ void cancel() 
+ void setResource(Disposable resource) 
 
}
class io.reactivex.internal.subscribers.SubscriberResourceWrapperTest {
 + void cancel() 
+ void error() 
+ void complete() 
 
}
class io.reactivex.internal.subscriptions.ArrayCompositeSubscription {
 + boolean setResource(int index, Subscription resource) 
+ Subscription replaceResource(int index, Subscription resource) 
+ void dispose() 
+ boolean isDisposed() 
 
}
class io.reactivex.internal.subscriptions.ArrayCompositeSubscriptionTest {
 + void set() 
+ void replace() 
+ void disposeRace() 
+ void setReplaceRace() 
+ void run() 
 
}
class io.reactivex.internal.subscriptions.AsyncSubscription {
 + void request(long n) 
+ void cancel() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean setResource(Disposable r) 
+ boolean replaceResource(Disposable r) 
+ void setSubscription(Subscription s) 
~    final AtomicReference<Subscription> actual;
~    final AtomicReference<Disposable> resource;
 
}
class io.reactivex.internal.subscriptions.AsyncSubscriptionTest {
 + void testNoResource() 
+ void testRequestBeforeSet() 
+ void testCancelBeforeSet() 
+ void testSingleSet() 
+ void testInitialResource() 
+ void testSetResource() 
+ void testReplaceResource() 
+ void testSetResource2() 
+ void testReplaceResource2() 
+ void testSetResourceAfterCancel() 
+ void testReplaceResourceAfterCancel() 
+ void testCancelOnce() 
+ void disposed() 
 
}
class io.reactivex.internal.subscriptions.AtomicInteger
class io.reactivex.internal.subscriptions.AtomicLong
class io.reactivex.internal.subscriptions.BooleanSubscription {
 + void request(long n) 
+ void cancel() 
+ boolean isCancelled() 
+ String toString() 
 
}
class io.reactivex.internal.subscriptions.DeferredScalarSubscription {
 + final void request(long n) 
+ final void complete(T v) 
+ final int requestFusion(int mode) 
+ final T poll() 
+ final boolean isEmpty() 
+ final void clear() 
+ void cancel() 
+ final boolean isCancelled() 
+ final boolean tryCancel() 
    # T value;
 
}
class io.reactivex.internal.subscriptions.DeferredScalarSubscriptionTest {
 + void queueSubscriptionSyncRejected() 
+ void clear() 
+ void cancel() 
+ void completeCancelRace() 
+ void run() 
+ void requestClearRace() 
+ void requestCancelRace() 
 
}
class io.reactivex.internal.subscriptions.FullArbiter {
 + void request(long n) 
+ void cancel() 
+ boolean setSubscription(Subscription s) 
+ boolean onNext(T value, Subscription s) 
+ void onError(Throwable value, Subscription s) 
+ void onComplete(Subscription s) 
~    final SpscLinkedArrayQueue<Object> queue;
 
}
class io.reactivex.internal.subscriptions.FullArbiterPad2
class io.reactivex.internal.subscriptions.FullArbiterTest {
 + void initialRequested() 
+ void initialCancel() 
+ void invalidDeferredRequest() 
+ void setSubscriptionAfterCancel() 
+ void cancelAfterPoll() 
+ void errorAfterCancel() 
+ void cancelAfterError() 
+ void offerDifferentSubscription() 
 
}
class io.reactivex.internal.subscriptions.QueueSubscriptionTest {
 + int requestFusion(int mode) 
+ Integer poll() 
+ boolean isEmpty() 
+ void clear() 
+ void request(long n) 
+ void cancel() 
+ void noOfferBasic() 
+ void noOfferBasicInt() 
+ void empty() 
 
}
class io.reactivex.internal.subscriptions.ScalarSubscription {
 + void request(long n) 
+ void cancel() 
+ boolean isCancelled() 
+ boolean offer(T e) 
+ boolean offer(T v1, T v2) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ int requestFusion(int mode) 
~    final T value;
 
}
class io.reactivex.internal.subscriptions.ScalarSubscriptionTest {
 + void badRequest() 
+ void noOffer() 
 
}
class io.reactivex.internal.subscriptions.SubscriptionArbiter {
 + final void setSubscription(Subscription s) 
+ final void request(long n) 
+ final void produced(long n) 
+ void cancel() 
~final void drain() 
~final void drainLoop() 
+ final boolean isUnbounded() 
+ final boolean isCancelled() 
~    final AtomicReference<Subscription> missedSubscription;
~    final AtomicLong missedRequested;
~    final AtomicLong missedProduced;
    # boolean unbounded;
 
}
class io.reactivex.internal.subscriptions.SubscriptionArbiterTest {
 + void setSubscriptionMissed() 
+ void invalidDeferredRequest() 
+ void unbounded() 
+ void cancelled() 
+ void drainUnbounded() 
+ void drainMissedRequested() 
+ void drainMissedRequestedProduced() 
+ void drainMissedRequestedMoreProduced() 
+ void missedSubscriptionNoPrior() 
 
}
class io.reactivex.internal.subscriptions.SubscriptionHelper {
 + void request(long n) 
+ void cancel() 
+ {static} boolean validate(Subscription current, Subscription next) 
+ {static} void reportSubscriptionSet() 
+ {static} boolean validate(long n) 
+ {static} void reportMoreProduced(long n) 
+ {static} boolean isCancelled(Subscription s) 
+ {static} boolean set(AtomicReference<Subscription> field, Subscription s) 
+ {static} boolean setOnce(AtomicReference<Subscription> field, Subscription s) 
+ {static} boolean replace(AtomicReference<Subscription> field, Subscription s) 
+ {static} boolean cancel(AtomicReference<Subscription> field) 
+ {static} boolean deferredSetOnce(AtomicReference<Subscription> field, AtomicLong requested,
            Subscription s) 
+ {static} void deferredRequest(AtomicReference<Subscription> field, AtomicLong requested, long n) 
 
}Test
class io.reactivex.internal.util.AppendOnlyLinkedArrayList {
 + void add(T value) 
+ void setFirst(T value) 
+ void forEachWhile(NonThrowingPredicate<? super T> consumer) 
~    final int capacity;
~    final Object[] head;
 
}
class io.reactivex.internal.util.AtomicThrowable {
 + boolean addThrowable(Throwable t) 
+ Throwable terminate() 
+ boolean isTerminated() 
 
}
class io.reactivex.internal.util.AtomicThrowableTest {
 + void isTerminated() 
 
}
class io.reactivex.internal.util.BackpressureHelper {
 + {static} long addCap(long a, long b) 
+ {static} long multiplyCap(long a, long b) 
+ {static} long add(AtomicLong requested, long n) 
+ {static} long addCancel(AtomicLong requested, long n) 
+ {static} long produced(AtomicLong requested, long n) 
+ {static} long producedCancel(AtomicLong requested, long n) 
 
}
class io.reactivex.internal.util.BackpressureHelperTest {
 + void constructorShouldBePrivate() 
+ void testAddCap() 
+ void testMultiplyCap() 
+ void producedMore() 
+ void producedMoreCancel() 
+ void requestProduceRace() 
+ void run() 
+ void requestCancelProduceRace() 
+ void utilityClass() 
+ void capped() 
+ void multiplyCap() 
 
}
class io.reactivex.internal.util.BlockingHelper {
 + {static} void awaitForComplete(CountDownLatch latch, Disposable subscription) 
+ {static} void verifyNonBlocking() 
 
}
class io.reactivex.internal.util.BlockingHelperTest {
 + void emptyEnum() 
+ void interrupted() 
+ void unblock() 
 
}
class io.reactivex.internal.util.BlockingIgnoringReceiver {
 + void accept(Throwable e) 
+ void run() 
    + Throwable error;
 
}
class io.reactivex.internal.util.ConnectConsumer {
 + void accept(Disposable t) 
    + Disposable disposable;
 
}
class io.reactivex.internal.util.CrashingIterable {
 + Iterator<Integer> iterator() 
+ boolean hasNext() 
+ Integer next() 
+ void remove() 
~    final int crashOnHasNext;
~    final int crashOnNext;
 
}
class io.reactivex.internal.util.CrashingMappedIterable {
 + Iterator<T> iterator() 
+ boolean hasNext() 
+ T next() 
+ void remove() 
~    final int crashOnHasNext;
~    final int crashOnNext;
 
}
class io.reactivex.internal.util.EndConsumerHelper {
 + {static} boolean validate(Disposable upstream, Disposable next, Class<?> observer) 
+ {static} boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) 
+ {static} boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) 
+ {static} boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) 
+ {static} String composeMessage(String consumer) 
+ {static} void reportDoubleSubscription(Class<?> consumer) 
 
}
class io.reactivex.internal.util.EndConsumerHelperTest {
 + void before() 
+ void after() 
+ void utilityClass() 
+ void checkDoubleDefaultSubscriber() 
+ void onError(Throwable t) 
+ void onComplete() 
+ void onNext(Integer t) 
+ void checkDoubleDefaultSubscriberNonAnonymous() 
+ void checkDoubleDisposableSubscriber() 
+ void checkDoubleResourceSubscriber() 
+ void checkDoubleDefaultObserver() 
+ void checkDoubleDisposableObserver() 
+ void checkDoubleResourceObserver() 
+ void checkDoubleDisposableSingleObserver() 
+ void checkDoubleResourceSingleObserver() 
+ void checkDoubleDisposableMaybeObserver() 
+ void checkDoubleResourceMaybeObserver() 
+ void checkDoubleDisposableCompletableObserver() 
+ void checkDoubleResourceCompletableObserver() 
+ void validateDisposable() 
+ void validateSubscription() 
 
}
class io.reactivex.internal.util.ExceptionHelper {
 + {static} RuntimeException wrapOrThrow(Throwable error) 
+ {static} List<Throwable> flatten(Throwable t) 
+ Throwable fillInStackTrace() 
 
}
class io.reactivex.internal.util.ExceptionHelperTest {
 + void utilityClass() 
+ void addRace() 
 
}
class io.reactivex.internal.util.HalfSerializer {
 + {static} void onError(Subscriber<?> subscriber, Throwable ex,
            AtomicInteger wip, AtomicThrowable error) 
+ {static} void onComplete(Subscriber<?> subscriber, AtomicInteger wip, AtomicThrowable error) 
+ {static} void onError(Observer<?> observer, Throwable ex,
            AtomicInteger wip, AtomicThrowable error) 
+ {static} void onComplete(Observer<?> observer, AtomicInteger wip, AtomicThrowable error) 
 
}
class io.reactivex.internal.util.HalfSerializerObserverTest {
 + void reentrantOnNextOnNext() 
+ void onSubscribe(Disposable s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void reentrantOnNextOnError() 
+ void reentrantOnNextOnComplete() 
+ void reentrantErrorOnError() 
+ void onNextOnCompleteRace() 
+ void run() 
+ void onErrorOnCompleteRace() 
 
}
class io.reactivex.internal.util.HalfSerializerSubscriberTest {
 + void utilityClass() 
+ void reentrantOnNextOnNext() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void reentrantOnNextOnError() 
+ void reentrantOnNextOnComplete() 
+ void reentrantErrorOnError() 
+ void onNextOnCompleteRace() 
+ void run() 
+ void onErrorOnCompleteRace() 
 
}
class io.reactivex.internal.util.LinkedArrayList {
 + void add(Object o) 
+ Object[] head() 
+ int size() 
+ String toString() 
~    final int capacityHint;
 
}
class io.reactivex.internal.util.MergerBiFunction {
 + List<T> apply(List<T> a, List<T> b) 
 
}
class io.reactivex.internal.util.MiscUtilTest {
 + void pow2UtilityClass() 
+ void isPowerOf2() 
+ void hashMapSupplier() 
+ void arrayListSupplier() 
+ void errorModeEnum() 
+ void linkedArrayList() 
+ void appendOnlyLinkedArrayListForEachWhile() 
+ void appendOnlyLinkedArrayListForEachWhilePreGrow() 
+ void appendOnlyLinkedArrayListForEachWhileExact() 
+ void appendOnlyLinkedArrayListForEachWhileAll() 
+ void appendOnlyLinkedArrayListForEachWhileBigger() 
+ void appendOnlyLinkedArrayListForEachWhileBiPreGrow() 
+ void appendOnlyLinkedArrayListForEachWhileBiExact() 
+ void appendOnlyLinkedArrayListForEachWhileBiAll() 
+ void queueDrainHelperUtility() 
 
}
class io.reactivex.internal.util.NotificationLite {
 + String toString() 
+ int hashCode() 
+ boolean equals(Object obj) 
+ {static} Object complete() 
+ {static} Object error(Throwable e) 
+ {static} Object subscription(Subscription s) 
+ {static} Object disposable(Disposable d) 
+ {static} boolean isComplete(Object o) 
+ {static} boolean isError(Object o) 
+ {static} boolean isSubscription(Object o) 
+ {static} boolean isDisposable(Object o) 
+ {static} Throwable getError(Object o) 
+ {static} Subscription getSubscription(Object o) 
+ {static} Disposable getDisposable(Object o) 
~        final Throwable e;
~        final Subscription s;
~        final Disposable d;
 
}Test
class io.reactivex.internal.util.ObservableToFlowabeTestSync {
 ~{static} List<String> readAllLines(File f) 
~{static} void list(String basepath, String basepackage) 
+ {static} void main(String[] args) 
 
}
class io.reactivex.internal.util.OpenHashSet {
 + boolean add(T value) 
+ boolean remove(T value) 
~{static} int mix(int x) 
+ Object[] keys() 
+ int size() 
~    final float loadFactor;
 
}
class io.reactivex.internal.util.OpenHashSetTest {
 + int hashCode() 
+ boolean equals(Object o) 
+ void addRemoveCollision() 
 
}
class io.reactivex.internal.util.Pow2 {
 + {static} int roundToPowerOfTwo(final int value) 
+ {static} boolean isPowerOfTwo(final int value) 
 
}
class io.reactivex.internal.util.QueueDrain {
  
}Helper
class io.reactivex.internal.util.QueueDrainHelper {
 + {static} void request(Subscription s, int prefetch) 
~{static} boolean isCancelled(BooleanSupplier cancelled) 
 
}Test
class io.reactivex.internal.util.SorterFunction {
 + List<T> apply(List<T> t) 
 
}
class io.reactivex.internal.util.TestingHelper {
 + void accept(T t) 
+ List<T> call() 
+ void accept(Object t1, Object t2) 
 
}
class io.reactivex.internal.util.VolatileSizeArrayList {
 + int size() 
+ boolean isEmpty() 
+ boolean contains(Object o) 
+ Iterator<T> iterator() 
+ Object[] toArray() 
+ boolean add(T e) 
+ boolean remove(Object o) 
+ boolean containsAll(Collection<?> c) 
+ boolean addAll(Collection<? extends T> c) 
+ boolean addAll(int index, Collection<? extends T> c) 
+ boolean removeAll(Collection<?> c) 
+ boolean retainAll(Collection<?> c) 
+ void clear() 
+ T get(int index) 
+ T set(int index, T element) 
+ void add(int index, T element) 
+ T remove(int index) 
+ int indexOf(Object o) 
+ int lastIndexOf(Object o) 
+ ListIterator<T> listIterator() 
+ ListIterator<T> listIterator(int index) 
+ List<T> subList(int fromIndex, int toIndex) 
+ boolean equals(Object obj) 
+ int hashCode() 
+ String toString() 
~    final ArrayList<T> list;
 
}
class io.reactivex.internal.util.VolatileSizeArrayListTest {
 + void normal() 
 
}
class io.reactivex.maybe.MaybeCreateTest {
 + void nullArgument() 
+ void basic() 
+ void basicWithCancellable() 
+ void basicWithError() 
+ void basicWithCompletion() 
+ void unsafeCreate() 
 
}
class io.reactivex.maybe.MaybeTest {
 + void fromFlowableEmpty() 
+ void fromFlowableJust() 
+ void fromFlowableError() 
+ void fromFlowableValueAndError() 
+ void fromFlowableMany() 
+ void fromFlowableDisposeComposesThrough() 
+ void fromObservableEmpty() 
+ void fromObservableJust() 
+ void fromObservableError() 
+ void fromObservableValueAndError() 
+ void fromObservableMany() 
+ void fromObservableDisposeComposesThrough() 
+ void fromObservableDisposeComposesThroughImmediatelyCancelled() 
+ void just() 
+ void justNull() 
+ void empty() 
+ void never() 
+ void errorNull() 
+ void errorCallableNull() 
+ void error() 
+ void errorCallable() 
+ void errorCallableReturnsNull() 
+ void wrapCustom() 
+ void wrapMaybe() 
+ void wrapNull() 
+ void emptySingleton() 
+ void neverSingleton() 
+ void liftNull() 
+ void liftJust() 
+ void liftThrows() 
+ void deferNull() 
+ void deferThrows() 
+ void deferReturnsNull() 
+ void defer() 
+ void flowableMaybeFlowable() 
+ void obervableMaybeobervable() 
+ void singleMaybeSingle() 
+ void completableMaybeCompletable() 
+ void unsafeCreate() 
+ void unsafeCreateNull() 
+ void to() 
+ void toNull() 
+ void compose() 
+ void composeNull() 
+ void mapNull() 
+ void mapReturnNull() 
+ void mapThrows() 
+ void map() 
+ void filterNull() 
+ void filterThrows() 
+ void filterTrue() 
+ void filterFalse() 
+ void filterEmpty() 
+ void singleFilterNull() 
+ void singleFilterThrows() 
+ void singleFilterTrue() 
+ void singleFilterFalse() 
+ void cast() 
+ void observeOnNull() 
+ void subscribeOnNull() 
+ void observeOnSuccess() 
+ void observeOnError() 
+ void observeOnComplete() 
+ void observeOnDispose2() 
+ void observeOnDoubleSubscribe() 
+ void subscribeOnSuccess() 
+ void observeOnErrorThread() 
+ void accept(Throwable e) 
+ void observeOnCompleteThread() 
+ void run() 
+ void subscribeOnError() 
+ void subscribeOnComplete() 
+ void fromAction() 
+ void fromActionThrows() 
+ void fromRunnable() 
+ void fromRunnableThrows() 
+ void fromCallableThrows() 
+ void doOnSuccess() 
+ void accept(Integer v) 
+ void doOnSuccessEmpty() 
+ void doOnSuccessThrows() 
+ void doOnSubscribe() 
+ void accept(Disposable v) 
+ void doOnSubscribeThrows() 
+ void doOnCompleteThrows() 
+ void doOnDispose() 
+ void doOnDisposeThrows() 
+ void observeOnDispose() 
+ void doAfterTerminateSuccess() 
+ void doAfterTerminateError() 
+ void accept(Object v) 
+ void doAfterTerminateComplete() 
+ void sourceThrowsNPE() 
+ void sourceThrowsIAE() 
+ void flatMap() 
+ void concatMap() 
+ void flatMapEmpty() 
+ void flatMapError() 
+ void flatMapNotifySuccess() 
+ MaybeSource<Integer> apply(Throwable v) 
+ MaybeSource<Integer> call() 
+ void flatMapNotifyError() 
+ void flatMapNotifyComplete() 
+ void ignoreElementSuccess() 
+ void ignoreElementError() 
+ void ignoreElementComplete() 
+ void ignoreElementSuccessMaybe() 
+ void ignoreElementErrorMaybe() 
+ void ignoreElementCompleteMaybe() 
+ void singleToMaybe() 
+ void singleToMaybeError() 
+ void completableToMaybe() 
+ void completableToMaybeError() 
+ void emptyToSingle() 
+ void errorToSingle() 
+ void emptyToCompletable() 
+ void errorToCompletable() 
+ void concat2() 
+ void concat2Empty() 
+ void concat2Backpressured() 
+ void concat2BackpressuredNonEager() 
+ void concat3() 
+ void concat3Empty() 
+ void concat3Mixed1() 
+ void concat3Mixed2() 
+ void concat3Backpressured() 
+ void concatArrayZero() 
+ void concatArrayOne() 
+ void concat4() 
+ void concatIterable() 
+ void concatIterableEmpty() 
+ void concatIterableBackpressured() 
+ void concatIterableBackpressuredNonEager() 
+ void concatIterableZero() 
+ void concatIterableOne() 
+ void concatPublisher() 
+ void concatPublisherPrefetch() 
+ void nullArgument() 
+ void basic() 
+ void basicWithError() 
+ void basicWithComplete() 
+ void unsafeCreateWithMaybe() 
+ void maybeToPublisherEnum() 
+ void ambArrayOneIsNull() 
+ void ambArrayEmpty() 
+ void ambArrayOne() 
+ void ambWithOrder() 
+ void ambIterableOrder() 
+ void ambArrayOrder() 
+ void ambArray1SignalsSuccess() 
+ void ambArray2SignalsSuccess() 
+ void ambArray1SignalsError() 
+ void ambArray2SignalsError() 
+ void ambArray1SignalsComplete() 
+ void ambArray2SignalsComplete() 
+ void ambIterable1SignalsSuccess() 
+ void ambIterable2SignalsSuccess() 
+ void ambIterable2SignalsSuccessWithOverlap() 
+ void ambIterable1SignalsError() 
+ void ambIterable2SignalsError() 
+ void ambIterable2SignalsErrorWithOverlap() 
+ void ambIterable1SignalsComplete() 
+ void ambIterable2SignalsComplete() 
+ void ambIterableNull() 
+ void ambIterableIteratorNull() 
+ void ambIterableOneIsNull() 
+ void ambIterableEmpty() 
+ void ambIterableOne() 
+ void mergeArray() 
+ void merge2() 
+ void merge3() 
+ void merge4() 
+ void merge4Take2() 
+ void mergeArrayBackpressured() 
+ void mergeArrayBackpressuredMixed1() 
+ void mergeArrayBackpressuredMixed2() 
+ void mergeArrayBackpressuredMixed3() 
+ void mergeArrayFused() 
+ void mergeArrayFusedRace() 
+ void mergeArrayZero() 
+ void mergeArrayOne() 
+ void mergePublisher() 
+ void mergePublisherMaxConcurrent() 
+ void mergeMaybe() 
+ void mergeIterable() 
+ void mergeALot() 
+ void mergeALotLastEmpty() 
+ void mergeALotFused() 
+ void mergeErrorSuccess() 
+ void mergeSuccessError() 
+ void subscribeZero() 
+ void subscribeZeroError() 
+ void subscribeToOnSuccess() 
+ void subscribeToOnError() 
+ void subscribeToOnComplete() 
+ void subscribeWith() 
+ void onSuccess(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void doOnEventSuccess() 
+ void doOnEventError() 
+ void doOnEventComplete() 
+ void doOnEventNull() 
+ void doOnEventSuccessThrows() 
+ void doOnEventErrorThrows() 
+ void doOnEventCompleteThrows() 
+ void concatArrayDelayError() 
+ void concatIterableDelayError() 
+ void concatPublisherDelayError() 
+ void concatEagerArray() 
+ void concatEagerIterable() 
+ void concatEagerPublisher() 
~{static} Future<Integer> emptyFuture() 
+ void fromFuture() 
+ void mergeArrayDelayError() 
+ void mergeIterableDelayError() 
+ void mergePublisherDelayError() 
+ void mergeDelayError2() 
+ void mergeDelayError3() 
+ void mergeDelayError4() 
+ void sequenceEqual() 
+ boolean test(Object t1, Object t2) 
+ void timer() 
+ void blockingGet() 
+ void toSingleDefault() 
+ void flatMapContinuation() 
+ Completable apply(Integer v) 
+ Publisher<Integer> apply(Integer v) 
+ Observable<Integer> apply(Integer v) 
+ void using() 
+ void accept(Integer d) 
+ String apply(Integer v) 
+ void usingNonEager() 
+ String apply(Object[] a) 
+ void zipArray() 
+ void zipIterable() 
+ void zip2() 
+ void zipWith() 
+ void zip3() 
+ void zip4() 
+ void zip5() 
+ void zip6() 
+ void zip7() 
+ void zip8() 
+ void zip9() 
+ void ambWith1SignalsSuccess() 
+ void ambWith2SignalsSuccess() 
+ void zipIterableObject() 
~{static} long usedMemoryNow() 
+ void onTerminateDetach() 
+ void onSuccess(Object value) 
+ void repeat() 
+ Publisher<Object> apply(Flowable<Object> v) 
+ void retry() 
+ boolean getAsBoolean() 
+ Publisher<Object> apply(Flowable<? extends Throwable> v) 
+ void onErrorResumeNextEmpty() 
+ void onErrorResumeNextValue() 
+ void onErrorResumeNextError() 
+ void valueConcatWithValue() 
+ void errorConcatWithValue() 
+ void valueConcatWithError() 
+ void emptyConcatWithValue() 
+ void emptyConcatWithError() 
 
}
class io.reactivex.maybe.MaybeTimerTest {
 + void timer() 
 
}
class io.reactivex.observable.ObservableCombineLatestTests {
 + void testCovarianceOfCombineLatest() 
+ ExtendedResult apply(Media m, Rating r) 
+ void accept(Result t1) 
+ void accept(ExtendedResult t1) 
+ void testNullEmitting() 
+ void accept(Boolean aBoolean) 
 
}
class io.reactivex.observable.ObservableConcatTests {
 + void testConcatSimple() 
+ void testConcatWithObservableOfObservable() 
+ void testConcatWithIterableOfObservable() 
+ void testConcatCovariance() 
+ void testConcatCovariance2() 
+ void testConcatCovariance3() 
+ void testConcatCovariance4() 
 
}
class io.reactivex.observable.ObservableCovarianceTest {
 + void testCovarianceOfFrom() 
+ void testSortedList() 
+ void testGroupByCompose() 
+ void accept(GroupedObservable<Object, Movie> g) 
+ Observable<String> apply(GroupedObservable<Object, Movie> g) 
+ Observable<Movie> apply(Observable<Movie> m) 
+ String apply(Movie v) 
+ void testCovarianceOfCompose() 
+ void testCovarianceOfCompose2() 
+ void testCovarianceOfCompose3() 
+ void testCovarianceOfCompose4() 
+ void testComposeWithDeltaLogic() 
+ Observable<Movie> apply(List<List<Movie>> listOfLists) 
+ Observable<Movie> apply(Observable<List<Movie>> movieList) 
 
}
class io.reactivex.observable.ObservableDoOnTest {
 + void testDoOnEach() 
+ void testDoOnError() 
+ void testDoOnCompleted() 
+ void doOnTerminateComplete() 
+ void doOnTerminateError() 
 
}
class io.reactivex.observable.ObservableErrorHandlingTests {
 + void testOnNextError() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testOnNextErrorAcrossThread() 
 
}
class io.reactivex.observable.ObservableEventStream {
 + {static} Observable<Event> getEventStream(final String type, final int numInstances) 
+ {static} Event randomEvent(String type, int numInstances) 
- {static} int randomIntFrom0to(int max) 
+ void accept(Emitter<Event> s) 
        - final int numInstances;
        - final String type;
        + final String type;
        + final String instanceId;
 
}
class io.reactivex.observable.ObservableEventStream.Event
class io.reactivex.observable.ObservableFuseableTest {
 + void syncRange() 
+ void syncArray() 
+ void syncIterable() 
+ void syncRangeHidden() 
+ void syncArrayHidden() 
+ void syncIterableHidden() 
 
}
class io.reactivex.observable.ObservableGroupByTests {
 + void testTakeUnsubscribesOnGroupBy() 
+ void accept(GroupedObservable<String, Event> v) 
+ void testTakeUnsubscribesOnFlatMapOfGroupBy() 
+ Observable<Object> apply(GroupedObservable<String, Event> g) 
+ void accept(Object pv) 
 
}
class io.reactivex.observable.ObservableMergeTests {
 + void testCovarianceOfMerge() 
+ void testMergeCovariance() 
+ void testMergeCovariance2() 
+ void testMergeCovariance3() 
+ void testMergeCovariance4() 
 
}
class io.reactivex.observable.ObservableNullTests {
 + void ambVarargsNull() 
+ void ambVarargsOneIsNull() 
+ void ambIterableNull() 
+ void ambIterableIteratorNull() 
+ void ambIterableOneIsNull() 
+ void combineLatestVarargsNull() 
+ void combineLatestVarargsOneIsNull() 
+ void combineLatestIterableNull() 
+ void combineLatestIterableIteratorNull() 
+ Object apply(Object[] v) 
+ void combineLatestIterableOneIsNull() 
+ void combineLatestVarargsFunctionNull() 
+ void combineLatestVarargsFunctionReturnsNull() 
+ void combineLatestIterableFunctionNull() 
+ void combineLatestIterableFunctionReturnsNull() 
+ void combineLatestDelayErrorVarargsNull() 
+ void combineLatestDelayErrorVarargsOneIsNull() 
+ void combineLatestDelayErrorIterableNull() 
+ void combineLatestDelayErrorIterableIteratorNull() 
+ void combineLatestDelayErrorIterableOneIsNull() 
+ void combineLatestDelayErrorVarargsFunctionNull() 
+ void combineLatestDelayErrorVarargsFunctionReturnsNull() 
+ void combineLatestDelayErrorIterableFunctionNull() 
+ void combineLatestDelayErrorIterableFunctionReturnsNull() 
+ void concatIterableNull() 
+ void concatIterableIteratorNull() 
+ void concatIterableOneIsNull() 
+ void concatObservableNull() 
+ void concatArrayNull() 
+ void concatArrayOneIsNull() 
+ void createNull() 
+ void deferFunctionNull() 
+ void deferFunctionReturnsNull() 
+ void errorFunctionNull() 
+ void errorFunctionReturnsNull() 
+ void errorThrowableNull() 
+ void fromArrayNull() 
+ void fromArrayOneIsNull() 
+ void fromCallableNull() 
+ void fromCallableReturnsNull() 
+ void fromFutureNull() 
+ void fromFutureReturnsNull() 
+ void fromFutureTimedFutureNull() 
+ void fromFutureTimedUnitNull() 
+ void fromFutureTimedSchedulerNull() 
+ void fromFutureTimedReturnsNull() 
+ void fromFutureSchedulerNull() 
+ void fromIterableNull() 
+ void fromIterableIteratorNull() 
+ void fromIterableValueNull() 
+ void generateConsumerNull() 
+ void generateConsumerEmitsNull() 
+ void generateStateConsumerInitialStateNull() 
+ void generateStateFunctionInitialStateNull() 
+ void generateStateConsumerNull() 
+ void generateConsumerStateNullAllowed() 
+ Integer call() 
+ void generateFunctionStateNullAllowed() 
+ Object apply(Object s, Emitter<Object> o) 
+ void generateConsumerDisposeNull() 
+ void generateFunctionDisposeNull() 
+ void intervalUnitNull() 
+ void intervalSchedulerNull() 
+ void intervalPeriodUnitNull() 
+ void intervalPeriodSchedulerNull() 
+ void intervalRangeUnitNull() 
+ void intervalRangeSchedulerNull() 
+ void justNull() 
+ void mergeIterableNull() 
+ void mergeIterableIteratorNull() 
+ void mergeIterableOneIsNull() 
+ void mergeArrayNull() 
+ void mergeArrayOneIsNull() 
+ void mergeDelayErrorIterableNull() 
+ void mergeDelayErrorIterableIteratorNull() 
+ void mergeDelayErrorIterableOneIsNull() 
+ void mergeDelayErrorArrayNull() 
+ void mergeDelayErrorArrayOneIsNull() 
+ void sequenceEqualFirstNull() 
+ void sequenceEqualSecondNull() 
+ void sequenceEqualComparatorNull() 
+ void switchOnNextNull() 
+ void timerUnitNull() 
+ void timerSchedulerNull() 
+ void usingResourceSupplierNull() 
+ void accept(Object d) 
+ void usingObservableSupplierNull() 
+ void usingObservableSupplierReturnsNull() 
+ Observable<Object> apply(Object d) 
+ void usingDisposeNull() 
+ Observable<Integer> apply(Object d) 
+ void zipIterableNull() 
+ void zipIterableIteratorNull() 
+ void zipIterableFunctionNull() 
+ void zipIterableFunctionReturnsNull() 
+ void zipObservableNull() 
+ void zipObservableFunctionNull() 
+ void zipObservableFunctionReturnsNull() 
+ void zipIterable2Null() 
+ void zipIterable2IteratorNull() 
+ Object apply(Object[] a) 
+ void zipIterable2FunctionNull() 
+ void zipIterable2FunctionReturnsNull() 
+ void allPredicateNull() 
+ void ambWithNull() 
+ void anyPredicateNull() 
+ void bufferSupplierNull() 
+ void bufferSupplierReturnsNull() 
+ void bufferTimedUnitNull() 
+ void bufferTimedSchedulerNull() 
+ void bufferTimedSupplierNull() 
+ void bufferTimedSupplierReturnsNull() 
+ void bufferOpenCloseOpenNull() 
+ void bufferOpenCloseCloseNull() 
+ void bufferOpenCloseCloseReturnsNull() 
+ void bufferBoundaryNull() 
+ void bufferBoundarySupplierNull() 
+ void bufferBoundarySupplierReturnsNull() 
+ void bufferBoundarySupplier2Null() 
+ void bufferBoundarySupplier2ReturnsNull() 
+ void bufferBoundarySupplier2SupplierNull() 
+ void bufferBoundarySupplier2SupplierReturnsNull() 
+ Collection<Integer> call() 
+ void castNull() 
+ void collectInitialSupplierNull() 
+ void collectInitialSupplierReturnsNull() 
+ void accept(Object a, Integer b) 
+ void collectInitialCollectorNull() 
+ void collectIntoInitialNull() 
+ void collectIntoCollectorNull() 
+ void composeNull() 
+ void concatMapNull() 
+ void concatMapReturnsNull() 
+ void concatMapIterableNull() 
+ void concatMapIterableReturnNull() 
+ void concatMapIterableIteratorNull() 
+ void concatWithNull() 
+ void containsNull() 
+ void debounceFunctionNull() 
+ void debounceFunctionReturnsNull() 
+ void debounceTimedUnitNull() 
+ void debounceTimedSchedulerNull() 
+ void defaultIfEmptyNull() 
+ void delayWithFunctionNull() 
+ void delayWithFunctionReturnsNull() 
+ void delayTimedUnitNull() 
+ void delayTimedSchedulerNull() 
+ void delaySubscriptionTimedUnitNull() 
+ void delaySubscriptionTimedSchedulerNull() 
+ void delaySubscriptionOtherNull() 
+ void delaySubscriptionFunctionNull() 
+ void delayBothInitialSupplierNull() 
+ void delayBothInitialSupplierReturnsNull() 
+ void delayBothItemSupplierNull() 
+ void delayBothItemSupplierReturnsNull() 
+ void distinctFunctionNull() 
+ void distinctSupplierNull() 
+ void distinctSupplierReturnsNull() 
+ Collection<Object> call() 
+ void distinctFunctionReturnsNull() 
+ void distinctUntilChangedFunctionNull() 
+ void distinctUntilChangedBiPredicateNull() 
+ void distinctUntilChangedFunctionReturnsNull() 
+ void doOnDisposeNull() 
+ void doOnCompleteNull() 
+ void doOnEachSupplierNull() 
+ void doOnEachSubscriberNull() 
+ void doOnErrorNull() 
+ void doOnLifecycleOnSubscribeNull() 
+ void doOnLifecycleOnDisposeNull() 
+ void doOnNextNull() 
+ void doOnSubscribeNull() 
+ void doOnTerminatedNull() 
+ void elementAtNull() 
+ void filterNull() 
+ void doAfterTerminateNull() 
+ void firstNull() 
+ void flatMapNull() 
+ void flatMapFunctionReturnsNull() 
+ void flatMapNotificationOnNextNull() 
+ Observable<Integer> call() 
+ void flatMapNotificationOnNextReturnsNull() 
+ Observable<Integer> apply(Throwable e) 
+ void flatMapNotificationOnErrorNull() 
+ void flatMapNotificationOnErrorReturnsNull() 
+ void flatMapNotificationOnCompleteNull() 
+ void flatMapNotificationOnCompleteReturnsNull() 
+ void flatMapCombinerMapperNull() 
+ void flatMapCombinerMapperReturnsNull() 
+ Object apply(Integer a, Object b) 
+ void flatMapCombinerCombinerNull() 
+ void flatMapCombinerCombinerReturnsNull() 
+ Object apply(Integer a, Integer b) 
+ void flatMapIterableMapperNull() 
+ void flatMapIterableMapperReturnsNull() 
+ void flatMapIterableMapperIteratorNull() 
+ void flatMapIterableMapperIterableOneNull() 
+ void flatMapIterableCombinerNull() 
+ void flatMapIterableCombinerReturnsNull() 
+ void forEachNull() 
+ void forEachWhileNull() 
+ void forEachWhileOnErrorNull() 
+ void forEachWhileOnCompleteNull() 
+ void accept(Throwable e) 
+ void groupByNull() 
+ void groupByKeyNull() 
+ void groupByValueNull() 
+ void groupByValueReturnsNull() 
+ Object apply(Integer v) 
+ void lastNull() 
+ void liftNull() 
+ void liftReturnsNull() 
+ void mapNull() 
+ void mapReturnsNull() 
+ void mergeWithNull() 
+ void observeOnNull() 
+ void ofTypeNull() 
+ void onErrorResumeNextFunctionNull() 
+ void onErrorResumeNextFunctionReturnsNull() 
+ void onErrorResumeNextObservableNull() 
+ void onErrorReturnFunctionNull() 
+ void onErrorReturnValueNull() 
+ void onErrorReturnFunctionReturnsNull() 
+ void onExceptionResumeNext() 
+ void publishFunctionNull() 
+ void publishFunctionReturnsNull() 
+ void reduceFunctionNull() 
+ void reduceFunctionReturnsNull() 
+ void reduceSeedNull() 
+ void reduceSeedFunctionNull() 
+ void reduceSeedFunctionReturnsNull() 
+ void reduceWithSeedNull() 
+ void reduceWithSeedReturnsNull() 
+ Object apply(Object a, Integer b) 
+ void repeatUntilNull() 
+ void repeatWhenNull() 
+ void repeatWhenFunctionReturnsNull() 
+ void replaySelectorNull() 
+ void replaySelectorReturnsNull() 
+ void replayBoundedSelectorNull() 
+ void replayBoundedSelectorReturnsNull() 
+ void replaySchedulerNull() 
+ void replayBoundedUnitNull() 
+ void replayBoundedSchedulerNull() 
+ void replayTimeBoundedSelectorNull() 
+ void replayTimeBoundedSelectorReturnsNull() 
+ void replaySelectorTimeBoundedUnitNull() 
+ void replaySelectorTimeBoundedSchedulerNull() 
+ void replayTimeSizeBoundedUnitNull() 
+ void replayTimeSizeBoundedSchedulerNull() 
+ void replayBufferSchedulerNull() 
+ void replayTimeBoundedUnitNull() 
+ void replayTimeBoundedSchedulerNull() 
+ void retryFunctionNull() 
+ void retryCountFunctionNull() 
+ void retryPredicateNull() 
+ void retryWhenFunctionNull() 
+ void retryWhenFunctionReturnsNull() 
+ void retryUntil() 
+ void safeSubscribeNull() 
+ void sampleUnitNull() 
+ void sampleSchedulerNull() 
+ void sampleObservableNull() 
+ void scanFunctionNull() 
+ void scanFunctionReturnsNull() 
+ void scanSeedNull() 
+ void scanSeedFunctionNull() 
+ void scanSeedFunctionReturnsNull() 
+ void scanSeedSupplierNull() 
+ void scanSeedSupplierReturnsNull() 
+ void scanSeedSupplierFunctionNull() 
+ void scanSeedSupplierFunctionReturnsNull() 
+ void singleNull() 
+ void skipTimedUnitNull() 
+ void skipTimedSchedulerNull() 
+ void skipLastTimedUnitNull() 
+ void skipLastTimedSchedulerNull() 
+ void skipUntilNull() 
+ void skipWhileNull() 
+ void startWithIterableNull() 
+ void startWithIterableIteratorNull() 
+ void startWithIterableOneNull() 
+ void startWithSingleNull() 
+ void startWithObservableNull() 
+ void startWithArrayNull() 
+ void startWithArrayOneNull() 
+ void subscribeOnNextNull() 
+ void subscribeOnErrorNull() 
+ void subscribeOnCompleteNull() 
+ void subscribeOnSubscribeNull() 
+ void subscribeNull() 
+ void subscribeOnNull() 
+ void switchIfEmptyNull() 
+ void switchMapNull() 
+ void switchMapFunctionReturnsNull() 
+ void takeTimedUnitNull() 
+ void takeTimedSchedulerNull() 
+ void takeLastTimedUnitNull() 
+ void takeLastSizeTimedUnitNull() 
+ void takeLastTimedSchedulerNull() 
+ void takeLastSizeTimedSchedulerNull() 
+ void takeUntilPredicateNull() 
+ void takeUntilObservableNull() 
+ void takeWhileNull() 
+ void throttleFirstUnitNull() 
+ void throttleFirstSchedulerNull() 
+ void throttleLastUnitNull() 
+ void throttleLastSchedulerNull() 
+ void throttleWithTimeoutUnitNull() 
+ void throttleWithTimeoutSchedulerNull() 
+ void timeIntervalUnitNull() 
+ void timeIntervalSchedulerNull() 
+ void timeoutSelectorNull() 
+ void timeoutSelectorReturnsNull() 
+ void timeoutSelectorOtherNull() 
+ void timeoutUnitNull() 
+ void timeouOtherNull() 
+ void timeouSchedulerNull() 
+ void timeoutFirstNull() 
+ void timeoutFirstItemNull() 
+ void timeoutFirstItemReturnsNull() 
+ void timestampUnitNull() 
+ void timestampSchedulerNull() 
+ void toNull() 
+ void toListNull() 
+ void toListSupplierReturnsNull() 
+ void toSortedListNull() 
+ void toMapKeyNull() 
+ void toMapValueNull() 
+ void toMapValueSelectorReturnsNull() 
+ void toMapMapSupplierNull() 
+ void toMapMapSupplierReturnsNull() 
+ void toMultimapKeyNull() 
+ void toMultimapValueNull() 
+ void toMultiMapValueSelectorReturnsNullAllowed() 
+ void toMultimapMapMapSupplierNull() 
+ void toMultimapMapSupplierReturnsNull() 
+ void toMultimapMapMapCollectionSupplierNull() 
+ Integer apply(Integer v) 
+ void toMultimapMapCollectionSupplierReturnsNull() 
+ Collection<Integer> apply(Integer v) 
+ void unsafeSubscribeNull() 
+ void unsubscribeOnNull() 
+ void windowTimedUnitNull() 
+ void windowSizeTimedUnitNull() 
+ void windowTimedSchedulerNull() 
+ void windowSizeTimedSchedulerNull() 
+ void windowBoundaryNull() 
+ void windowOpenCloseOpenNull() 
+ void windowOpenCloseCloseNull() 
+ void windowOpenCloseCloseReturnsNull() 
+ void windowBoundarySupplierNull() 
+ void windowBoundarySupplierReturnsNull() 
+ void withLatestFromOtherNull() 
+ void withLatestFromCombinerNull() 
+ void withLatestFromCombinerReturnsNull() 
+ void zipWithIterableNull() 
+ void zipWithIterableCombinerNull() 
+ void zipWithIterableCombinerReturnsNull() 
+ void zipWithIterableIteratorNull() 
+ void zipWithIterableOneIsNull() 
+ void zipWithObservableNull() 
+ void zipWithCombinerNull() 
+ void zipWithCombinerReturnsNull() 
 
}
class io.reactivex.observable.ObservableReduceTests {
 + void reduceIntsObservable() 
+ void reduceWithObjectsObservable() 
+ Movie apply(Movie t1, Movie t2) 
+ void reduceWithCovariantObjectsObservable() 
+ void reduceInts() 
+ void reduceWithObjects() 
+ void reduceWithCovariantObjects() 
+ void reduceCovariance() 
+ void libraryFunctionActingOnMovieObservables(Observable<Movie> obs) 
 
}
class io.reactivex.observable.ObservableScanTests {
 + void testUnsubscribeScan() 
+ void accept(HashMap<String, String> pv) 
 
}
class io.reactivex.observable.ObservableStartWithTests {
 + void startWith1() 
+ void startWithIterable() 
+ void startWithObservable() 
+ void startWithEmpty() 
 
}
class io.reactivex.observable.ObservableSubscriberTest {
 + void testOnStartCalledOnceViaSubscribe() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(Integer t) 
+ void testOnStartCalledOnceViaUnsafeSubscribe() 
+ void testOnStartCalledOnceViaLift() 
+ void subscribeConsumerConsumer() 
+ void accept(Throwable e) 
+ void subscribeConsumerConsumerWithError() 
+ void methodTestCancelled() 
+ void safeSubscriberAlreadySafe() 
+ void methodTestNoCancel() 
+ void pluginNull() 
# void subscribeActual(Observer<? super Integer> s) 
+ void subscribeActualThrows() 
 
}
class io.reactivex.observable.ObservableTest {
 + boolean test(Integer v) 
+ void before() 
+ void fromArray() 
+ void fromIterable() 
+ void fromArityArgs3() 
+ void fromArityArgs1() 
+ void testCreate() 
+ void testCountAFewItemsObservable() 
+ void testCountZeroItemsObservable() 
+ void testCountErrorObservable() 
+ void testCountAFewItems() 
+ void testCountZeroItems() 
+ void testCountError() 
+ void testTakeFirstWithPredicateOfSome() 
+ void testTakeFirstWithPredicateOfNoneMatchingThePredicate() 
+ void testTakeFirstOfSome() 
+ void testTakeFirstOfNone() 
+ void testFirstOfNone() 
+ void testFirstWithPredicateOfNoneMatchingThePredicate() 
+ void testReduce() 
+ void testReduceObservable() 
+ void testReduceWithEmptyObservable() 
+ void testReduceWithEmptyObservableAndSeed() 
+ void testReduceWithInitialValue() 
+ void testReduceWithInitialValueObservable() 
+ void testOnSubscribeFails() 
+ void testMaterializeDematerializeChaining() 
+ void testCustomObservableWithErrorInObserverAsynchronous() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void testCustomObservableWithErrorInObserverSynchronous() 
+ void testCustomObservableWithErrorInObservableSynchronous() 
+ void onComplete() 
+ void testPublishLast() 
+ void accept(String value) 
+ void testReplay() 
+ void accept(String v) 
+ void testCache() 
+ void testCacheWithCapacity() 
+ void testErrorThrownWithoutErrorHandlerSynchronous() 
+ void testErrorThrownWithoutErrorHandlerAsynchronous() 
+ void testTakeWithErrorInObserver() 
+ void testOfType() 
+ void testOfTypeWithPolymorphism() 
+ void testContainsObservable() 
+ void testContainsWithInexistenceObservable() 
+ void testContainsWithNullObservable() 
+ void testContainsWithEmptyObservableObservable() 
+ void testContains() 
+ void testContainsWithInexistence() 
+ void testContainsWithNull() 
+ void testContainsWithEmptyObservable() 
+ void testIgnoreElements() 
+ void testIgnoreElementsObservable() 
+ void testJustWithScheduler() 
+ void testStartWithWithScheduler() 
+ void testRangeWithScheduler() 
+ void testMergeWith() 
+ void testConcatWith() 
+ void testAmbWith() 
+ void testSubscribeWithoutOnError() 
+ void testTakeWhileToList() 
+ void accept(List<Boolean> booleans) 
+ void testCompose() 
+ void testErrorThrownIssue1685() 
+ void testEmptyIdentity() 
+ void testEmptyIsEmpty() 
+ void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain() 
+ void testForEachWithError() 
+ void testForEachWithNull() 
+ void testExtend() 
+ void testFlatMap() 
+ void singleDefault() 
+ void singleDefaultObservable() 
+ void zipIterableObject() 
+ void combineLatestObject() 
 
}
class io.reactivex.observable.ObservableThrottleLastTests {
 + void testThrottle() 
 
}
class io.reactivex.observable.ObservableThrottleWithTimeoutTests {
 + void testThrottle() 
+ void throttleFirstDefaultScheduler() 
 
}
class io.reactivex.observable.ObservableWindowTests {
 + void testWindow() 
+ void accept(List<Integer> xs) 
 
}
class io.reactivex.observable.ObservableZipTests {
 + void testZipObservableOfObservables() 
+ void accept(Object pv) 
+ void testCovarianceOfZip() 
+ void nonBlockingObservable() 
+ ExtendedResult apply(Media m, Rating r) 
+ void accept(Result t1) 
+ void accept(ExtendedResult t1) 
+ void zipWithDelayError() 
+ void zipWithDelayErrorBufferSize() 
 
}
class io.reactivex.observables.Observable
class io.reactivex.observers.BaseTestConsumer.TestWaitStrategy
class io.reactivex.observers.DisposableCompletableObserverTest {
 # void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void normal() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.DisposableMaybeObserverTest {
 # void onStart() 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void normal() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.DisposableObserverTest {
 # void onStart() 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void normal() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.DisposableSingleObserverTest {
 # void onStart() 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void normal() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.ResourceCompletableObserverTest {
 # void onStart() 
+ void onComplete() 
+ void onError(Throwable e) 
+ void nullResource() 
+ void addResources() 
+ void onCompleteCleansUp() 
+ void onErrorCleansUp() 
+ void normal() 
+ void error() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.ResourceMaybeObserverTest {
 # void onStart() 
+ void onSuccess(final T value) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void nullResource() 
+ void addResources() 
+ void onCompleteCleansUp() 
+ void onSuccessCleansUp() 
+ void onErrorCleansUp() 
+ void normal() 
+ void empty() 
+ void error() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.ResourceObserverTest {
 # void onStart() 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void nullResource() 
+ void addResources() 
+ void onCompleteCleansUp() 
+ void onErrorCleansUp() 
+ void normal() 
+ void error() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.ResourceSingleObserverTest {
 # void onStart() 
+ void onSuccess(final T value) 
+ void onError(Throwable e) 
+ void nullResource() 
+ void addResources() 
+ void onSuccessCleansUp() 
+ void onErrorCleansUp() 
+ void normal() 
+ void error() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.observers.SafeObserver {
 + void onSubscribe(@NonNull Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(@NonNull T t) 
+ void onError(@NonNull Throwable t) 
+ void onComplete() 
 
}
class io.reactivex.observers.SafeObserverTest {
 + void onNextFailure() 
+ void onNextFailureSafe() 
+ void onCompleteFailure() 
+ void onErrorFailure() 
+ void onErrorFailureSafe() 
+ void onErrorNotImplementedFailureSafe() 
+ void onNextOnErrorFailure() 
+ void onNextOnErrorFailureSafe() 
+ boolean isDisposed() 
+ void dispose() 
+ void onCompleteSuccessWithUnsubscribeFailure() 
+ void onErrorSuccessWithUnsubscribeFailure() 
+ void onErrorFailureWithUnsubscribeFailure() 
+ void onErrorNotImplementedFailureWithUnsubscribeFailure() 
- {static} Observer<String> OBSERVER_SUCCESS() 
+ void onError(Throwable e) 
+ void onNext(String args) 
- {static} Observer<String> OBSERVER_SUCCESS(final AtomicReference<Throwable> onError) 
- {static} Observer<String> OBSERVER_ONNEXT_FAIL(final AtomicReference<Throwable> onError) 
- {static} Observer<String> OBSERVER_ONNEXT_ONERROR_FAIL() 
- {static} Observer<String> OBSERVER_ONERROR_FAIL() 
- {static} Observer<String> OBSERVER_ONERROR_NOTIMPLEMENTED() 
- {static} Observer<String> OBSERVER_ONCOMPLETED_FAIL(final AtomicReference<Throwable> onError) 
+ void testOnCompletedThrows() 
+ void onComplete() 
+ void testActual() 
+ void onNextAfterComplete() 
+ void onNextNull() 
+ void onNextWithoutOnSubscribe() 
+ void onErrorWithoutOnSubscribe() 
+ void onCompleteWithoutOnSubscribe() 
+ void onNextNormal() 
+ void onSubscribe(Disposable d) 
+ void onNext(Object value) 
+ SafeObserver<Object> toSafe() 
+ CrashDummy assertError(Class<? extends Throwable> clazz) 
+ CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz) 
+ CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz, String message) 
+ void onNextOnErrorCrash() 
+ void onNextDisposeCrash() 
+ void onSubscribeTwice() 
+ void onSubscribeCrashes() 
+ void onSubscribeAndDisposeCrashes() 
+ void onNextOnSubscribeCrash() 
+ void onNextNullDisposeCrashes() 
+ void noSubscribeOnErrorCrashes() 
+ void onErrorNull() 
+ void onErrorNoSubscribeCrash() 
+ void onErrorNoSubscribeOnErrorCrash() 
+ void onCompleteteCrash() 
+ void onCompleteteNoSubscribeCrash() 
+ void onCompleteteNoSubscribeOnErrorCrash() 
 
}
class io.reactivex.observers.SerializedObserver {
 + void onSubscribe(@NonNull Disposable s) 
+ void dispose() 
+ boolean isDisposed() 
+ void onNext(@NonNull T t) 
+ void onError(@NonNull Throwable t) 
+ void onComplete() 
~    final boolean delayError;
 
}
class io.reactivex.observers.SerializedObserverTest {
 + void before() 
- Observer<String> serializedObserver(Observer<String> o) 
+ void testSingleThreadedBasic() 
+ void testMultiThreadedBasic() 
+ void testMultiThreadedWithNPE() 
+ void testMultiThreadedWithNPEinMiddle() 
+ void runOutOfOrderConcurrencyTest() 
+ void runConcurrencyTest() 
+ void testNotificationDelay() 
+ void onError(Throwable e) 
+ void onNext(String t) 
+ void testThreadStarvation() 
+ void onError(Throwable t) 
+ void onComplete() 
- {static} void waitOnThreads(Future<?>... futures) 
- {static} Observable<String> infinite(final AtomicInteger produced) 
+ void run() 
+ void onNext(String args) 
+ int assertEvents(TestConcurrencySubscriberEvent expectedEndingEvent) 
+ void subscribe(final Observer<? super String> observer) 
+ void waitToFinish() 
# void captureMaxThreads() 
+ void testSerializeNull() 
+ void testSerializeAllowsOnError() 
+ void testSerializeReentrantNullAndComplete() 
+ void testSerializeReentrantNullAndError() 
+ void testSerializeDrainPhaseThrows() 
+ void testErrorReentry() 
+ void testCompleteReentry() 
+ void dispose() 
+ void onCompleteRace() 
+ void onNextOnCompleteRace() 
+ void onNextOnErrorRace() 
+ void onNextOnErrorRaceDelayError() 
+ void startOnce() 
+ void onCompleteOnErrorRace() 
        - final CountDownLatch latch;
        - final Observer<String> observer;
        - final int numStringsToSend;
~        final AtomicInteger produced;
        - final CountDownLatch running;
        - final TestConcurrencySubscriberEvent event;
        - final int waitTime;
~        final String[] values;
        - Thread t;
 
}
class io.reactivex.observers.TestObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final boolean isCancelled() 
+ final void cancel() 
+ final void dispose() 
+ final boolean isDisposed() 
+ final boolean hasSubscription() 
+ final TestObserver<T> assertSubscribed() 
+ final TestObserver<T> assertNotSubscribed() 
+ final TestObserver<T> assertOf(Consumer<? super TestObserver<T>> check) 
~final TestObserver<T> setInitialFusionMode(int mode) 
~final TestObserver<T> assertFusionMode(int mode) 
~{static} String fusionModeToString(int mode) 
~final TestObserver<T> assertFuseable() 
~final TestObserver<T> assertNotFuseable() 
+ void onSuccess(T value) 
+ void onSubscribe(Disposable d) 
+ void onNext(Object t) 
    - QueueDisposable<T> qs;
 
}
class io.reactivex.observers.TestObserverTest {
 + void testAssert() 
+ void testAssertNotMatchCount() 
+ void testAssertNotMatchValue() 
+ void assertNeverAtNotMatchingValue() 
+ void assertNeverAtMatchingValue() 
+ void assertNeverAtMatchingPredicate() 
+ void assertNeverAtNotMatchingPredicate() 
+ void testAssertTerminalEventNotReceived() 
+ void testWrappingMock() 
+ void testWrappingMockWhenUnsubscribeInvolved() 
+ void testErrorSwallowed() 
+ void testGetEvents() 
+ void testNullExpected() 
+ void testNullActual() 
+ void testTerminalErrorOnce() 
+ void testTerminalCompletedOnce() 
+ void testTerminalOneKind() 
+ void createDelegate() 
+ void assertError() 
+ boolean test(Throwable t) 
+ void emptyObserverEnum() 
+ void valueAndClass() 
+ void assertFailure() 
+ void assertFuseable() 
+ void assertTerminated() 
+ void assertOf() 
+ void accept(TestObserver<Integer> f) 
+ void assertResult() 
+ void await() 
+ void errors() 
+ void onNext() 
+ void fusionModeToString() 
+ void multipleTerminals() 
+ void assertValue() 
+ void onNextMisbehave() 
+ void awaitTerminalEventInterrupt() 
+ void assertTerminated2() 
+ void onSubscribe() 
+ void assertValueSequence() 
+ void assertEmpty() 
+ void awaitDoneTimed() 
+ void assertNotSubscribed() 
+ void assertErrorMultiple() 
+ void testErrorInPredicate() 
+ void assertComplete() 
+ void completeWithoutOnSubscribe() 
+ void completeDelegateThrows() 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void errorDelegateThrows() 
+ void syncQueueThrows() 
+ void asyncQueueThrows() 
+ void completedMeansDisposed() 
+ void errorMeansDisposed() 
+ void asyncFusion() 
+ void assertValuePredicateEmpty() 
+ void assertValuePredicateMatch() 
+ void assertValuePredicateNoMatch() 
+ void assertValuePredicateMatchButMore() 
+ void assertValueAtPredicateEmpty() 
+ void assertValueAtPredicateMatch() 
+ void assertValueAtPredicateNoMatch() 
+ void assertValueAtInvalidIndex() 
+ void withTag() 
 
}
class io.reactivex.parallel.ParallelCollectTest {
 + void subscriberCount() 
+ void accept(List<Integer> a, Integer b) 
+ void initialCrash() 
+ void reducerCrash() 
+ void cancel() 
+ void error() 
+ void doubleError() 
+ void accept(List<Object> a, Object b) 
 
}
class io.reactivex.parallel.ParallelDoOnNextTryTest {
 + void accept(Object t) 
+ void doOnNextNoError() 
+ void doOnNextErrorNoError() 
+ void doOnNextConditionalNoError() 
+ void doOnNextErrorConditionalNoError() 
+ void doOnNextFailWithError() 
+ void doOnNextFailWithStop() 
+ void doOnNextFailWithRetry() 
+ void doOnNextFailWithRetryLimited() 
+ ParallelFailureHandling apply(Long n, Throwable e) 
+ void doOnNextFailWithSkip() 
+ void doOnNextFailHandlerThrows() 
+ void doOnNextWrongParallelism() 
+ void filterInvalidSource() 
+ void doOnNextFailWithErrorConditional() 
+ void doOnNextFailWithStopConditional() 
+ void doOnNextFailWithRetryConditional() 
+ void doOnNextFailWithRetryLimitedConditional() 
+ void doOnNextFailWithSkipConditional() 
+ void doOnNextFailHandlerThrowsConditional() 
+ void doOnNextWrongParallelismConditional() 
+ void filterInvalidSourceConditional() 
 
}
class io.reactivex.parallel.ParallelFilterTest {
 + void subscriberCount() 
+ void doubleFilter() 
+ boolean test(Integer v) 
+ void doubleError() 
+ void doubleError2() 
+ void error() 
+ void predicateThrows() 
 
}
class io.reactivex.parallel.ParallelFilterTryTest {
 + void accept(Object t) 
+ void filterNoError() 
+ void filterFalse() 
+ void filterFalseConditional() 
+ void filterErrorNoError() 
+ void filterConditionalNoError() 
+ void filterErrorConditionalNoError() 
+ void filterFailWithError() 
+ void filterFailWithStop() 
+ void filterFailWithRetry() 
+ void filterFailWithRetryLimited() 
+ ParallelFailureHandling apply(Long n, Throwable e) 
+ void filterFailWithSkip() 
+ void filterFailHandlerThrows() 
+ void filterWrongParallelism() 
+ void filterInvalidSource() 
+ void filterFailWithErrorConditional() 
+ void filterFailWithStopConditional() 
+ void filterFailWithRetryConditional() 
+ void filterFailWithRetryLimitedConditional() 
+ void filterFailWithSkipConditional() 
+ void filterFailHandlerThrowsConditional() 
+ void filterWrongParallelismConditional() 
+ void filterInvalidSourceConditional() 
 
}
class io.reactivex.parallel.ParallelFlowableTest {
 + void sequentialMode() 
+ void sequentialModeFused() 
+ void parallelMode() 
+ void parallelModeFused() 
+ void reduceFull() 
+ void parallelReduceFull() 
+ Long apply(Long a, Long b) 
+ void toSortedList() 
+ void sorted() 
+ void collect() 
+ void accept(List<Integer> a, Integer b) 
+ Iterable<Integer> apply(List<Integer> v) 
+ void from() 
+ void concatMapUnordered() 
+ void flatMapUnordered() 
+ void collectAsyncFused() 
+ void accept(List<Integer> v) 
+ void collectAsync() 
+ void collectAsync2() 
+ void collectAsync3() 
+ void collectAsync3Fused() 
+ void collectAsync3Take() 
+ void collectAsync4Take() 
+ void emptySourceZeroRequest() 
+ void parallelismAndPrefetch() 
+ void parallelismAndPrefetchAsync() 
+ void badParallelismStage() 
+ void badParallelismStage2() 
+ void filter() 
+ void filterThrows() 
+ void run() 
+ boolean test(Integer v) 
+ void doAfterNext() 
+ void accept(Integer v) 
+ void doOnNextThrows() 
+ void doAfterNextThrows() 
+ void errorNotRepeating() 
+ void doOnError() 
+ Integer apply(Integer v) 
+ void accept(Throwable e) 
+ void doOnErrorThrows() 
+ void doOnComplete() 
+ void doAfterTerminate() 
+ void doOnSubscribe() 
+ void accept(Subscription s) 
+ void doOnRequest() 
+ void accept(long s) 
+ void doOnCancel() 
+ void fromPublishers() 
+ void to() 
+ void toThrows() 
+ void compose() 
+ void flatMapDelayError() 
+ Flowable<Integer> apply(Integer v) 
+ void flatMapDelayErrorMaxConcurrency() 
+ void concatMapDelayError() 
+ void concatMapDelayErrorPrefetch() 
+ void concatMapDelayErrorBoundary() 
+ {static} void checkSubscriberCount(ParallelFlowable<?> source) 
+ void checkAddBiConsumer() 
+ void mergeBiFunction() 
+ void concatMapSubscriberCount() 
+ void flatMapSubscriberCount() 
+ void fromArraySubscriberCount() 
 
}
class io.reactivex.parallel.ParallelFromPublisherTest {
 + void sourceOverflow() 
+ void fusedFilterBecomesEmpty() 
+ void syncFusedMapCrash() 
+ void asyncFusedMapCrash() 
 
}
class io.reactivex.parallel.ParallelInvalid {
 + void subscribe(Subscriber<? super Object>[] subscribers) 
+ int parallelism() 
 
}
class io.reactivex.parallel.ParallelJoinTest {
 + void overflowFastpath() 
+ int parallelism() 
+ void overflowSlowpath() 
+ void subscribe(Subscriber<? super Integer>[] subscribers) 
+ void emptyBackpressured() 
+ void overflowFastpathDelayError() 
+ void overflowSlowpathDelayError() 
+ void emptyBackpressuredDelayError() 
+ void delayError() 
+ void normalDelayError() 
+ void rangeDelayError() 
+ void rangeDelayErrorBackpressure() 
+ void rangeDelayErrorBackpressure2() 
+ void delayErrorCancelBackpressured() 
+ void delayErrorCancelBackpressured2() 
+ void consumerCancelsAfterOne() 
+ void delayErrorConsumerCancelsAfterOne() 
+ void delayErrorDrainTrigger() 
+ void failedRailIsIgnored() 
+ void failedRailIsIgnoredHidden() 
 
}
class io.reactivex.parallel.ParallelMapTest {
 + void subscriberCount() 
+ void doubleFilter() 
+ boolean test(Integer v) 
+ void doubleFilterAsync() 
+ void doubleError() 
+ void doubleError2() 
+ void error() 
+ void mapCrash() 
+ void mapCrashConditional() 
+ void mapCrashConditional2() 
 
}
class io.reactivex.parallel.ParallelMapTryTest {
 + void accept(Object t) 
+ void mapNoError() 
+ void mapErrorNoError() 
+ void mapConditionalNoError() 
+ void mapErrorConditionalNoError() 
+ void mapFailWithError() 
+ void mapFailWithStop() 
+ void mapFailWithRetry() 
+ void mapFailWithRetryLimited() 
+ ParallelFailureHandling apply(Long n, Throwable e) 
+ void mapFailWithSkip() 
+ void mapFailHandlerThrows() 
+ void mapWrongParallelism() 
+ void mapInvalidSource() 
+ void mapFailWithErrorConditional() 
+ void mapFailWithStopConditional() 
+ void mapFailWithRetryConditional() 
+ void mapFailWithRetryLimitedConditional() 
+ void mapFailWithSkipConditional() 
+ void mapFailHandlerThrowsConditional() 
+ void mapWrongParallelismConditional() 
+ void mapInvalidSourceConditional() 
+ void failureHandlingEnum() 
 
}
class io.reactivex.parallel.ParallelPeekTest {
 + void subscriberCount() 
+ void onSubscribeCrash() 
+ void doubleError() 
+ void requestCrash() 
+ void cancelCrash() 
+ void onCompleteCrash() 
+ void onAfterTerminatedCrash() 
+ void onAfterTerminatedCrash2() 
 
}
class io.reactivex.parallel.ParallelPerf {
 + Integer apply(Integer t) 
+ void setup() 
+ Integer apply(Integer v) 
+ Publisher<Integer> apply(GroupedFlowable<Integer, Integer> g) 
+ void flatMap(Blackhole bh) 
+ void groupBy(Blackhole bh) 
+ void parallel(Blackhole bh) 
    + int count;
    + int compute;
    + int parallelism;
 
}
class io.reactivex.parallel.ParallelReduceFullTest {
 + void cancel() 
+ void error() 
+ void error2() 
+ void empty() 
+ void doubleError() 
+ void reducerCrash() 
+ void reducerCrash2() 
 
}
class io.reactivex.parallel.ParallelReduceTest {
 + void subscriberCount() 
+ List<Integer> apply(List<Integer> a, Integer b) 
+ void initialCrash() 
+ void reducerCrash() 
+ void cancel() 
+ void error() 
+ void doubleError() 
+ List<Object> apply(List<Object> a, Object b) 
 
}
class io.reactivex.parallel.ParallelRunOnTest {
 + void subscriberCount() 
+ void doubleError() 
+ void conditionalPath() 
+ void missingBackpressure() 
+ void subscribe(Subscriber<? super Integer>[] subscribers) 
+ void error() 
+ void errorBackpressured() 
+ void errorConditional() 
+ void errorConditionalBackpressured() 
+ void emptyConditionalBackpressured() 
+ void nextCancelRace() 
+ void run() 
+ void nextCancelRaceBackpressured() 
+ void nextCancelRaceConditional() 
+ void nextCancelRaceBackpressuredConditional() 
+ void normalCancelAfterRequest1() 
+ void conditionalCancelAfterRequest1() 
 
}
class io.reactivex.parallel.ParallelSortedJoinTest {
 + void cancel() 
+ void error() 
+ void error3() 
+ void error2() 
+ void comparerCrash() 
+ void empty() 
+ void asyncDrain() 
+ void sortCancelRace() 
+ void run() 
+ void sortCancelRace2() 
 
}
class io.reactivex.plugins.RxJavaPlugins {
 + {static} void lockdown() 
+ {static} boolean isLockdown() 
+ {static} void setFailOnNonBlockingScheduler(boolean enable) 
+ {static} boolean isFailOnNonBlockingScheduler() 
+ {static} Scheduler initComputationScheduler(@NonNull Callable<Scheduler> defaultScheduler) 
+ {static} Scheduler initIoScheduler(@NonNull Callable<Scheduler> defaultScheduler) 
+ {static} Scheduler initNewThreadScheduler(@NonNull Callable<Scheduler> defaultScheduler) 
+ {static} Scheduler initSingleScheduler(@NonNull Callable<Scheduler> defaultScheduler) 
+ {static} Scheduler onComputationScheduler(@NonNull Scheduler defaultScheduler) 
+ {static} void onError(@NonNull Throwable error) 
~{static} boolean isBug(Throwable error) 
~{static} void uncaught(@NonNull Throwable error) 
+ {static} Scheduler onIoScheduler(@NonNull Scheduler defaultScheduler) 
+ {static} Scheduler onNewThreadScheduler(@NonNull Scheduler defaultScheduler) 
+ {static} Runnable onSchedule(@NonNull Runnable run) 
+ {static} Scheduler onSingleScheduler(@NonNull Scheduler defaultScheduler) 
+ {static} void reset() 
+ {static} void setComputationSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) 
+ {static} void setErrorHandler(@Nullable Consumer<? super Throwable> handler) 
+ {static} void setInitComputationSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) 
+ {static} void setInitIoSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) 
+ {static} void setInitNewThreadSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) 
+ {static} void setInitSingleSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) 
+ {static} void setIoSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) 
+ {static} void setNewThreadSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) 
+ {static} void setScheduleHandler(@Nullable Function<? super Runnable, ? extends Runnable> handler) 
+ {static} void setSingleSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) 
~{static} void unlock() 
+ {static} void setOnCompletableAssembly(@Nullable Function<? super Completable, ? extends Completable> onCompletableAssembly) 
+ {static} void setOnCompletableSubscribe(
            @Nullable BiFunction<? super Completable, ? super CompletableObserver, ? extends CompletableObserver> onCompletableSubscribe) 
+ {static} void setOnFlowableAssembly(@Nullable Function<? super Flowable, ? extends Flowable> onFlowableAssembly) 
+ {static} void setOnMaybeAssembly(@Nullable Function<? super Maybe, ? extends Maybe> onMaybeAssembly) 
+ {static} void setOnConnectableFlowableAssembly(@Nullable Function<? super ConnectableFlowable, ? extends ConnectableFlowable> onConnectableFlowableAssembly) 
+ {static} void setOnFlowableSubscribe(@Nullable BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> onFlowableSubscribe) 
+ {static} void setOnMaybeSubscribe(@Nullable BiFunction<? super Maybe, MaybeObserver, ? extends MaybeObserver> onMaybeSubscribe) 
+ {static} void setOnObservableAssembly(@Nullable Function<? super Observable, ? extends Observable> onObservableAssembly) 
+ {static} void setOnConnectableObservableAssembly(@Nullable Function<? super ConnectableObservable, ? extends ConnectableObservable> onConnectableObservableAssembly) 
+ {static} void setOnObservableSubscribe(
            @Nullable BiFunction<? super Observable, ? super Observer, ? extends Observer> onObservableSubscribe) 
+ {static} void setOnSingleAssembly(@Nullable Function<? super Single, ? extends Single> onSingleAssembly) 
+ {static} void setOnSingleSubscribe(@Nullable BiFunction<? super Single, ? super SingleObserver, ? extends SingleObserver> onSingleSubscribe) 
+ {static} CompletableObserver onSubscribe(@NonNull Completable source, @NonNull CompletableObserver observer) 
+ {static} Completable onAssembly(@NonNull Completable source) 
+ {static} void setOnParallelAssembly(@Nullable Function<? super ParallelFlowable, ? extends ParallelFlowable> handler) 
+ {static} boolean onBeforeBlocking() 
+ {static} void setOnBeforeBlocking(@Nullable BooleanSupplier handler) 
+ {static} BooleanSupplier getOnBeforeBlocking() 
+ {static} Scheduler createComputationScheduler(@NonNull ThreadFactory threadFactory) 
+ {static} Scheduler createIoScheduler(@NonNull ThreadFactory threadFactory) 
+ {static} Scheduler createNewThreadScheduler(@NonNull ThreadFactory threadFactory) 
+ {static} Scheduler createSingleScheduler(@NonNull ThreadFactory threadFactory) 
~{static} Scheduler callRequireNonNull(@NonNull Callable<Scheduler> s) 
~{static} Scheduler applyRequireNonNull(@NonNull Function<? super Callable<Scheduler>, ? extends Scheduler> f, Callable<Scheduler> s) 
 
}
class io.reactivex.plugins.RxJavaPluginsTest {
 ~{static} Observable<Integer> createObservable() 
~{static} Flowable<Integer> createFlowable() 
+ void constructorShouldBePrivate() 
+ void assemblyTrackingObservable() 
~{static} Single<Integer> createSingle() 
+ void assemblyTrackingSingle() 
~{static} Completable createCompletable() 
+ void assemblyTrackingCompletable() 
+ void lockdown() 
+ Object apply(Object t1, Object t2) 
+ boolean getAsBoolean() 
+ Scheduler apply(Scheduler t) 
+ void overrideSingleScheduler() 
+ void overrideComputationScheduler() 
+ void overrideIoScheduler() 
+ void overrideNewThreadScheduler() 
+ Scheduler apply(Callable<Scheduler> t) 
+ void overrideInitSingleScheduler() 
+ void overrideInitComputationScheduler() 
+ void overrideInitIoScheduler() 
+ void overrideInitNewThreadScheduler() 
+ Scheduler call() 
+ void overrideInitSingleSchedulerCrashes() 
+ void overrideInitComputationSchedulerCrashes() 
+ void overrideInitIoSchedulerCrashes() 
+ void overrideInitNewThreadSchedulerCrashes() 
+ void testDefaultSingleSchedulerIsInitializedLazily() 
+ void testDefaultIoSchedulerIsInitializedLazily() 
+ void testDefaultComputationSchedulerIsInitializedLazily() 
+ void testDefaultNewThreadSchedulerIsInitializedLazily() 
+ void observableCreate() 
+ void flowableCreate() 
+ void observableStart() 
+ void onNext(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void flowableStart() 
+ void observableReturn() 
+ void singleCreate() 
+ void singleStart() 
+ void onSuccess(Object value) 
+ void singleReturn() 
+ void completableCreate() 
+ void completableStart() 
+ Runnable apply(Runnable t) 
+ void run() 
+ void onScheduleComputation() 
+ void onScheduleIO() 
+ void onScheduleNewThread() 
+ void onError() 
+ void clear() 
+ void onErrorNoHandler() 
+ void onErrorCrashes() 
+ void uncaughtException(Thread t, Throwable e) 
+ void onErrorWithNull() 
+ void onErrorWithSuper() 
+ Scheduler apply(Scheduler scheduler) 
+ Scheduler apply(Callable<Scheduler> schedulerCallable) 
+ ConnectableFlowable apply(ConnectableFlowable connectableFlowable) 
+ ConnectableObservable apply(ConnectableObservable connectableObservable) 
+ Flowable apply(Flowable flowable) 
+ Subscriber apply(Flowable flowable, Subscriber subscriber) 
+ Maybe apply(Maybe maybe) 
+ MaybeObserver apply(Maybe maybe, MaybeObserver maybeObserver) 
+ Observable apply(Observable observable) 
+ Observer apply(Observable observable, Observer observer) 
+ ParallelFlowable apply(ParallelFlowable parallelFlowable) 
+ Single apply(Single single) 
+ SingleObserver apply(Single single, SingleObserver singleObserver) 
+ Runnable apply(Runnable runnable) 
+ CompletableObserver apply(Completable completable, CompletableObserver completableObserver) 
+ Completable apply(Completable completable) 
+ void clearIsPassthrough() 
+ void subscribeActual(Subscriber t) 
+ void subscribeActual(SingleObserver t) 
+ void subscribeActual(CompletableObserver t) 
+ void subscribeActual(MaybeObserver t) 
+ void onSubscribe(Disposable d) 
+ void onSubscribe(Subscription s) 
+ void onNext(Object t) 
+ void onError(Throwable t) 
+ Object call(Object t) 
+ CompletableSubscriber call(CompletableSubscriber t) 
~{static} void assertTestException(List<Throwable> list, int index, String message) 
~{static} void assertUndeliverableTestException(List<Throwable> list, int index, String message) 
~{static} void assertNPE(List<Throwable> list, int index) 
+ void onXError() 
+ void onPluginsXError() 
+ Throwable onSubscribeError(Throwable e) 
+ void onXLift() 
+ Operator call(Operator t) 
+ CompletableOperator call(CompletableOperator t) 
+ void onPluginsXLift() 
+ CompletableOperator onLift(CompletableOperator lift) 
+ void overrideConnectableObservable() 
# void subscribeActual(Observer observer) 
+ void overrideConnectableFlowable() 
# void subscribeActual(Subscriber subscriber) 
+ void assemblyHookCrashes() 
+ Flowable apply(Flowable f) 
+ void subscribeHookCrashes() 
+ Subscriber apply(Flowable f, Subscriber s) 
+ void maybeCreate() 
+ void maybeStart() 
+ void onErrorNull() 
- {static} void verifyThread(Scheduler scheduler, String expectedThreadName)
            
+ void createComputationScheduler() 
+ void createIoScheduler() 
+ void createNewThreadScheduler() 
+ void createSingleScheduler() 
+ void onBeforeBlocking() 
+ void onParallelAssembly() 
+ void isBug() 
 
}
class io.reactivex.processors.AsyncProcessor {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasSubscribers() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ Throwable getThrowable() 
# void subscribeActual(Subscriber<? super T> s) 
+ boolean hasValue() 
+ T getValue() 
+ Object[] getValues() 
+ T[] getValues(T[] array) 
+ void cancel() 
~    final AtomicReference<AsyncSubscription<T>[]> subscribers;
~        final AsyncProcessor<T> parent;
 
}
class io.reactivex.processors.AsyncProcessorTest {
 # FlowableProcessor<Object> create() 
+ void testNeverCompleted() 
+ void testCompleted() 
+ void testNull() 
+ void testSubscribeAfterCompleted() 
+ void testSubscribeAfterError() 
+ void testError() 
+ void testUnsubscribeBeforeCompleted() 
+ void testEmptySubjectCompleted() 
+ void testSubscribeCompletionRaceCondition() 
+ void run() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testCurrentStateMethodsNormal() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void fusionLive() 
+ void fusionOfflie() 
+ void onSubscribeAfterDone() 
+ void cancelUpfront() 
+ void cancelRace() 
+ void onErrorCancelRace() 
+ void onNextCrossCancel() 
+ void onErrorCrossCancel() 
+ void onCompleteCrossCancel() 
        - final AsyncProcessor<String> subject;
 
}
class io.reactivex.processors.BehaviorProcessor {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean offer(T t) 
+ boolean hasSubscribers() 
+ Throwable getThrowable() 
+ T getValue() 
+ Object[] getValues() 
+ T[] getValues(T[] array) 
+ boolean hasComplete() 
+ boolean hasThrowable() 
+ boolean hasValue() 
+ void request(long n) 
+ void cancel() 
+ boolean test(Object o) 
+ boolean isFull() 
~    final AtomicReference<BehaviorSubscription<T>[]> subscribers;
~    final ReadWriteLock lock;
~    final Lock readLock;
~    final Lock writeLock;
~    final AtomicReference<Object> value;
~    final AtomicReference<Throwable> terminalEvent;
~        final BehaviorProcessor<T> state;
 
}
class io.reactivex.processors.BehaviorProcessorTest {
 # FlowableProcessor<Object> create() 
+ void testThatSubscriberReceivesDefaultValueAndSubsequentEvents() 
+ void testThatSubscriberReceivesLatestAndThenSubsequentEvents() 
+ void testSubscribeThenOnComplete() 
+ void testSubscribeToCompletedOnlyEmitsOnComplete() 
+ void testSubscribeToErrorOnlyEmitsOnError() 
+ void testCompletedStopsEmittingData() 
+ void testCompletedAfterErrorIsNotSent() 
+ void testCompletedAfterErrorIsNotSent2() 
+ void testCompletedAfterErrorIsNotSent3() 
+ void testUnsubscriptionCase() 
+ void onNext(String t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testStartEmpty() 
+ void testStartEmptyThenAddOne() 
+ void testStartEmptyCompleteWithOne() 
+ void testTakeOneSubscriber() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testEmissionSubscriptionRace() 
+ void run() 
+ void onNext(Object t) 
+ void testCurrentStateMethodsNormalEmptyStart() 
+ void testCurrentStateMethodsNormalSomeStart() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void cancelOnArrival() 
+ void onSubscribe() 
+ void onErrorAfterComplete() 
+ void cancelOnArrival2() 
+ void addRemoveRace() 
+ void subscribeOnNextRace() 
+ void firstBackpressured() 
+ void offer() 
+ void offerAsync() 
+ void completeSubscribeRace() 
+ void errorSubscribeRace() 
 
}
class io.reactivex.processors.Flowable
class io.reactivex.processors.PublishProcessor {
 + void subscribeActual(Subscriber<? super T> t) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean offer(T t) 
+ boolean hasSubscribers() 
+ Throwable getThrowable() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ void request(long n) 
+ void cancel() 
+ boolean isCancelled() 
~    final AtomicReference<PublishSubscription<T>[]> subscribers;
~        final PublishProcessor<T> parent;
 
}
class io.reactivex.processors.PublishProcessorTest {
 # FlowableProcessor<Object> create() 
+ void testCompleted() 
+ void testCompletedStopsEmittingData() 
- void assertCompletedSubscriber(Subscriber<String> observer) 
+ void testError() 
- void assertErrorSubscriber(Subscriber<String> observer) 
+ void testSubscribeMidSequence() 
- void assertCompletedStartingWithThreeSubscriber(Subscriber<String> observer) 
+ void testUnsubscribeFirstSubscriber() 
- void assertObservedUntilTwo(Subscriber<String> observer) 
+ void testNestedSubscribe() 
+ void accept(String v) 
+ void testReSubscribe() 
+ void testUnsubscriptionCase() 
+ void onNext(String t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testCurrentStateMethodsNormal() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void subscribeTo() 
+ void requestValidation() 
+ void crossCancel() 
+ void crossCancelOnError() 
+ void crossCancelOnComplete() 
+ void backpressureOverflow() 
+ void onSubscribeCancelsImmediately() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void terminateRace() 
+ void addRemoveRance() 
+ void run() 
+ void offer() 
+ void offerAsync() 
 
}
class io.reactivex.processors.ReplayProcessor {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasSubscribers() 
+ Throwable getThrowable() 
+ T getValue() 
+ Object[] getValues() 
+ T[] getValues(T[] array) 
+ boolean hasComplete() 
+ boolean hasThrowable() 
+ boolean hasValue() 
+ void request(long n) 
+ void cancel() 
+ void add(T value) 
+ void addFinal(Object notificationLite) 
+ void replay(ReplaySubscription<T> rs) 
+ int size() 
~    final ReplayBuffer<T> buffer;
~    final AtomicReference<ReplaySubscription<T>[]> subscribers;
~        final ReplayProcessor<T> state;
~        final AtomicLong requested;
~        final List<Object> buffer;
~        final T value;
~        final long time;
~        final int maxSize;
~        final long maxAge;
~        final TimeUnit unit;
~        final Scheduler scheduler;
 
}
class io.reactivex.processors.ReplayProcessorBoundedConcurrencyTest {
 + void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() 
+ void run() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testReplaySubjectConcurrentSubscriptions() 
+ void testSubscribeCompletionRaceCondition() 
+ void testRaceForTerminalState() 
+ void testReplaySubjectEmissionSubscriptionRace() 
# void onStart() 
+ void onComplete() 
+ void onNext(Object t) 
+ void testConcurrentSizeAndHasAnyValue() 
+ void testConcurrentSizeAndHasAnyValueBounded() 
+ void testConcurrentSizeAndHasAnyValueTimeBounded() 
        - final ReplayProcessor<String> subject;
 
}
class io.reactivex.processors.ReplayProcessorConcurrencyTest {
 + void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() 
+ void run() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testReplaySubjectConcurrentSubscriptions() 
+ void testSubscribeCompletionRaceCondition() 
+ void testRaceForTerminalState() 
+ void testReplaySubjectEmissionSubscriptionRace() 
+ void onComplete() 
+ void onNext(Object t) 
+ void testConcurrentSizeAndHasAnyValue() 
        - final ReplayProcessor<String> subject;
 
}
class io.reactivex.processors.ReplayProcessorTest {
 # FlowableProcessor<Object> create() 
+ void testCompleted() 
+ void testCompletedStopsEmittingData() 
+ void testCompletedAfterError() 
- void assertCompletedSubscriber(Subscriber<String> observer) 
+ void testError() 
- void assertErrorSubscriber(Subscriber<String> observer) 
+ void testSubscribeMidSequence() 
+ void testUnsubscribeFirstSubscriber() 
- void assertObservedUntilTwo(Subscriber<String> observer) 
+ void testNewSubscriberDoesntBlockExisting() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void onComplete() 
+ void testSubscriptionLeak() 
+ void testUnsubscriptionCase() 
+ void onNext(String t) 
+ void testTerminateOnce() 
+ void testReplay1AfterTermination() 
+ void testReplay1Directly() 
+ void testReplayTimestampedAfterTermination() 
+ void testReplayTimestampedDirectly() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testCurrentStateMethodsNormal() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void testSizeAndHasAnyValueUnbounded() 
+ void testSizeAndHasAnyValueEffectivelyUnbounded() 
+ void testSizeAndHasAnyValueUnboundedError() 
+ void testSizeAndHasAnyValueEffectivelyUnboundedError() 
+ void testSizeAndHasAnyValueUnboundedEmptyError() 
+ void testSizeAndHasAnyValueEffectivelyUnboundedEmptyError() 
+ void testSizeAndHasAnyValueUnboundedEmptyCompleted() 
+ void testSizeAndHasAnyValueEffectivelyUnboundedEmptyCompleted() 
+ void testSizeAndHasAnyValueSizeBounded() 
+ void testSizeAndHasAnyValueTimeBounded() 
+ void testGetValues() 
+ void testGetValuesUnbounded() 
+ void testBackpressureHonored() 
+ void testBackpressureHonoredSizeBound() 
+ void testBackpressureHonoredTimeBound() 
+ void createInvalidCapacity() 
+ void createWithSizeInvalidCapacity() 
+ void createWithTimeAndSizeInvalidCapacity() 
+ void hasSubscribers() 
+ void peekStateUnbounded() 
+ void peekStateTimeAndSize() 
+ void peekStateTimeAndSizeValue() 
+ void capacityHint() 
+ void subscribeCancelRace() 
+ void run() 
+ void subscribeAfterDone() 
+ void subscribeRace() 
+ void cancelUpfront() 
+ void cancelRace() 
+ void sizeboundReplayError() 
+ void sizeAndTimeBoundReplayError() 
+ void replayRequestRace() 
+ void timedSkipOld() 
+ void takeSizeAndTime() 
+ void takeSize() 
+ void reentrantDrain() 
+ void reentrantDrainBackpressured() 
+ void timedNoOutdatedData() 
 
}
class io.reactivex.processors.SerializedProcessor {
 # void subscribeActual(Subscriber<? super T> s) 
+ void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasSubscribers() 
+ boolean hasThrowable() 
+ Throwable getThrowable() 
+ boolean hasComplete() 
~    final FlowableProcessor<T> actual;
 
}
class io.reactivex.processors.SerializedProcessorTest {
 + void testBasic() 
+ void testAsyncSubjectValueRelay() 
+ void testAsyncSubjectValueEmpty() 
+ void testAsyncSubjectValueError() 
+ void testPublishSubjectValueRelay() 
+ void testPublishSubjectValueEmpty() 
+ void testPublishSubjectValueError() 
+ void testBehaviorSubjectValueRelay() 
+ void testBehaviorSubjectValueRelayIncomplete() 
+ void testBehaviorSubjectIncompleteEmpty() 
+ void testBehaviorSubjectEmpty() 
+ void testBehaviorSubjectError() 
+ void testReplaySubjectValueRelay() 
+ void testReplaySubjectValueRelayIncomplete() 
+ void testReplaySubjectValueRelayBounded() 
+ void testReplaySubjectValueRelayBoundedIncomplete() 
+ void testReplaySubjectValueRelayBoundedEmptyIncomplete() 
+ void testReplaySubjectValueRelayEmptyIncomplete() 
+ void testReplaySubjectEmpty() 
+ void testReplaySubjectError() 
+ void testReplaySubjectBoundedEmpty() 
+ void testReplaySubjectBoundedError() 
+ void testDontWrapSerializedSubjectAgain() 
+ void normal() 
+ void onNextOnNextRace() 
+ void run() 
+ void onNextOnErrorRace() 
+ void onNextOnCompleteRace() 
+ void onNextOnSubscribeRace() 
+ void onCompleteOnSubscribeRace() 
+ void onCompleteOnCompleteRace() 
+ void onErrorOnErrorRace() 
+ void onSubscribeOnSubscribeRace() 
 
}
class io.reactivex.processors.UnicastProcessor {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
# void subscribeActual(Subscriber<? super T> s) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ int requestFusion(int requestedMode) 
+ void request(long n) 
+ void cancel() 
+ boolean hasSubscribers() 
+ Throwable getThrowable() 
+ boolean hasComplete() 
+ boolean hasThrowable() 
~    final SpscLinkedArrayQueue<T> queue;
~    final AtomicReference<Runnable> onTerminate;
~    final boolean delayError;
~    final AtomicBoolean once;
~    final BasicIntQueueSubscription<T> wip;
~    final AtomicLong requested;
 
}
class io.reactivex.processors.UnicastProcessorTest {
 # FlowableProcessor<Object> create() 
+ void fusionLive() 
+ void fusionOfflie() 
+ void failFast() 
+ void failFastFusionOffline() 
+ void threeArgsFactory() 
+ void onTerminateCalledWhenOnError() 
+ void onTerminateCalledWhenOnComplete() 
+ void onTerminateCalledWhenCanceled() 
+ void nullOnTerminate() 
+ void negativeCapacityHint() 
+ void zeroCapacityHint() 
+ void completeCancelRace() 
+ void run() 
+ void afterDone() 
+ void onErrorStatePeeking() 
+ void rejectSyncFusion() 
+ void cancelOnArrival() 
+ void multiSubscriber() 
+ void fusedDrainCancel() 
 
}
class io.reactivex.schedulers.CachedThreadSchedulerTest {
 # Scheduler getScheduler() 
+ final void testIOScheduler() 
+ void accept(String t) 
+ final void testUnhandledErrorIsDeliveredToThreadHandler() 
+ final void testHandledErrorIsNotDeliveredToThreadHandler() 
+ void testCancelledTaskRetention() 
+ void workerDisposed() 
+ void shutdownRejects() 
+ void run() 
 
}
class io.reactivex.schedulers.ComputationSchedulerTests {
 # Scheduler getScheduler() 
+ void testThreadSafetyWhenSchedulerIsHoppingBetweenThreads() 
+ final void testComputationThreadPool1() 
+ void accept(String t) 
+ final void testMergeWithExecutorScheduler() 
+ final void testUnhandledErrorIsDeliveredToThreadHandler() 
+ final void testHandledErrorIsNotDeliveredToThreadHandler() 
+ void testCancelledTaskRetention() 
+ void shutdownRejects() 
+ void run() 
 
}
class io.reactivex.schedulers.ExecutorSchedulerTest {
 # Scheduler getScheduler() 
+ final void testUnhandledErrorIsDeliveredToThreadHandler() 
+ final void testHandledErrorIsNotDeliveredToThreadHandler() 
+ {static} void testCancelledRetention(Scheduler.Worker w, boolean periodic) 
+ void testCancelledTaskRetention() 
+ void execute(Runnable command) 
+ void executeOne() 
+ void executeAll() 
+ void testCancelledTasksDontRun() 
+ void testCancelledWorkerDoesntRunTasks() 
+ void testNoTimedTaskAfterScheduleRetention() 
+ void testNoTimedTaskPartRetention() 
+ void testNoPeriodicTimedTaskPartRetention() 
+ void run() 
+ void plainExecutor() 
+ void rejectingExecutor() 
+ void rejectingExecutorWorker() 
+ void reuseScheduledExecutor() 
+ void reuseScheduledExecutorAsWorker() 
+ void disposeRace() 
+ void runnableDisposed() 
+ void runnableDisposedAsync() 
+ void runnableDisposedAsync2() 
+ void runnableDisposedAsyncCrash() 
+ void runnableDisposedAsyncTimed() 
+ void runnableDisposedAsyncTimed2() 
 
}
class io.reactivex.schedulers.FailOnBlockingTest {
 + void failComputationFlowableBlockingFirst() 
+ void failComputationFlowableBlockingLast() 
+ void failComputationFlowableBlockingIterable() 
+ void failComputationFlowableBlockingSubscribe() 
+ void failComputationFlowableBlockingSingle() 
+ void failComputationFlowableBlockingForEach() 
+ void failComputationFlowableBlockingLatest() 
+ void failComputationFlowableBlockingNext() 
+ void failComputationFlowableToFuture() 
+ void failComputationObservableBlockingFirst() 
+ void failComputationObservableBlockingLast() 
+ void failComputationObservableBlockingIterable() 
+ void failComputationObservableBlockingSubscribe() 
+ void failComputationObservableBlockingSingle() 
+ void failComputationObservableBlockingForEach() 
+ void failComputationObservableBlockingLatest() 
+ void failComputationObservableBlockingNext() 
+ void failComputationObservableToFuture() 
+ void failSingleObservableBlockingFirst() 
+ void failSingleSingleBlockingGet() 
+ void failSingleMaybeBlockingGet() 
+ void failSingleCompletableBlockingGet() 
+ void failSingleCompletableBlockingAwait() 
+ void dontfailIOObservableBlockingFirst() 
+ void failWithCustomHandler() 
+ Integer apply(Integer v) 
 
}
class io.reactivex.schedulers.NewThreadSchedulerTest {
 # Scheduler getScheduler() 
+ final void testUnhandledErrorIsDeliveredToThreadHandler() 
+ final void testHandledErrorIsNotDeliveredToThreadHandler() 
+ void testNoSelfInterrupt() 
+ void dispose() 
+ void shutdownRejects() 
+ void run() 
+ void npeRegression() 
 
}
class io.reactivex.schedulers.SchedulerLifecycleTest {
 + void testShutdown() 
- void tryOutSchedulers() 
+ void testStartIdempotence() 
 
}
class io.reactivex.schedulers.SchedulerTest {
 + void defaultPeriodicTask() 
+ void run() 
+ void periodicDirectThrows() 
+ void disposePeriodicDirect() 
+ void scheduleDirect() 
+ void disposeSelfPeriodicDirect() 
+ void disposeSelfPeriodic() 
+ void periodicDirectTaskRace() 
+ void periodicDirectTaskRaceIO() 
+ void scheduleDirectThrows() 
+ void schedulersUtility() 
+ void defaultSchedulePeriodicallyDirectRejects() 
+ void dispose() 
+ boolean isDisposed() 
+ void holders() 
+ Worker createWorker() 
+ void customScheduleDirectDisposed() 
 
}
class io.reactivex.schedulers.SchedulerTestHelper {
 ~{static} void testUnhandledErrorIsDeliveredToThreadHandler(Scheduler scheduler) 
~{static} void testHandledErrorIsNotDeliveredToThreadHandler(Scheduler scheduler) 
+ void uncaughtException(Thread t, Throwable e) 
+ void onComplete() 
+ void onError(Throwable e) 
+ void onNext(T t) 
 
}
class io.reactivex.schedulers.SchedulerWorkerTest {
 + Worker createWorker() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull Runnable action) 
+ Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) 
+ long now(TimeUnit unit) 
+ long now(@NonNull TimeUnit unit) 
+ void testCurrentTimeDriftBackwards() 
+ void testCurrentTimeDriftForwards() 
 
}
class io.reactivex.schedulers.Schedulers {
 + {static} Scheduler computation() 
+ {static} Scheduler io() 
+ {static} Scheduler trampoline() 
+ {static} Scheduler newThread() 
+ {static} Scheduler single() 
+ {static} Scheduler from(@NonNull Executor executor) 
+ {static} void shutdown() 
+ {static} void start() 
+ Scheduler call() 
~    {static} final Scheduler SINGLE;
~    {static} final Scheduler COMPUTATION;
~    {static} final Scheduler IO;
~    {static} final Scheduler TRAMPOLINE;
~    {static} final Scheduler NEW_THREAD;
 
}
class io.reactivex.schedulers.TestScheduler {
 + String toString() 
+ int compareTo(TimedRunnable o) 
+ long now(@NonNull TimeUnit unit) 
+ void advanceTimeBy(long delayTime, TimeUnit unit) 
+ void advanceTimeTo(long delayTime, TimeUnit unit) 
+ void triggerActions() 
- void triggerActions(long targetTimeInNanoseconds) 
+ Worker createWorker() 
+ void dispose() 
+ boolean isDisposed() 
+ Disposable schedule(@NonNull Runnable run, long delayTime, @NonNull TimeUnit unit) 
+ Disposable schedule(@NonNull Runnable run) 
+ void run() 
~        final long time;
~        final Runnable run;
~        final TestWorker scheduler;
~        final long count;
~            final TimedRunnable timedAction;
 
}
class io.reactivex.schedulers.TestSchedulerTest {
 + final void testPeriodicScheduling() 
+ final void testPeriodicSchedulingUnsubscription() 
+ final void testImmediateUnsubscribes() 
+ final void testImmediateUnsubscribes2() 
+ final void testNestedSchedule() 
+ void timedRunnableToString() 
+ String toString() 
+ void workerDisposed() 
 
}
class io.reactivex.schedulers.Timed {
 + T value() 
+ TimeUnit unit() 
+ long time() 
+ long time(@NonNull TimeUnit unit) 
+ boolean equals(Object other) 
+ int hashCode() 
+ String toString() 
~    final T value;
~    final long time;
~    final TimeUnit unit;
 
}
class io.reactivex.schedulers.TimedTest {
 + void properties() 
+ void hashCodeOf() 
+ void equalsWith() 
+ void toStringOf() 
+ void timeUnitNullFail() 
 
}
class io.reactivex.schedulers.TrampolineSchedulerTest {
 # Scheduler getScheduler() 
+ final void testMergeWithCurrentThreadScheduler1() 
+ void accept(String t) 
+ void testNestedTrampolineWithUnsubscribe() 
+ void run() 
+ void testTrampolineWorkerHandlesConcurrentScheduling() 
- {static} Worker doWorkOnNewTrampoline(final String key, final ArrayList<String> workDone) 
- {static} Runnable createPrintAction(final String message, final ArrayList<String> workDone) 
 
}
class io.reactivex.single.SingleCacheTest {
 + void normal() 
+ void error() 
+ void delayed() 
+ void delayedDisposed() 
+ void crossCancel() 
+ void crossCancelOnError() 
 
}
class io.reactivex.single.SingleNullTests {
 + void ambIterableNull() 
+ void ambIterableIteratorNull() 
+ void ambIterableOneIsNull() 
+ void ambArrayNull() 
+ void ambArrayOneIsNull() 
+ void concatIterableNull() 
+ void concatIterableIteratorNull() 
+ void concatIterableOneIsNull() 
+ void concatObservableNull() 
+ void concatNull() 
+ void createNull() 
+ void deferNull() 
+ void deferReturnsNull() 
+ void errorSupplierNull() 
+ void errorSupplierReturnsNull() 
+ void errorNull() 
+ void fromCallableNull() 
+ void fromCallableReturnsNull() 
+ void fromFutureNull() 
+ void fromFutureReturnsNull() 
+ void fromFutureTimedFutureNull() 
+ void fromFutureTimedUnitNull() 
+ void fromFutureTimedSchedulerNull() 
+ void fromFutureTimedReturnsNull() 
+ void fromFutureSchedulerNull() 
+ void fromPublisherNull() 
+ void justNull() 
+ void mergeIterableNull() 
+ void mergeIterableIteratorNull() 
+ void mergeIterableOneIsNull() 
+ void mergeSingleNull() 
+ void mergeNull() 
+ void timerUnitNull() 
+ void timerSchedulerNull() 
+ void equalsFirstNull() 
+ void equalsSecondNull() 
+ void usingResourceSupplierNull() 
+ void usingSingleSupplierNull() 
+ void usingSingleSupplierReturnsNull() 
+ Single<Object> apply(Object d) 
+ void usingDisposeNull() 
+ Single<Integer> apply(Object d) 
+ void zipIterableNull() 
+ void zipIterableIteratorNull() 
+ Object apply(Object[] v) 
+ void zipIterableOneIsNull() 
+ void zipIterableOneFunctionNull() 
+ void zipIterableOneFunctionReturnsNull() 
+ void zipNull() 
+ Object invoke(Object o, Method m, Object[] a) 
+ Object invoke(Object o, Method m1, Object[] a) 
+ void zip2FirstNull() 
+ void zip2SecondNull() 
+ void zip2ZipperNull() 
+ void zip2ZipperReturnsdNull() 
+ void zipArrayNull() 
+ void zipIterableTwoIsNull() 
+ void zipArrayOneIsNull() 
+ void zipArrayFunctionNull() 
+ void zipArrayFunctionReturnsNull() 
+ void ambWithNull() 
+ void composeNull() 
+ void castNull() 
+ void concatWith() 
+ void delayUnitNull() 
+ void delaySchedulerNull() 
+ void doOnSubscribeNull() 
+ void doOnSuccess() 
+ void doOnError() 
+ void doOnDisposeNull() 
+ void flatMapNull() 
+ void flatMapFunctionReturnsNull() 
+ void flatMapPublisherNull() 
+ void flatMapPublisherFunctionReturnsNull() 
+ void liftNull() 
+ void liftFunctionReturnsNull() 
+ void containsNull() 
+ void containsComparerNull() 
+ void mergeWithNull() 
+ void observeOnNull() 
+ void onErrorReturnSupplierNull() 
+ void onErrorReturnsSupplierReturnsNull() 
+ void onErrorReturnValueNull() 
+ void onErrorResumeNextSingleNull() 
+ void onErrorResumeNextFunctionNull() 
+ void onErrorResumeNextFunctionReturnsNull() 
+ void repeatWhenNull() 
+ void repeatWhenFunctionReturnsNull() 
+ void repeatUntilNull() 
+ void retryBiPreducateNull() 
+ void retryPredicateNull() 
+ void retryWhenNull() 
+ void retryWhenFunctionReturnsNull() 
+ void subscribeBiConsumerNull() 
+ void subscribeConsumerNull() 
+ void subscribeSingeSubscriberNull() 
+ void subscribeOnSuccessNull() 
+ void subscribeOnErrorNull() 
+ void subscribeSubscriberNull() 
+ void subscribeOnNull() 
+ void timeoutUnitNull() 
+ void timeoutSchedulerNull() 
+ void timeoutOtherNull() 
+ void timeoutOther2Null() 
+ void toNull() 
+ void zipWithNull() 
+ void zipWithFunctionNull() 
+ void zipWithFunctionReturnsNull() 
 
}
class io.reactivex.single.SingleSubscribeTest {
 + void consumer() 
+ void accept(Integer v) 
+ void biconsumer() 
+ void accept(Integer v, Throwable e) 
+ void biconsumerError() 
+ void accept(Object v, Throwable e) 
+ void subscribeThrows() 
+ void biConsumerDispose() 
+ void consumerDispose() 
+ void consumerSuccessThrows() 
+ void consumerErrorThrows() 
+ void biConsumerThrows() 
+ void biConsumerErrorThrows() 
+ void methodTestNoCancel() 
+ void successIsDisposed() 
+ void errorIsDisposed() 
+ void biConsumerIsDisposedOnSuccess() 
+ void accept(Integer t1, Throwable t2) 
+ void biConsumerIsDisposedOnError() 
 
}
class io.reactivex.single.SingleTest {
 + void testHelloWorld() 
+ void testHelloWorld2() 
+ void onSuccess(String value) 
+ void onError(Throwable error) 
+ void testMap() 
+ void testZip() 
+ void testZipWith() 
+ void testMerge() 
+ void testMergeWith() 
+ void testCreateSuccess() 
+ void testCreateError() 
+ void testAsync() 
+ String apply(String v) 
+ void testFlatMap() 
+ void testTimeout() 
+ void testTimeoutWithFallback() 
+ void testUnsubscribe() 
+ void run() 
+ void testUnsubscribe2() 
+ void subscribe(final SingleObserver<? super String> s) 
+ void testUnsubscribeViaReturnedSubscription() 
+ void testBackpressureAsObservable() 
+ void toObservable() 
+ void doOnEventNullEvent() 
+ void doOnEventComplete() 
+ void doOnEventError() 
+ void toFuture() 
+ void toFutureThrows() 
+ void toFlowableIterableRemove() 
+ void zipIterableObject() 
+ void to() 
+ void fromObservableNull() 
+ void fromObservableEmpty() 
+ void fromObservableMoreThan1Elements() 
+ void fromObservableOneElement() 
+ void fromObservableError() 
+ void implementationThrows() 
 
}
class io.reactivex.single.SingleTimerTest {
 + void timer() 
 
}
class io.reactivex.subjects.AsyncSubject {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasObservers() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ Throwable getThrowable() 
# void subscribeActual(Observer<? super T> s) 
+ boolean hasValue() 
+ T getValue() 
+ Object[] getValues() 
+ T[] getValues(T[] array) 
+ void dispose() 
~    final AtomicReference<AsyncDisposable<T>[]> subscribers;
~        final AsyncSubject<T> parent;
 
}
class io.reactivex.subjects.AsyncSubjectTest {
 + void testNeverCompleted() 
+ void testCompleted() 
+ void testNull() 
+ void testSubscribeAfterCompleted() 
+ void testSubscribeAfterError() 
+ void testError() 
+ void testUnsubscribeBeforeCompleted() 
+ void testEmptySubjectCompleted() 
+ void testSubscribeCompletionRaceCondition() 
+ void run() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testCurrentStateMethodsNormal() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void fusionLive() 
+ void fusionOfflie() 
+ void onNextNull() 
+ void onErrorNull() 
+ void onNextNullDelayed() 
+ void onErrorNullDelayed() 
+ void onSubscribeAfterDone() 
+ void cancelUpfront() 
+ void cancelRace() 
+ void onErrorCancelRace() 
+ void onNextCrossCancel() 
+ void onErrorCrossCancel() 
+ void onCompleteCrossCancel() 
        - final AsyncSubject<String> subject;
 
}
class io.reactivex.subjects.BehaviorSubject {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasObservers() 
+ Throwable getThrowable() 
+ T getValue() 
+ Object[] getValues() 
+ T[] getValues(T[] array) 
+ boolean hasComplete() 
+ boolean hasThrowable() 
+ boolean hasValue() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean test(Object o) 
~    final AtomicReference<Object> value;
~    final AtomicReference<BehaviorDisposable<T>[]> subscribers;
~    final ReadWriteLock lock;
~    final Lock readLock;
~    final Lock writeLock;
~    final AtomicReference<Throwable> terminalEvent;
~        final BehaviorSubject<T> state;
 
}
class io.reactivex.subjects.BehaviorSubjectTest {
 + void testThatSubscriberReceivesDefaultValueAndSubsequentEvents() 
+ void testThatSubscriberReceivesLatestAndThenSubsequentEvents() 
+ void testSubscribeThenOnComplete() 
+ void testSubscribeToCompletedOnlyEmitsOnComplete() 
+ void testSubscribeToErrorOnlyEmitsOnError() 
+ void testCompletedStopsEmittingData() 
+ void testCompletedAfterErrorIsNotSent() 
+ void testCompletedAfterErrorIsNotSent2() 
+ void testCompletedAfterErrorIsNotSent3() 
+ void testUnsubscriptionCase() 
+ void onNext(String t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testStartEmpty() 
+ void testStartEmptyThenAddOne() 
+ void testStartEmptyCompleteWithOne() 
+ void testTakeOneSubscriber() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testEmissionSubscriptionRace() 
+ void run() 
+ void onNext(Object t) 
+ void testCurrentStateMethodsNormalEmptyStart() 
+ void testCurrentStateMethodsNormalSomeStart() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void onNextNull() 
+ void onErrorNull() 
+ void onNextNullDelayed() 
+ void onErrorNullDelayed() 
+ void cancelOnArrival() 
+ void onSubscribe() 
+ void onErrorAfterComplete() 
+ void cancelOnArrival2() 
+ void addRemoveRace() 
+ void subscribeOnNextRace() 
+ void innerDisposed() 
+ void onNext(Object value) 
+ void completeSubscribeRace() 
+ void errorSubscribeRace() 
 
}
class io.reactivex.subjects.Completable
class io.reactivex.subjects.CompletableSubject {
 + {static} CompletableSubject create() 
+ void onSubscribe(Disposable d) 
+ void onError(Throwable e) 
+ void onComplete() 
# void subscribeActual(CompletableObserver observer) 
+ Throwable getThrowable() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ boolean hasObservers() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<CompletableDisposable[]> observers;
~    final AtomicBoolean once;
~        final CompletableObserver actual;
 
}
class io.reactivex.subjects.CompletableSubjectTest {
 + void once() 
+ void error() 
+ void complete() 
+ void nullThrowable() 
+ void cancelOnArrival() 
+ void cancelOnArrival2() 
+ void dispose() 
+ void disposeTwice() 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribeDispose() 
+ void addRemoveRace() 
+ void run() 
 
}
class io.reactivex.subjects.Maybe
class io.reactivex.subjects.MaybeSubject {
 + void onSubscribe(Disposable d) 
+ void onSuccess(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
# void subscribeActual(MaybeObserver<? super T> observer) 
+ T getValue() 
+ boolean hasValue() 
+ Throwable getThrowable() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ boolean hasObservers() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<MaybeDisposable<T>[]> observers;
~    final AtomicBoolean once;
 
}
class io.reactivex.subjects.MaybeSubjectTest {
 + void success() 
+ void once() 
+ void error() 
+ void complete() 
+ void nullValue() 
+ void nullThrowable() 
+ void cancelOnArrival() 
+ void cancelOnArrival2() 
+ void dispose() 
+ void disposeTwice() 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void onSubscribeDispose() 
+ void addRemoveRace() 
+ void run() 
 
}
class io.reactivex.subjects.Observable
class io.reactivex.subjects.PublishSubject {
 + void subscribeActual(Observer<? super T> t) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasObservers() 
+ Throwable getThrowable() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<PublishDisposable<T>[]> subscribers;
~        final PublishSubject<T> parent;
 
}
class io.reactivex.subjects.PublishSubjectTest {
 + void testCompleted() 
+ void testCompletedStopsEmittingData() 
- void assertCompletedSubscriber(Observer<String> observer) 
+ void testError() 
- void assertErrorSubscriber(Observer<String> observer) 
+ void testSubscribeMidSequence() 
- void assertCompletedStartingWithThreeSubscriber(Observer<String> observer) 
+ void testUnsubscribeFirstSubscriber() 
- void assertObservedUntilTwo(Observer<String> observer) 
+ void testNestedSubscribe() 
+ void accept(String v) 
+ void testReSubscribe() 
+ void testUnsubscriptionCase() 
+ void onNext(String t) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testCurrentStateMethodsNormal() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void requestValidation() 
+ void crossCancel() 
+ void crossCancelOnError() 
+ void crossCancelOnComplete() 
+ void backpressureOverflow() 
+ void onSubscribeCancelsImmediately() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void terminateRace() 
+ void addRemoveRance() 
+ void run() 
+ void addTerminateRance() 
+ void addCompleteRance() 
+ void subscribeToAfterComplete() 
+ void nullOnNext() 
+ void nullOnError() 
+ void subscribedTo() 
+ void onNextNull() 
+ void onErrorNull() 
 
}
class io.reactivex.subjects.ReplaySubject {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasObservers() 
+ Throwable getThrowable() 
+ T getValue() 
+ Object[] getValues() 
+ T[] getValues(T[] array) 
+ boolean hasComplete() 
+ boolean hasThrowable() 
+ boolean hasValue() 
+ void dispose() 
+ boolean isDisposed() 
+ void add(T value) 
+ void addFinal(Object notificationLite) 
+ void replay(ReplayDisposable<T> rs) 
+ int size() 
~    final ReplayBuffer<T> buffer;
~    final AtomicReference<ReplayDisposable<T>[]> observers;
~        final ReplaySubject<T> state;
~        final List<Object> buffer;
~        final T value;
~        final long time;
~        final int maxSize;
~        final long maxAge;
~        final TimeUnit unit;
~        final Scheduler scheduler;
 
}
class io.reactivex.subjects.ReplaySubjectBoundedConcurrencyTest {
 + void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() 
+ void run() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testReplaySubjectConcurrentSubscriptions() 
+ void testSubscribeCompletionRaceCondition() 
+ void testRaceForTerminalState() 
+ void testReplaySubjectEmissionSubscriptionRace() 
# void onStart() 
+ void onComplete() 
+ void onNext(Object t) 
+ void testConcurrentSizeAndHasAnyValue() 
+ void testConcurrentSizeAndHasAnyValueBounded() 
+ void testConcurrentSizeAndHasAnyValueTimeBounded() 
        - final ReplaySubject<String> subject;
 
}
class io.reactivex.subjects.ReplaySubjectConcurrencyTest {
 + void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() 
+ void run() 
+ void onError(Throwable e) 
+ void onNext(Long args) 
+ void testReplaySubjectConcurrentSubscriptions() 
+ void testSubscribeCompletionRaceCondition() 
+ void testRaceForTerminalState() 
+ void testReplaySubjectEmissionSubscriptionRace() 
+ void onComplete() 
+ void onNext(Object t) 
+ void testConcurrentSizeAndHasAnyValue() 
        - final ReplaySubject<String> subject;
 
}
class io.reactivex.subjects.ReplaySubjectTest {
 + void testCompleted() 
+ void testCompletedStopsEmittingData() 
+ void testCompletedAfterError() 
- void assertCompletedSubscriber(Observer<String> observer) 
+ void testError() 
- void assertErrorSubscriber(Observer<String> observer) 
+ void testSubscribeMidSequence() 
+ void testUnsubscribeFirstSubscriber() 
- void assertObservedUntilTwo(Observer<String> observer) 
+ void testNewSubscriberDoesntBlockExisting() 
+ void onError(Throwable e) 
+ void onNext(String v) 
+ void onComplete() 
+ void testSubscriptionLeak() 
+ void testUnsubscriptionCase() 
+ void onNext(String t) 
+ void testTerminateOnce() 
+ void testReplay1AfterTermination() 
+ void testReplay1Directly() 
+ void testReplayTimestampedAfterTermination() 
+ void testReplayTimestampedDirectly() 
+ void testOnErrorThrowsDoesntPreventDelivery() 
+ void testOnErrorThrowsDoesntPreventDelivery2() 
+ void testCurrentStateMethodsNormal() 
+ void testCurrentStateMethodsEmpty() 
+ void testCurrentStateMethodsError() 
+ void testSizeAndHasAnyValueUnbounded() 
+ void testSizeAndHasAnyValueEffectivelyUnbounded() 
+ void testSizeAndHasAnyValueUnboundedError() 
+ void testSizeAndHasAnyValueEffectivelyUnboundedError() 
+ void testSizeAndHasAnyValueUnboundedEmptyError() 
+ void testSizeAndHasAnyValueEffectivelyUnboundedEmptyError() 
+ void testSizeAndHasAnyValueUnboundedEmptyCompleted() 
+ void testSizeAndHasAnyValueEffectivelyUnboundedEmptyCompleted() 
+ void testSizeAndHasAnyValueSizeBounded() 
+ void testSizeAndHasAnyValueTimeBounded() 
+ void testGetValues() 
+ void testGetValuesUnbounded() 
+ void createInvalidCapacity() 
+ void createWithSizeInvalidCapacity() 
+ void createWithTimeAndSizeInvalidCapacity() 
+ void hasSubscribers() 
+ void peekStateUnbounded() 
+ void peekStateTimeAndSize() 
+ void peekStateTimeAndSizeValue() 
+ void onNextNull() 
+ void onErrorNull() 
+ void capacityHint() 
+ void subscribeCancelRace() 
+ void run() 
+ void subscribeAfterDone() 
+ void subscribeRace() 
+ void cancelUpfront() 
+ void cancelRace() 
+ void sizeboundReplayError() 
+ void sizeAndTimeBoundReplayError() 
+ void timedSkipOld() 
+ void takeSizeAndTime() 
+ void takeSize() 
+ void reentrantDrain() 
+ void dispose() 
+ void timedNoOutdatedData() 
 
}
class io.reactivex.subjects.SerializedSubject {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean test(Object o) 
+ boolean hasObservers() 
+ boolean hasThrowable() 
+ Throwable getThrowable() 
+ boolean hasComplete() 
~    final Subject<T> actual;
 
}
class io.reactivex.subjects.SerializedSubjectTest {
 + void testBasic() 
+ void testAsyncSubjectValueRelay() 
+ void testAsyncSubjectValueEmpty() 
+ void testAsyncSubjectValueError() 
+ void testPublishSubjectValueRelay() 
+ void testPublishSubjectValueEmpty() 
+ void testPublishSubjectValueError() 
+ void testBehaviorSubjectValueRelay() 
+ void testBehaviorSubjectValueRelayIncomplete() 
+ void testBehaviorSubjectIncompleteEmpty() 
+ void testBehaviorSubjectEmpty() 
+ void testBehaviorSubjectError() 
+ void testReplaySubjectValueRelay() 
+ void testReplaySubjectValueRelayIncomplete() 
+ void testReplaySubjectValueRelayBounded() 
+ void testReplaySubjectValueRelayBoundedIncomplete() 
+ void testReplaySubjectValueRelayBoundedEmptyIncomplete() 
+ void testReplaySubjectValueRelayEmptyIncomplete() 
+ void testReplaySubjectEmpty() 
+ void testReplaySubjectError() 
+ void testReplaySubjectBoundedEmpty() 
+ void testReplaySubjectBoundedError() 
+ void testDontWrapSerializedSubjectAgain() 
+ void normal() 
+ void onNextOnNextRace() 
+ void run() 
+ void onNextOnErrorRace() 
+ void onNextOnCompleteRace() 
+ void onNextOnSubscribeRace() 
+ void onCompleteOnSubscribeRace() 
+ void onCompleteOnCompleteRace() 
+ void onErrorOnErrorRace() 
+ void onSubscribeOnSubscribeRace() 
 
}
class io.reactivex.subjects.Single
class io.reactivex.subjects.SingleSubject {
 + void onSubscribe(@NonNull Disposable d) 
+ void onSuccess(@NonNull T value) 
+ void onError(@NonNull Throwable e) 
# void subscribeActual(@NonNull SingleObserver<? super T> observer) 
+ T getValue() 
+ boolean hasValue() 
+ Throwable getThrowable() 
+ boolean hasThrowable() 
+ boolean hasObservers() 
+ void dispose() 
+ boolean isDisposed() 
~    final AtomicReference<SingleDisposable<T>[]> observers;
~    final AtomicBoolean once;
 
}
class io.reactivex.subjects.SingleSubjectTest {
 + void success() 
+ void once() 
+ void error() 
+ void nullValue() 
+ void nullThrowable() 
+ void cancelOnArrival() 
+ void cancelOnArrival2() 
+ void dispose() 
+ void disposeTwice() 
+ void onSuccess(Object value) 
+ void onError(Throwable e) 
+ void onSubscribeDispose() 
+ void addRemoveRace() 
+ void run() 
 
}
class io.reactivex.subjects.UnicastSubject {
 # void subscribeActual(Observer<? super T> observer) 
+ void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ boolean hasObservers() 
+ Throwable getThrowable() 
+ boolean hasThrowable() 
+ boolean hasComplete() 
+ int requestFusion(int mode) 
+ T poll() 
+ boolean isEmpty() 
+ void clear() 
+ void dispose() 
+ boolean isDisposed() 
~    final SpscLinkedArrayQueue<T> queue;
~    final AtomicReference<Runnable> onTerminate;
~    final boolean delayError;
~    final AtomicBoolean once;
~    final BasicIntQueueDisposable<T> wip;
 
}
class io.reactivex.subjects.UnicastSubjectTest {
 + void fusionLive() 
+ void fusionOfflie() 
+ void failFast() 
+ void threeArgsFactoryFailFast() 
+ void threeArgsFactoryDelayError() 
+ void fusionOfflineFailFast() 
+ void fusionOfflineFailFastMultipleEvents() 
+ void failFastMultipleEvents() 
+ void onTerminateCalledWhenOnError() 
+ void onTerminateCalledWhenOnComplete() 
+ void onTerminateCalledWhenCanceled() 
+ void nullOnTerminate() 
+ void negativeCapacityHint() 
+ void zeroCapacityHint() 
+ void onNextNull() 
+ void onErrorNull() 
+ void onNextNullDelayed() 
+ void onErrorNullDelayed() 
+ void completeCancelRace() 
+ void run() 
+ void afterDone() 
+ void onErrorStatePeeking() 
+ void rejectSyncFusion() 
+ void cancelOnArrival() 
+ void multiSubscriber() 
+ void fusedDrainCancel() 
+ void dispose() 
 
}
class io.reactivex.subscribers.DefaultSubscriberTest {
 # void onStart() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void requestUpfront() 
 
}
class io.reactivex.subscribers.DisposableSubscriberTest {
 # void onStart() 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void normal() 
+ void startOnce() 
+ void dispose() 
 
}
class io.reactivex.subscribers.ResourceSubscriberTest {
 # void onStart() 
+ void onNext(T value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void nullResource() 
+ void addResources() 
+ void onCompleteCleansUp() 
+ void onErrorCleansUp() 
+ void normal() 
+ void startOnce() 
+ void dispose() 
+ void request() 
+ void onNext(Integer t) 
+ void onError(Throwable t) 
+ void requestUpfront() 
 
}
class io.reactivex.subscribers.SafeSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
 
}
class io.reactivex.subscribers.SafeSubscriberTest {
 + void testOnNextAfterOnError() 
+ void testOnCompletedAfterOnError() 
+ void testOnNextAfterOnCompleted() 
+ void testOnErrorAfterOnCompleted() 
+ void sendOnCompleted() 
+ void sendOnNext(String value) 
+ void sendOnError(Throwable e) 
+ void subscribe(Subscriber<? super String> observer) 
+ void request(long n) 
+ void onNextFailure() 
+ void onNextFailureSafe() 
+ void onCompleteFailure() 
+ void onErrorFailure() 
+ void onErrorFailureSafe() 
+ void onErrorNotImplementedFailureSafe() 
+ void onNextOnErrorFailure() 
+ void onNextOnErrorFailureSafe() 
+ void cancel() 
+ void onCompleteSuccessWithUnsubscribeFailure() 
+ void onErrorSuccessWithUnsubscribeFailure() 
+ void onErrorFailureWithUnsubscribeFailure() 
+ void onErrorNotImplementedFailureWithUnsubscribeFailure() 
- {static} Subscriber<String> OBSERVER_SUCCESS() 
+ void onError(Throwable e) 
+ void onNext(String args) 
- {static} Subscriber<String> OBSERVER_SUCCESS(final AtomicReference<Throwable> onError) 
- {static} Subscriber<String> OBSERVER_ONNEXT_FAIL(final AtomicReference<Throwable> onError) 
- {static} Subscriber<String> OBSERVER_ONNEXT_ONERROR_FAIL() 
- {static} Subscriber<String> OBSERVER_ONERROR_FAIL() 
- {static} Subscriber<String> OBSERVER_ONERROR_NOTIMPLEMENTED() 
- {static} Subscriber<String> OBSERVER_ONCOMPLETED_FAIL(final AtomicReference<Throwable> onError) 
+ void testOnCompletedThrows() 
+ void onComplete() 
+ void testActual() 
+ void dispose() 
+ void onNextAfterComplete() 
+ void onNextNull() 
+ void onNextWithoutOnSubscribe() 
+ void onErrorWithoutOnSubscribe() 
+ void onCompleteWithoutOnSubscribe() 
+ void onNextNormal() 
+ void onSubscribe(Subscription s) 
+ void onNext(Object value) 
+ SafeSubscriber<Object> toSafe() 
+ CrashDummy assertError(Class<? extends Throwable> clazz) 
+ CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz) 
+ CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz, String message) 
+ void onNextOnErrorCrash() 
+ void onNextDisposeCrash() 
+ void onSubscribeTwice() 
+ void onSubscribeCrashes() 
+ void onSubscribeAndDisposeCrashes() 
+ void onNextOnSubscribeCrash() 
+ void onNextNullDisposeCrashes() 
+ void noSubscribeOnErrorCrashes() 
+ void onErrorNull() 
+ void onErrorNoSubscribeCrash() 
+ void onErrorNoSubscribeOnErrorCrash() 
+ void onCompleteteCrash() 
+ void onCompleteteNoSubscribeCrash() 
+ void onCompleteteNoSubscribeOnErrorCrash() 
+ void requestCrash() 
+ void cancelCrash() 
+ void requestCancelCrash() 
~        final boolean crashOnSubscribe;
~        final boolean crashOnError;
~        final boolean crashOnComplete;
~        final boolean crashDispose;
~        final boolean crashRequest;
 
}
class io.reactivex.subscribers.SafeSubscriberWithPluginTest {
 + void cancel() 
+ void request(long n) 
+ void resetBefore() 
+ void testOnCompletedThrows() 
+ void testOnCompletedThrows2() 
+ void testPluginException() 
+ void onComplete() 
+ void testPluginExceptionWhileOnErrorUnsubscribeThrows() 
+ void testPluginExceptionWhileOnErrorThrowsNotImplAndUnsubscribeThrows() 
+ void onError(Throwable e) 
+ void testPluginExceptionWhileOnErrorThrows() 
+ void testPluginExceptionWhileOnErrorThrowsAndUnsubscribeThrows() 
+ void testPluginExceptionWhenUnsubscribing2() 
+ void testPluginErrorHandlerReceivesExceptionWhenUnsubscribeAfterCompletionThrows() 
+ void testPluginErrorHandlerReceivesExceptionFromFailingUnsubscribeAfterCompletionThrows() 
 
}
class io.reactivex.subscribers.SerializedSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void cancel() 
~    final boolean delayError;
 
}
class io.reactivex.subscribers.SerializedSubscriberTest {
 + void before() 
- Subscriber<String> serializedSubscriber(Subscriber<String> o) 
+ void testSingleThreadedBasic() 
+ void testMultiThreadedBasic() 
+ void testMultiThreadedWithNPE() 
+ void testMultiThreadedWithNPEinMiddle() 
+ void runOutOfOrderConcurrencyTest() 
+ void runConcurrencyTest() 
+ void testNotificationDelay() 
+ void onError(Throwable e) 
+ void onNext(String t) 
+ void testThreadStarvation() 
+ void onError(Throwable t) 
+ void onComplete() 
- {static} void waitOnThreads(Future<?>... futures) 
- {static} Flowable<String> infinite(final AtomicInteger produced) 
+ void run() 
+ void onNext(String args) 
+ int assertEvents(TestConcurrencySubscriberEvent expectedEndingEvent) 
+ void subscribe(final Subscriber<? super String> observer) 
+ void waitToFinish() 
# void captureMaxThreads() 
+ void testSerializeNull() 
+ void testSerializeAllowsOnError() 
+ void testSerializeReentrantNullAndComplete() 
+ void testSerializeReentrantNullAndError() 
+ void testSerializeDrainPhaseThrows() 
+ void testErrorReentry() 
+ void testCompleteReentry() 
+ void dispose() 
+ void onCompleteRace() 
+ void onNextOnCompleteRace() 
+ void onNextOnErrorRace() 
+ void onNextOnErrorRaceDelayError() 
+ void startOnce() 
+ void onCompleteOnErrorRace() 
        - final CountDownLatch latch;
        - final Subscriber<String> observer;
        - final int numStringsToSend;
~        final AtomicInteger produced;
        - final CountDownLatch running;
        - final TestConcurrencySubscriberEvent event;
        - final int waitTime;
~        final String[] values;
        - Thread t;
 
}
class io.reactivex.subscribers.TestSubscriber {
 + void onSubscribe(Subscription s) 
# void onStart() 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ final void request(long n) 
+ final void cancel() 
+ final boolean isCancelled() 
+ final void dispose() 
+ final boolean isDisposed() 
+ final boolean hasSubscription() 
+ final TestSubscriber<T> assertSubscribed() 
+ final TestSubscriber<T> assertNotSubscribed() 
~final TestSubscriber<T> setInitialFusionMode(int mode) 
~final TestSubscriber<T> assertFusionMode(int mode) 
~{static} String fusionModeToString(int mode) 
~final TestSubscriber<T> assertFuseable() 
~final TestSubscriber<T> assertNotFuseable() 
+ final TestSubscriber<T> assertOf(Consumer<? super TestSubscriber<T>> check) 
+ final TestSubscriber<T> requestMore(long n) 
+ void onNext(Object t) 
    - final AtomicReference<Subscription> subscription;
    - final AtomicLong missedRequested;
    - QueueSubscription<T> qs;
 
}
class io.reactivex.subscribers.TestSubscriberTest {
 + void testAssert() 
+ void testAssertNotMatchCount() 
+ void testAssertNotMatchValue() 
+ void assertNeverAtNotMatchingValue() 
+ void assertNeverAtMatchingValue() 
+ void assertNeverAtMatchingPredicate() 
+ void assertNeverAtNotMatchingPredicate() 
+ void testAssertTerminalEventNotReceived() 
+ void testWrappingMock() 
+ void testWrappingMockWhenUnsubscribeInvolved() 
+ void testAssertError() 
+ void testAwaitTerminalEventWithDuration() 
+ void testAwaitTerminalEventWithDurationAndUnsubscribeOnTimeout() 
+ void testNullDelegate1() 
+ void testNullDelegate2() 
+ void testNullDelegate3() 
+ void testDelegate1() 
+ void testDelegate2() 
+ void testDelegate3() 
+ void testUnsubscribed() 
+ void testNoErrors() 
+ void testNotCompleted() 
+ void testMultipleCompletions() 
+ void testCompleted() 
+ void testMultipleCompletions2() 
+ void testMultipleErrors() 
+ void testMultipleErrors2() 
+ void testMultipleErrors3() 
+ void testMultipleErrors4() 
+ void testDifferentError() 
+ void testDifferentError2() 
+ void testDifferentError3() 
+ void testDifferentError4() 
+ void testErrorInPredicate() 
+ void testNoError() 
+ void testNoError2() 
+ void testNoError3() 
+ void testInterruptTerminalEventAwait() 
+ void testInterruptTerminalEventAwaitTimed() 
+ void testInterruptTerminalEventAwaitAndUnsubscribe() 
+ void testNoTerminalEventBut1Completed() 
+ void testNoTerminalEventBut1Error() 
+ void testNoTerminalEventBut1Error1Completed() 
+ void testNoTerminalEventBut2Errors() 
+ void testNoValues() 
+ void testValueCount() 
+ void testOnCompletedCrashCountsDownLatch() 
+ void testOnErrorCrashCountsDownLatch() 
+ void createDelegate() 
+ void assertError() 
+ boolean test(Throwable t) 
+ void emptyObserverEnum() 
+ void valueAndClass() 
+ void assertFailure() 
+ void assertFuseable() 
+ void assertTerminated() 
+ void assertOf() 
+ void accept(TestSubscriber<Integer> f) 
+ void assertResult() 
+ void await() 
+ void errors() 
+ void onNext() 
+ void fusionModeToString() 
+ void multipleTerminals() 
+ void assertValue() 
+ void onNextMisbehave() 
+ void awaitTerminalEventInterrupt() 
+ void assertTerminated2() 
+ void onSubscribe() 
+ void assertValueSequence() 
+ void assertEmpty() 
+ void awaitDoneTimed() 
+ void assertNotSubscribed() 
+ void assertErrorMultiple() 
+ void assertComplete() 
+ void completeWithoutOnSubscribe() 
+ void completeDelegateThrows() 
+ void onNext(Integer value) 
+ void onError(Throwable e) 
+ void onComplete() 
+ void errorDelegateThrows() 
+ void syncQueueThrows() 
+ void asyncQueueThrows() 
+ void assertValuePredicateEmpty() 
+ void assertValuePredicateMatch() 
+ void assertValuePredicateNoMatch() 
+ void assertValuePredicateMatchButMore() 
+ void assertValueAtPredicateEmpty() 
+ void assertValueAtPredicateMatch() 
+ void assertValueAtPredicateNoMatch() 
+ void assertValueAtInvalidIndex() 
+ void requestMore() 
+ void withTag() 
+ void timeoutIndicated() 
+ void timeoutIndicated2() 
+ void timeoutIndicated3() 
+ void disposeIndicated() 
+ void checkTestWaitStrategyEnum() 
+ void awaitCount() 
+ void awaitCountLess() 
+ void awaitCountLess2() 
+ void awaitCountLess3() 
+ void interruptTestWaitStrategy() 
+ void awaitCountTimeout() 
+ void assertTimeout() 
+ void assertTimeout2() 
+ void assertNoTimeout() 
+ void assertNoTimeout2() 
+ void assertNeverPredicateThrows() 
+ void assertValueAtPredicateThrows() 
+ void waitStrategyRuns() 
 
}
class io.reactivex.tck.AllTckTest {
 + Publisher<Boolean> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.AmbArrayTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.AmbTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.AnyTckTest {
 + Publisher<Boolean> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.AsyncProcessorAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.BehaviorProcessorAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
 
}
class io.reactivex.tck.BufferBoundaryTckTest {
 + Publisher<List<Long>> createPublisher(long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.BufferExactSizeTckTest {
 + Publisher<List<Long>> createPublisher(long elements) 
 
}
class io.reactivex.tck.CacheTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.CollectTckTest {
 + Publisher<List<Integer>> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.CombineLatestArrayDelayErrorTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.CombineLatestArrayTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.CombineLatestIterableDelayErrorTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.CombineLatestIterableTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatArrayEagerTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatIterableEagerTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatMapIterableTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatMapTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatPublisherEagerTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatPublisherTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ConcatTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.CreateTckTest {
 + Publisher<Long> createPublisher(final long elements) 
 
}
class io.reactivex.tck.DefaultIfEmptyTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DeferTckTest {
 + Publisher<Long> createPublisher(final long elements) 
 
}
class io.reactivex.tck.DelaySubscriptionTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DelayTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DistinctTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DistinctUntilChangedTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DoAfterNextTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DoFinallyTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.DoOnNextTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ElementAtTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.EmptyTckTest {
 + Publisher<Long> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.FilterTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.FirstTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.FlatMapTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.FromArrayTckTest {
 + Publisher<Long> createPublisher(long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.FromCallableTckTest {
 + Publisher<Long> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.FromFutureTckTest {
 + Publisher<Long> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.FromIterableTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.GenerateTckTest {
 + Publisher<Long> createPublisher(final long elements) 
 
}
class io.reactivex.tck.GroupByTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.HideTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.IgnoreElementsTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.IntervalRangeTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.IntervalTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.IsEmptyTckTest {
 + Publisher<Boolean> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.JustTckTest {
 + Publisher<Long> createPublisher(long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.LastTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.MapTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.MergeIterableTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.MergePublisherTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.MergeTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ObserveOnTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.OnBackpressureBufferTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.OnErrorResumeNextTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.OnErrorReturnItemTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.PublishProcessorAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
 
}
class io.reactivex.tck.PublishSelectorTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.PublishTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.PublisherVerification
class io.reactivex.tck.RangeTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.RebatchRequestsTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ReduceTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.ReduceWithTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.RepeatTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ReplayProcessorSizeBoundAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
 
}
class io.reactivex.tck.ReplayProcessorTimeBoundAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
 
}
class io.reactivex.tck.ReplayProcessorUnboundedAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
 
}
class io.reactivex.tck.ReplaySelectorTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ReplayTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.RetryTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ScanTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SequenceEqualTckTest {
 + Publisher<Boolean> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.ShareTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SingleTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.SkipLastTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SkipTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SkipUntilTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SkipWhileTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SortedTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SubscribeOnTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SwitchIfEmptyTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.SwitchMapDelayErrorTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.SwitchMapTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.SwitchOnNextTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.TakeLastTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.TakeTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.TakeUntilTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.TakeWhileTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.TimeIntervalTckTest {
 + Publisher<Timed<Integer>> createPublisher(long elements) 
 
}
class io.reactivex.tck.TimeoutTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.TimerTckTest {
 + Publisher<Long> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.TimestampTckTest {
 + Publisher<Timed<Integer>> createPublisher(long elements) 
 
}
class io.reactivex.tck.ToListTckTest {
 + Publisher<List<Integer>> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.ToMapTckTest {
 + long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.ToMultimapTckTest {
 + long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.ToSortedListTckTest {
 + Publisher<List<Integer>> createPublisher(final long elements) 
+ long maxElementsFromPublisher() 
 
}
class io.reactivex.tck.UnicastProcessorAsPublisherTckTest {
 + Publisher<Integer> createPublisher(final long elements) 
 
}
class io.reactivex.tck.UnsubscribeOnTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.UsingTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.WindowBoundaryTckTest {
 + Publisher<List<Long>> createPublisher(long elements) 
 
}
class io.reactivex.tck.WindowExactSizeTckTest {
 + Publisher<List<Long>> createPublisher(long elements) 
 
}
class io.reactivex.tck.WithLatestFromTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ZipIterableTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ZipTckTest {
 + Publisher<Long> createPublisher(long elements) 
 
}
class io.reactivex.tck.ZipWithIterableTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class io.reactivex.tck.ZipWithTckTest {
 + Publisher<Integer> createPublisher(long elements) 
 
}
class org.junit.Assert
class org.junit.rules.ExpectedException
class org.junit.rules.TestName
class org.junit.runner.Description
class org.junit.runners.model.Statement
class org.mockito.ArgumentMatchers
class org.mockito.InOrder
class org.mockito.Mockito
class org.mockito.MockitoAnnotations
class org.mockito.invocation.InvocationOnMock
class org.mockito.runners.MockitoJUnitRunner
class org.mockito.stubbing.Answer
class org.openjdk.jmh.infra.Blackhole
class org.reactivestreams.Publisher
class org.reactivestreams.Subscriber
interface Thread.UncaughtExceptionHandler
interface io.reactivex.Completable {
 + {static} Completable ambArray(final CompletableSource... sources) 
+ {static} Completable amb(final Iterable<? extends CompletableSource> sources) 
+ {static} Completable complete() 
+ {static} Completable concatArray(CompletableSource... sources) 
+ {static} Completable concat(Iterable<? extends CompletableSource> sources) 
+ {static} Completable concat(Publisher<? extends CompletableSource> sources) 
+ {static} Completable concat(Publisher<? extends CompletableSource> sources, int prefetch) 
+ void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Completable create(CompletableOnSubscribe source) 
+ {static} Completable unsafeCreate(CompletableSource source) 
+ {static} Completable defer(final Callable<? extends CompletableSource> completableSupplier) 
+ {static} Completable error(final Callable<? extends Throwable> errorSupplier) 
+ {static} Completable error(final Throwable error) 
+ {static} Completable fromAction(final Action run) 
+ {static} Completable fromCallable(final Callable<?> callable) 
+ {static} Completable fromFuture(final Future<?> future) 
+ {static} Completable fromRunnable(final Runnable run) 
+ {static} Completable mergeArray(CompletableSource... sources) 
+ {static} Completable merge(Iterable<? extends CompletableSource> sources) 
+ {static} Completable merge(Publisher<? extends CompletableSource> sources) 
+ {static} Completable merge(Publisher<? extends CompletableSource> sources, int maxConcurrency) 
- {static} Completable merge0(Publisher<? extends CompletableSource> sources, int maxConcurrency, boolean delayErrors) 
+ {static} Completable mergeArrayDelayError(CompletableSource... sources) 
+ {static} Completable mergeDelayError(Iterable<? extends CompletableSource> sources) 
+ {static} Completable mergeDelayError(Publisher<? extends CompletableSource> sources) 
+ {static} Completable mergeDelayError(Publisher<? extends CompletableSource> sources, int maxConcurrency) 
+ {static} Completable never() 
+ {static} Completable timer(long delay, TimeUnit unit) 
+ {static} Completable timer(final long delay, final TimeUnit unit, final Scheduler scheduler) 
- {static} NullPointerException toNpe(Throwable ex) 
+ {static} Completable wrap(CompletableSource source) 
+ final Completable ambWith(CompletableSource other) 
+ final Completable andThen(CompletableSource next) 
+ final void blockingAwait() 
+ final boolean blockingAwait(long timeout, TimeUnit unit) 
+ final Throwable blockingGet() 
+ final Throwable blockingGet(long timeout, TimeUnit unit) 
+ final Completable cache() 
+ final Completable compose(CompletableTransformer transformer) 
+ final Completable concatWith(CompletableSource other) 
+ final Completable delay(long delay, TimeUnit unit) 
+ final Completable delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Completable delay(final long delay, final TimeUnit unit, final Scheduler scheduler, final boolean delayError) 
+ final Completable doOnComplete(Action onComplete) 
+ final Completable doOnDispose(Action onDispose) 
+ final Completable doOnError(Consumer<? super Throwable> onError) 
+ final Completable doOnEvent(final Consumer<? super Throwable> onEvent) 
- Completable doOnLifecycle(
            final Consumer<? super Disposable> onSubscribe,
            final Consumer<? super Throwable> onError,
            final Action onComplete,
            final Action onTerminate,
            final Action onAfterTerminate,
            final Action onDispose) 
+ final Completable doOnSubscribe(Consumer<? super Disposable> onSubscribe) 
+ final Completable doOnTerminate(final Action onTerminate) 
+ final Completable doAfterTerminate(final Action onAfterTerminate) 
+ final Completable doFinally(Action onFinally) 
+ final Completable lift(final CompletableOperator onLift) 
+ final Completable mergeWith(CompletableSource other) 
+ final Completable observeOn(final Scheduler scheduler) 
+ final Completable onErrorComplete() 
+ final Completable onErrorComplete(final Predicate<? super Throwable> predicate) 
+ final Completable onErrorResumeNext(final Function<? super Throwable, ? extends CompletableSource> errorMapper) 
+ final Completable repeat() 
+ final Completable repeat(long times) 
+ final Completable repeatUntil(BooleanSupplier stop) 
+ final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final Completable retry() 
+ final Completable retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Completable retry(long times) 
+ final Completable retry(Predicate<? super Throwable> predicate) 
+ final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final Completable startWith(CompletableSource other) 
+ final Completable hide() 
+ final Disposable subscribe() 
+ final void subscribe(CompletableObserver s) 
# {abstract} void subscribeActual(CompletableObserver s)
+ final Disposable subscribe(final Action onComplete, final Consumer<? super Throwable> onError) 
+ final Disposable subscribe(final Action onComplete) 
+ final Completable subscribeOn(final Scheduler scheduler) 
+ final Completable timeout(long timeout, TimeUnit unit) 
+ final Completable timeout(long timeout, TimeUnit unit, CompletableSource other) 
+ final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) 
- Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) 
+ final Completable unsubscribeOn(final Scheduler scheduler) 
+ final TestObserver<Void> test() 
+ final TestObserver<Void> test(boolean cancelled) 
 
}Emitter
interface io.reactivex.CompletableObserver {
  
}
interface io.reactivex.CompletableOnSubscribe {
  
}
interface io.reactivex.CompletableOperator {
  
}
interface io.reactivex.CompletableSource {
  
}
interface io.reactivex.CompletableTransformer {
  
}
interface io.reactivex.Emitter {
  
}
interface io.reactivex.Flowable {
 + {static} int bufferSize() 
+ void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) 
+ {static} Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Flowable<Long> interval(long period, TimeUnit unit) 
+ {static} Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) 
+ {static} Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Flowable<Integer> range(int start, int count) 
+ {static} Flowable<Long> rangeLong(long start, long count) 
+ {static} Flowable<Long> timer(long delay, TimeUnit unit) 
+ {static} Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Single<Boolean> all(Predicate<? super T> predicate) 
+ final Flowable<T> ambWith(Publisher<? extends T> other) 
+ final Single<Boolean> any(Predicate<? super T> predicate) 
+ final T blockingFirst() 
+ final T blockingFirst(T defaultItem) 
+ final void blockingForEach(Consumer<? super T> onNext) 
+ final Iterable<T> blockingIterable() 
+ final Iterable<T> blockingIterable(int bufferSize) 
+ final T blockingLast() 
+ final T blockingLast(T defaultItem) 
+ final Iterable<T> blockingLatest() 
+ final Iterable<T> blockingMostRecent(T initialItem) 
+ final Iterable<T> blockingNext() 
+ final T blockingSingle() 
+ final T blockingSingle(T defaultItem) 
+ final Future<T> toFuture() 
+ final void blockingSubscribe() 
+ final void blockingSubscribe(Consumer<? super T> onNext) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) 
+ final void blockingSubscribe(Subscriber<? super T> subscriber) 
+ final Flowable<List<T>> buffer(int count) 
+ final Flowable<List<T>> buffer(int count, int skip) 
+ final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) 
+ final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) 
+ final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> cache() 
+ final Flowable<T> cacheWithInitialCapacity(int initialCapacity) 
+ final Flowable<T> concatWith(Publisher<? extends T> other) 
+ final Single<Boolean> contains(final Object item) 
+ final Single<Long> count() 
+ final Flowable<T> debounce(long timeout, TimeUnit unit) 
+ final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> defaultIfEmpty(T defaultItem) 
+ final Flowable<T> delay(long delay, TimeUnit unit) 
+ final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) 
+ final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Flowable<T> delaySubscription(long delay, TimeUnit unit) 
+ final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> distinct() 
+ final Flowable<T> distinctUntilChanged() 
+ final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) 
+ final Flowable<T> doFinally(Action onFinally) 
+ final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) 
+ final Flowable<T> doAfterTerminate(Action onAfterTerminate) 
+ final Flowable<T> doOnCancel(Action onCancel) 
+ final Flowable<T> doOnComplete(Action onComplete) 
- Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete, Action onAfterTerminate) 
+ final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) 
+ final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) 
+ final Flowable<T> doOnError(Consumer<? super Throwable> onError) 
+ final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe,
            final LongConsumer onRequest, final Action onCancel) 
+ final Flowable<T> doOnNext(Consumer<? super T> onNext) 
+ final Flowable<T> doOnRequest(LongConsumer onRequest) 
+ final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) 
+ final Flowable<T> doOnTerminate(final Action onTerminate) 
+ final Maybe<T> elementAt(long index) 
+ final Single<T> elementAt(long index, T defaultItem) 
+ final Single<T> elementAtOrError(long index) 
+ final Flowable<T> filter(Predicate<? super T> predicate) 
+ final Maybe<T> firstElement() 
+ final Single<T> first(T defaultItem) 
+ final Single<T> firstOrError() 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors, int maxConcurrency) 
+ final Disposable forEach(Consumer<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,
            final Action onComplete) 
+ final Flowable<T> hide() 
+ final Completable ignoreElements() 
+ final Single<Boolean> isEmpty() 
+ final Maybe<T> lastElement() 
+ final Single<T> last(T defaultItem) 
+ final Single<T> lastOrError() 
+ final Flowable<Notification<T>> materialize() 
+ final Flowable<T> mergeWith(Publisher<? extends T> other) 
+ final Flowable<T> observeOn(Scheduler scheduler) 
+ final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) 
+ final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> onBackpressureBuffer() 
+ final Flowable<T> onBackpressureBuffer(boolean delayError) 
+ final Flowable<T> onBackpressureBuffer(int capacity) 
+ final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) 
+ final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) 
+ final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,
            Action onOverflow) 
+ final Flowable<T> onBackpressureBuffer(int capacity, Action onOverflow) 
+ final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) 
+ final Flowable<T> onBackpressureDrop() 
+ final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) 
+ final Flowable<T> onBackpressureLatest() 
+ final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) 
+ final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) 
+ final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) 
+ final Flowable<T> onErrorReturnItem(final T item) 
+ final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) 
+ final Flowable<T> onTerminateDetach() 
+ final ParallelFlowable<T> parallel() 
+ final ParallelFlowable<T> parallel(int parallelism) 
+ final ParallelFlowable<T> parallel(int parallelism, int prefetch) 
+ final ConnectableFlowable<T> publish() 
+ final ConnectableFlowable<T> publish(int bufferSize) 
+ final Flowable<T> rebatchRequests(int n) 
+ final Maybe<T> reduce(BiFunction<T, T, T> reducer) 
+ final Flowable<T> repeat() 
+ final Flowable<T> repeat(long times) 
+ final Flowable<T> repeatUntil(BooleanSupplier stop) 
+ final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final ConnectableFlowable<T> replay() 
+ final ConnectableFlowable<T> replay(final int bufferSize) 
+ final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) 
+ final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) 
+ final ConnectableFlowable<T> replay(long time, TimeUnit unit) 
+ final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableFlowable<T> replay(final Scheduler scheduler) 
+ final Flowable<T> retry() 
+ final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Flowable<T> retry(long count) 
+ final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) 
+ final Flowable<T> retry(Predicate<? super Throwable> predicate) 
+ final Flowable<T> retryUntil(final BooleanSupplier stop) 
+ final Flowable<T> retryWhen(
            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final void safeSubscribe(Subscriber<? super T> s) 
+ final Flowable<T> sample(long period, TimeUnit unit) 
+ final Flowable<T> sample(long period, TimeUnit unit, boolean emitLast) 
+ final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) 
+ final Flowable<T> scan(BiFunction<T, T, T> accumulator) 
+ final Flowable<T> serialize() 
+ final Flowable<T> share() 
+ final Maybe<T> singleElement() 
+ final Single<T> single(T defaultItem) 
+ final Single<T> singleOrError() 
+ final Flowable<T> skip(long count) 
+ final Flowable<T> skip(long time, TimeUnit unit) 
+ final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> skipLast(int count) 
+ final Flowable<T> skipLast(long time, TimeUnit unit) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> skipWhile(Predicate<? super T> predicate) 
+ final Flowable<T> sorted() 
+ final Flowable<T> sorted(Comparator<? super T> sortFunction) 
+ final Flowable<T> startWith(Iterable<? extends T> items) 
+ final Flowable<T> startWith(Publisher<? extends T> other) 
+ final Flowable<T> startWith(T value) 
+ final Flowable<T> startWithArray(T... items) 
+ final Disposable subscribe() 
+ final Disposable subscribe(Consumer<? super T> onNext) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete, Consumer<? super Subscription> onSubscribe) 
+ final void subscribe(Subscriber<? super T> s) 
+ final void subscribe(FlowableSubscriber<? super T> s) 
# {abstract} void subscribeActual(Subscriber<? super T> s)
+ final Flowable<T> subscribeOn(Scheduler scheduler) 
+ final Flowable<T> switchIfEmpty(Publisher<? extends T> other) 
+ final Flowable<T> take(long count) 
+ final Flowable<T> take(long time, TimeUnit unit) 
+ final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> takeLast(int count) 
+ final Flowable<T> takeLast(long count, long time, TimeUnit unit) 
+ final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> takeLast(long time, TimeUnit unit) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) 
+ final Flowable<T> takeWhile(Predicate<? super T> predicate) 
+ final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) 
+ final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) 
+ final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) 
+ final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<Timed<T>> timeInterval() 
+ final Flowable<Timed<T>> timeInterval(Scheduler scheduler) 
+ final Flowable<Timed<T>> timeInterval(TimeUnit unit) 
+ final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Publisher<? extends T> other) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher<? extends T> other) 
+ final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) 
- Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Publisher<? extends T> other,
            Scheduler scheduler) 
+ final Flowable<Timed<T>> timestamp() 
+ final Flowable<Timed<T>> timestamp(Scheduler scheduler) 
+ final Flowable<Timed<T>> timestamp(TimeUnit unit) 
+ final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) 
+ final Single<List<T>> toList() 
+ final Single<List<T>> toList(final int capacityHint) 
+ final Observable<T> toObservable() 
+ final Single<List<T>> toSortedList() 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator) 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) 
+ final Single<List<T>> toSortedList(int capacityHint) 
+ final Flowable<T> unsubscribeOn(Scheduler scheduler) 
+ final Flowable<Flowable<T>> window(long count) 
+ final Flowable<Flowable<T>> window(long count, long skip) 
+ final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) 
+ final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) 
+ final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            long count) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            long count, boolean restart) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count) 
+ final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count, boolean restart) 
+ final Flowable<Flowable<T>> window(
            long timespan, TimeUnit unit, Scheduler scheduler,
            long count, boolean restart, int bufferSize) 
+ final TestSubscriber<T> test() 
+ final TestSubscriber<T> test(long initialRequest) 
+ final TestSubscriber<T> test(long initialRequest, boolean cancel) 
~    {static} final int BUFFER_SIZE;
 
}Emitter
interface io.reactivex.FlowableOnSubscribe {
  
}
interface io.reactivex.FlowableOperator {
  
}
interface io.reactivex.FlowableSubscriber {
  
}
interface io.reactivex.FlowableTransformer {
  
}
interface io.reactivex.Maybe {
 + void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Maybe<Long> timer(long delay, TimeUnit unit) 
+ {static} Maybe<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Maybe<T> ambWith(MaybeSource<? extends T> other) 
+ final T blockingGet() 
+ final T blockingGet(T defaultValue) 
+ final Maybe<T> cache() 
+ final Flowable<T> concatWith(MaybeSource<? extends T> other) 
+ final Single<Boolean> contains(final Object item) 
+ final Single<Long> count() 
+ final Maybe<T> defaultIfEmpty(T defaultItem) 
+ final Maybe<T> delay(long delay, TimeUnit unit) 
+ final Maybe<T> delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Maybe<T> delaySubscription(long delay, TimeUnit unit) 
+ final Maybe<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Maybe<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) 
+ final Maybe<T> doAfterTerminate(Action onAfterTerminate) 
+ final Maybe<T> doFinally(Action onFinally) 
+ final Maybe<T> doOnDispose(Action onDispose) 
+ final Maybe<T> doOnComplete(Action onComplete) 
+ final Maybe<T> doOnError(Consumer<? super Throwable> onError) 
+ final Maybe<T> doOnEvent(BiConsumer<? super T, ? super Throwable> onEvent) 
+ final Maybe<T> doOnSubscribe(Consumer<? super Disposable> onSubscribe) 
+ final Maybe<T> doOnSuccess(Consumer<? super T> onSuccess) 
+ final Maybe<T> filter(Predicate<? super T> predicate) 
+ final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) 
+ final Maybe<T> hide() 
+ final Completable ignoreElement() 
+ final Single<Boolean> isEmpty() 
+ final Flowable<T> mergeWith(MaybeSource<? extends T> other) 
+ final Maybe<T> observeOn(final Scheduler scheduler) 
+ final Flowable<T> toFlowable() 
+ final Observable<T> toObservable() 
+ final Single<T> toSingle(T defaultValue) 
+ final Single<T> toSingle() 
+ final Maybe<T> onErrorComplete() 
+ final Maybe<T> onErrorComplete(final Predicate<? super Throwable> predicate) 
+ final Maybe<T> onErrorResumeNext(final MaybeSource<? extends T> next) 
+ final Maybe<T> onErrorResumeNext(Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) 
+ final Maybe<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) 
+ final Maybe<T> onErrorReturnItem(final T item) 
+ final Maybe<T> onExceptionResumeNext(final MaybeSource<? extends T> next) 
+ final Maybe<T> onTerminateDetach() 
+ final Flowable<T> repeat() 
+ final Flowable<T> repeat(long times) 
+ final Flowable<T> repeatUntil(BooleanSupplier stop) 
+ final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final Maybe<T> retry() 
+ final Maybe<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Maybe<T> retry(long count) 
+ final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) 
+ final Maybe<T> retry(Predicate<? super Throwable> predicate) 
+ final Maybe<T> retryUntil(final BooleanSupplier stop) 
+ final Maybe<T> retryWhen(
            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final Disposable subscribe() 
+ final Disposable subscribe(Consumer<? super T> onSuccess) 
+ final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? super Throwable> onError) 
+ final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? super Throwable> onError,
            Action onComplete) 
+ final void subscribe(MaybeObserver<? super T> observer) 
# {abstract} void subscribeActual(MaybeObserver<? super T> observer)
+ final Maybe<T> subscribeOn(Scheduler scheduler) 
+ final Maybe<T> switchIfEmpty(MaybeSource<? extends T> other) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit, MaybeSource<? extends T> fallback) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, MaybeSource<? extends T> fallback) 
+ final Maybe<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) 
+ final Maybe<T> unsubscribeOn(final Scheduler scheduler) 
+ final TestObserver<T> test() 
+ final TestObserver<T> test(boolean cancelled) 
 
}Emitter
interface io.reactivex.MaybeObserver {
  
}
interface io.reactivex.MaybeOnSubscribe {
  
}
interface io.reactivex.MaybeOperator {
  
}
interface io.reactivex.MaybeSource {
  
}
interface io.reactivex.MaybeTransformer {
  
}
interface io.reactivex.Observable {
 + {static} int bufferSize() 
+ void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Observable<Long> interval(long initialDelay, long period, TimeUnit unit) 
+ {static} Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Observable<Long> interval(long period, TimeUnit unit) 
+ {static} Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) 
+ {static} Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 
+ {static} Observable<Integer> range(final int start, final int count) 
+ {static} Observable<Long> rangeLong(long start, long count) 
+ {static} Observable<Long> timer(long delay, TimeUnit unit) 
+ {static} Observable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Single<Boolean> all(Predicate<? super T> predicate) 
+ final Observable<T> ambWith(ObservableSource<? extends T> other) 
+ final Single<Boolean> any(Predicate<? super T> predicate) 
+ final T blockingFirst() 
+ final T blockingFirst(T defaultItem) 
+ final void blockingForEach(Consumer<? super T> onNext) 
+ final Iterable<T> blockingIterable() 
+ final Iterable<T> blockingIterable(int bufferSize) 
+ final T blockingLast() 
+ final T blockingLast(T defaultItem) 
+ final Iterable<T> blockingLatest() 
+ final Iterable<T> blockingMostRecent(T initialValue) 
+ final Iterable<T> blockingNext() 
+ final T blockingSingle() 
+ final T blockingSingle(T defaultItem) 
+ final Future<T> toFuture() 
+ final void blockingSubscribe() 
+ final void blockingSubscribe(Consumer<? super T> onNext) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) 
+ final void blockingSubscribe(Observer<? super T> subscriber) 
+ final Observable<List<T>> buffer(int count) 
+ final Observable<List<T>> buffer(int count, int skip) 
+ final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) 
+ final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit, int count) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) 
+ final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> cache() 
+ final Observable<T> cacheWithInitialCapacity(int initialCapacity) 
+ final Observable<T> concatWith(ObservableSource<? extends T> other) 
+ final Single<Boolean> contains(final Object element) 
+ final Single<Long> count() 
+ final Observable<T> debounce(long timeout, TimeUnit unit) 
+ final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> defaultIfEmpty(T defaultItem) 
+ final Observable<T> delay(long delay, TimeUnit unit) 
+ final Observable<T> delay(long delay, TimeUnit unit, boolean delayError) 
+ final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Observable<T> delaySubscription(long delay, TimeUnit unit) 
+ final Observable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> distinct() 
+ final Observable<T> distinctUntilChanged() 
+ final Observable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) 
+ final Observable<T> doAfterNext(Consumer<? super T> onAfterNext) 
+ final Observable<T> doAfterTerminate(Action onFinally) 
+ final Observable<T> doFinally(Action onFinally) 
+ final Observable<T> doOnDispose(Action onDispose) 
+ final Observable<T> doOnComplete(Action onComplete) 
- Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) 
+ final Observable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) 
+ final Observable<T> doOnEach(final Observer<? super T> observer) 
+ final Observable<T> doOnError(Consumer<? super Throwable> onError) 
+ final Observable<T> doOnLifecycle(final Consumer<? super Disposable> onSubscribe, final Action onDispose) 
+ final Observable<T> doOnNext(Consumer<? super T> onNext) 
+ final Observable<T> doOnSubscribe(Consumer<? super Disposable> onSubscribe) 
+ final Observable<T> doOnTerminate(final Action onTerminate) 
+ final Maybe<T> elementAt(long index) 
+ final Single<T> elementAt(long index, T defaultItem) 
+ final Single<T> elementAtOrError(long index) 
+ final Observable<T> filter(Predicate<? super T> predicate) 
+ final Maybe<T> firstElement() 
+ final Single<T> first(T defaultItem) 
+ final Single<T> firstOrError() 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) 
+ final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors) 
+ final Disposable forEach(Consumer<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext) 
+ final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer<? super Throwable> onError,
            final Action onComplete) 
+ final Observable<T> hide() 
+ final Completable ignoreElements() 
+ final Single<Boolean> isEmpty() 
+ final Maybe<T> lastElement() 
+ final Single<T> last(T defaultItem) 
+ final Single<T> lastOrError() 
+ final Observable<Notification<T>> materialize() 
+ final Observable<T> mergeWith(ObservableSource<? extends T> other) 
+ final Observable<T> observeOn(Scheduler scheduler) 
+ final Observable<T> observeOn(Scheduler scheduler, boolean delayError) 
+ final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> onErrorResumeNext(Function<? super Throwable, ? extends ObservableSource<? extends T>> resumeFunction) 
+ final Observable<T> onErrorResumeNext(final ObservableSource<? extends T> next) 
+ final Observable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) 
+ final Observable<T> onErrorReturnItem(final T item) 
+ final Observable<T> onExceptionResumeNext(final ObservableSource<? extends T> next) 
+ final Observable<T> onTerminateDetach() 
+ final ConnectableObservable<T> publish() 
+ final Maybe<T> reduce(BiFunction<T, T, T> reducer) 
+ final Observable<T> repeat() 
+ final Observable<T> repeat(long times) 
+ final Observable<T> repeatUntil(BooleanSupplier stop) 
+ final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) 
+ final ConnectableObservable<T> replay() 
+ final ConnectableObservable<T> replay(final int bufferSize) 
+ final ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit) 
+ final ConnectableObservable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableObservable<T> replay(final int bufferSize, final Scheduler scheduler) 
+ final ConnectableObservable<T> replay(long time, TimeUnit unit) 
+ final ConnectableObservable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final ConnectableObservable<T> replay(final Scheduler scheduler) 
+ final Observable<T> retry() 
+ final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Observable<T> retry(long times) 
+ final Observable<T> retry(long times, Predicate<? super Throwable> predicate) 
+ final Observable<T> retry(Predicate<? super Throwable> predicate) 
+ final Observable<T> retryUntil(final BooleanSupplier stop) 
+ final Observable<T> retryWhen(
            final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) 
+ final void safeSubscribe(Observer<? super T> s) 
+ final Observable<T> sample(long period, TimeUnit unit) 
+ final Observable<T> sample(long period, TimeUnit unit, boolean emitLast) 
+ final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) 
+ final Observable<T> scan(BiFunction<T, T, T> accumulator) 
+ final Observable<T> serialize() 
+ final Observable<T> share() 
+ final Maybe<T> singleElement() 
+ final Single<T> single(T defaultItem) 
+ final Single<T> singleOrError() 
+ final Observable<T> skip(long count) 
+ final Observable<T> skip(long time, TimeUnit unit) 
+ final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> skipLast(int count) 
+ final Observable<T> skipLast(long time, TimeUnit unit) 
+ final Observable<T> skipLast(long time, TimeUnit unit, boolean delayError) 
+ final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> skipWhile(Predicate<? super T> predicate) 
+ final Observable<T> sorted() 
+ final Observable<T> sorted(Comparator<? super T> sortFunction) 
+ final Observable<T> startWith(Iterable<? extends T> items) 
+ final Observable<T> startWith(ObservableSource<? extends T> other) 
+ final Observable<T> startWith(T item) 
+ final Observable<T> startWithArray(T... items) 
+ final Disposable subscribe() 
+ final Disposable subscribe(Consumer<? super T> onNext) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete) 
+ final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
            Action onComplete, Consumer<? super Disposable> onSubscribe) 
+ final void subscribe(Observer<? super T> observer) 
# {abstract} void subscribeActual(Observer<? super T> observer)
+ final Observable<T> subscribeOn(Scheduler scheduler) 
+ final Observable<T> switchIfEmpty(ObservableSource<? extends T> other) 
+ final Observable<T> take(long count) 
+ final Observable<T> take(long time, TimeUnit unit) 
+ final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> takeLast(int count) 
+ final Observable<T> takeLast(long count, long time, TimeUnit unit) 
+ final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> takeLast(long time, TimeUnit unit) 
+ final Observable<T> takeLast(long time, TimeUnit unit, boolean delayError) 
+ final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) 
+ final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) 
+ final Observable<T> takeUntil(Predicate<? super T> stopPredicate) 
+ final Observable<T> takeWhile(Predicate<? super T> predicate) 
+ final Observable<T> throttleFirst(long windowDuration, TimeUnit unit) 
+ final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> throttleLast(long intervalDuration, TimeUnit unit) 
+ final Observable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) 
+ final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Observable<Timed<T>> timeInterval() 
+ final Observable<Timed<T>> timeInterval(Scheduler scheduler) 
+ final Observable<Timed<T>> timeInterval(TimeUnit unit) 
+ final Observable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, ObservableSource<? extends T> other) 
+ final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) 
- Observable<T> timeout0(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other,
            Scheduler scheduler) 
+ final Observable<Timed<T>> timestamp() 
+ final Observable<Timed<T>> timestamp(Scheduler scheduler) 
+ final Observable<Timed<T>> timestamp(TimeUnit unit) 
+ final Observable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) 
+ final Single<List<T>> toList() 
+ final Single<List<T>> toList(final int capacityHint) 
+ final Flowable<T> toFlowable(BackpressureStrategy strategy) 
+ final Single<List<T>> toSortedList() 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator) 
+ final Single<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) 
+ final Single<List<T>> toSortedList(int capacityHint) 
+ final Observable<T> unsubscribeOn(Scheduler scheduler) 
+ final Observable<Observable<T>> window(long count) 
+ final Observable<Observable<T>> window(long count, long skip) 
+ final Observable<Observable<T>> window(long count, long skip, int bufferSize) 
+ final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit) 
+ final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) 
+ final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            long count) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            long count, boolean restart) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count) 
+ final Observable<Observable<T>> window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count, boolean restart) 
+ final Observable<Observable<T>> window(
            long timespan, TimeUnit unit, Scheduler scheduler,
            long count, boolean restart, int bufferSize) 
+ final TestObserver<T> test() 
+ final TestObserver<T> test(boolean dispose) 
 
}Emitter
interface io.reactivex.ObservableOnSubscribe {
  
}
interface io.reactivex.ObservableOperator {
  
}
interface io.reactivex.ObservableSource {
  
}
interface io.reactivex.ObservableTransformer {
  
}
interface io.reactivex.Observer {
  
}
interface io.reactivex.Publisher
interface io.reactivex.Single {
 + void onEvent(Event e) 
+ void onFailure(Exception e) 
+ {static} Single<Long> timer(long delay, TimeUnit unit) 
+ {static} Single<Long> timer(final long delay, final TimeUnit unit, final Scheduler scheduler) 
+ final Single<T> ambWith(SingleSource<? extends T> other) 
+ final Single<T> hide() 
+ final Single<T> cache() 
+ final Flowable<T> concatWith(SingleSource<? extends T> other) 
+ final Single<T> delay(long time, TimeUnit unit) 
+ final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler) 
+ final Single<T> delaySubscription(CompletableSource other) 
+ final Single<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) 
+ final Single<T> doAfterTerminate(Action onAfterTerminate) 
+ final Single<T> doFinally(Action onFinally) 
+ final Single<T> doOnSubscribe(final Consumer<? super Disposable> onSubscribe) 
+ final Single<T> doOnSuccess(final Consumer<? super T> onSuccess) 
+ final Single<T> doOnEvent(final BiConsumer<? super T, ? super Throwable> onEvent) 
+ final Single<T> doOnError(final Consumer<? super Throwable> onError) 
+ final Single<T> doOnDispose(final Action onDispose) 
+ final Maybe<T> filter(Predicate<? super T> predicate) 
+ final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) 
+ final T blockingGet() 
+ final Single<Boolean> contains(Object value) 
+ final Single<Boolean> contains(final Object value, final BiPredicate<Object, Object> comparer) 
+ final Flowable<T> mergeWith(SingleSource<? extends T> other) 
+ final Single<T> observeOn(final Scheduler scheduler) 
+ final Single<T> onErrorReturn(final Function<Throwable, ? extends T> resumeFunction) 
+ final Single<T> onErrorReturnItem(final T value) 
+ final Single<T> onErrorResumeNext(final Single<? extends T> resumeSingleInCaseOfError) 
+ final Single<T> onErrorResumeNext(
            final Function<? super Throwable, ? extends SingleSource<? extends T>> resumeFunctionInCaseOfError) 
+ final Flowable<T> repeat() 
+ final Flowable<T> repeat(long times) 
+ final Flowable<T> repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) 
+ final Flowable<T> repeatUntil(BooleanSupplier stop) 
+ final Single<T> retry() 
+ final Single<T> retry(long times) 
+ final Single<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) 
+ final Single<T> retry(Predicate<? super Throwable> predicate) 
+ final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) 
+ final Disposable subscribe() 
+ final Disposable subscribe(final BiConsumer<? super T, ? super Throwable> onCallback) 
+ final Disposable subscribe(Consumer<? super T> onSuccess) 
+ final Disposable subscribe(final Consumer<? super T> onSuccess, final Consumer<? super Throwable> onError) 
+ final void subscribe(SingleObserver<? super T> subscriber) 
# {abstract} void subscribeActual(@NonNull SingleObserver<? super T> observer)
+ final Single<T> subscribeOn(final Scheduler scheduler) 
+ final Single<T> takeUntil(final CompletableSource other) 
+ final Single<T> timeout(long timeout, TimeUnit unit) 
+ final Single<T> timeout(long timeout, TimeUnit unit, Scheduler scheduler) 
+ final Single<T> timeout(long timeout, TimeUnit unit, Scheduler scheduler, SingleSource<? extends T> other) 
+ final Single<T> timeout(long timeout, TimeUnit unit, SingleSource<? extends T> other) 
- Single<T> timeout0(final long timeout, final TimeUnit unit, final Scheduler scheduler, final SingleSource<? extends T> other) 
+ final Completable toCompletable() 
+ final Flowable<T> toFlowable() 
+ final Future<T> toFuture() 
+ final Maybe<T> toMaybe() 
+ final Observable<T> toObservable() 
+ final Single<T> unsubscribeOn(final Scheduler scheduler) 
+ final TestObserver<T> test() 
+ final TestObserver<T> test(boolean cancelled) 
 
}Emitter
interface io.reactivex.SingleObserver {
  
}
interface io.reactivex.SingleOnSubscribe {
  
}
interface io.reactivex.SingleOperator {
  
}
interface io.reactivex.SingleSource {
  
}
interface io.reactivex.SingleTransformer {
  
}
interface io.reactivex.Subscriber
interface io.reactivex.disposables.Disposable {
  
}
interface io.reactivex.functions.Action {
  
}
interface io.reactivex.functions.BiConsumer {
  
}
interface io.reactivex.functions.BiFunction {
  
}
interface io.reactivex.functions.BiPredicate {
  
}
interface io.reactivex.functions.BooleanSupplier {
  
}
interface io.reactivex.functions.Cancellable {
  
}
interface io.reactivex.functions.Consumer {
  
}
interface io.reactivex.functions.Function {
  
}
interface io.reactivex.functions.Function3 {
  
}
interface io.reactivex.functions.Function4 {
  
}
interface io.reactivex.functions.Function5 {
  
}
interface io.reactivex.functions.Function6 {
  
}
interface io.reactivex.functions.Function7 {
  
}
interface io.reactivex.functions.Function8 {
  
}
interface io.reactivex.functions.Function9 {
  
}
interface io.reactivex.functions.IntFunction {
  
}
interface io.reactivex.functions.LongConsumer {
  
}
interface io.reactivex.functions.Predicate {
  
}
interface io.reactivex.internal.disposables.DisposableContainer {
  
}
interface io.reactivex.internal.fuseable.ConditionalSubscriber {
  
}
interface io.reactivex.internal.fuseable.FuseToFlowable {
  
}
interface io.reactivex.internal.fuseable.FuseToMaybe {
  
}
interface io.reactivex.internal.fuseable.FuseToObservable {
  
}
interface io.reactivex.internal.fuseable.HasUpstreamCompletableSource {
  
}
interface io.reactivex.internal.fuseable.HasUpstreamMaybeSource {
  
}
interface io.reactivex.internal.fuseable.HasUpstreamObservableSource {
  
}
interface io.reactivex.internal.fuseable.HasUpstreamPublisher {
  
}
interface io.reactivex.internal.fuseable.HasUpstreamSingleSource {
  
}
interface io.reactivex.internal.fuseable.QueueDisposable {
  
}
interface io.reactivex.internal.fuseable.QueueFuseable {
  
}
interface io.reactivex.internal.fuseable.QueueSubscription {
  
}
interface io.reactivex.internal.fuseable.ScalarCallable {
  
}
interface io.reactivex.internal.fuseable.SimplePlainQueue {
  
}
interface io.reactivex.internal.fuseable.SimpleQueue {
  
}
interface io.reactivex.internal.observers.CompletableObserver
interface io.reactivex.internal.observers.Consumer
interface io.reactivex.internal.observers.Future
interface io.reactivex.internal.observers.InnerQueuedObserver {
 + void onSubscribe(Disposable s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void dispose() 
+ boolean isDisposed() 
+ boolean isDone() 
+ void setDone() 
+ SimpleQueue<T> queue() 
+ int fusionMode() 
~    final InnerQueuedObserverSupport<T> parent;
~    final int prefetch;
 
}Support
interface io.reactivex.internal.observers.MaybeObserver
interface io.reactivex.internal.observers.ObservableQueueDrain
interface io.reactivex.internal.observers.SingleObserver
interface io.reactivex.internal.observers.Subscription
interface io.reactivex.internal.operators.completable.Action
interface io.reactivex.internal.operators.completable.CompletableObserver
interface io.reactivex.internal.operators.completable.Consumer
interface io.reactivex.internal.operators.flowable.Action
interface io.reactivex.internal.operators.flowable.FuseToFlowable
interface io.reactivex.internal.operators.flowable.HasUpstreamPublisher
interface io.reactivex.internal.operators.maybe.Action
interface io.reactivex.internal.operators.maybe.FuseToMaybe
interface io.reactivex.internal.operators.maybe.HasUpstreamMaybeSource
interface io.reactivex.internal.operators.maybe.MaybeObserver
interface io.reactivex.internal.operators.observable.Action
interface io.reactivex.internal.operators.single.Action
interface io.reactivex.internal.operators.single.SingleObserver
interface io.reactivex.internal.schedulers.Callable
interface io.reactivex.internal.schedulers.Disposable
interface io.reactivex.internal.schedulers.Future
interface io.reactivex.internal.schedulers.NonBlockingThread {
  
}
interface io.reactivex.internal.subscribers.ConditionalSubscriber
interface io.reactivex.internal.subscribers.Future
interface io.reactivex.internal.subscribers.InnerQueuedSubscriber {
 + void onSubscribe(Subscription s) 
+ void onNext(T t) 
+ void onError(Throwable t) 
+ void onComplete() 
+ void request(long n) 
+ void requestOne() 
+ void cancel() 
+ boolean isDone() 
+ void setDone() 
+ SimpleQueue<T> queue() 
~    final InnerQueuedSubscriberSupport<T> parent;
~    final int prefetch;
~    final int limit;
 
}Support
interface io.reactivex.internal.subscribers.QueueDrain
interface io.reactivex.internal.subscribers.QueueSubscription
interface io.reactivex.internal.subscribers.Subscription
interface io.reactivex.internal.subscriptions.Subscription
interface io.reactivex.internal.util.Action
interface io.reactivex.internal.util.AppendOnlyLinkedArrayList {
 + void add(T value) 
+ void setFirst(T value) 
+ void forEachWhile(NonThrowingPredicate<? super T> consumer) 
~    final int capacity;
~    final Object[] head;
 
}.NonThrowingPredicate
interface io.reactivex.internal.util.BiFunction
interface io.reactivex.internal.util.CompletableObserver
interface io.reactivex.internal.util.Consumer
interface io.reactivex.internal.util.FlowableSubscriber
interface io.reactivex.internal.util.List
interface io.reactivex.internal.util.MaybeObserver
interface io.reactivex.internal.util.ObservableQueueDrain {
  
}
interface io.reactivex.internal.util.Observer
interface io.reactivex.internal.util.QueueDrain {
  
}
interface io.reactivex.internal.util.RandomAccess
interface io.reactivex.internal.util.SingleObserver
interface io.reactivex.internal.util.Subscription
interface io.reactivex.observers.CompletableObserver
interface io.reactivex.observers.MaybeObserver
interface io.reactivex.observers.Observer
interface io.reactivex.observers.SingleObserver
interface io.reactivex.parallel.Consumer
interface io.reactivex.parallel.ParallelTransformer {
  
}
interface io.reactivex.processors.FlowableSubscriber
interface io.reactivex.subjects.CompletableObserver
interface io.reactivex.subjects.MaybeObserver
interface io.reactivex.subjects.Observer
interface io.reactivex.subjects.SingleObserver
interface io.reactivex.subscribers.Subscription
interface org.junit.rules.TestRule
interface org.reactivestreams.Processor
interface org.reactivestreams.Subscription
io.reactivex.Completable --|> io.reactivex.CompletableSource
io.reactivex.Flowable --|> io.reactivex.Publisher
io.reactivex.Maybe --|> io.reactivex.MaybeSource
io.reactivex.Observable --|> io.reactivex.ObservableSource
io.reactivex.Single --|> io.reactivex.SingleSource
io.reactivex.disposables.ReferenceDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.flowables.ConnectableFlowable --|> io.reactivex.Flowable
io.reactivex.flowables.GroupedFlowable --|> io.reactivex.Flowable
io.reactivex.internal.observers.BasicFuseableObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.BasicFuseableObserver --|> io.reactivex.internal.fuseable.QueueDisposable
io.reactivex.internal.observers.BasicIntQueueDisposable --|> io.reactivex.internal.fuseable.QueueDisposable
io.reactivex.internal.observers.BasicQueueDisposable --|> io.reactivex.internal.fuseable.QueueDisposable
io.reactivex.internal.observers.BlockingBaseObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.BlockingBaseObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.DeferredScalarObserver --|> io.reactivex.internal.observers.DeferredScalarDisposable
io.reactivex.internal.observers.DeferredScalarObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.QueueDrainObserver --|> io.reactivex.internal.observers.QueueDrainSubscriberPad2
io.reactivex.internal.observers.QueueDrainObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.QueueDrainObserver --|> io.reactivex.internal.observers.ObservableQueueDrain
io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream --|> io.reactivex.internal.fuseable.HasUpstreamPublisher
io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream --|> io.reactivex.internal.fuseable.HasUpstreamMaybeSource
io.reactivex.internal.operators.observable.AbstractObservableWithUpstream --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.AbstractObservableWithUpstream --|> io.reactivex.internal.fuseable.HasUpstreamObservableSource
io.reactivex.internal.schedulers.AbstractDirectTask --|> io.reactivex.disposables.Disposable
io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber --|> io.reactivex.internal.subscribers.ConditionalSubscriber
io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber --|> io.reactivex.internal.subscribers.QueueSubscription
io.reactivex.internal.subscribers.BasicFuseableSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.BasicFuseableSubscriber --|> io.reactivex.internal.fuseable.QueueSubscription
io.reactivex.internal.subscribers.BlockingBaseSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.DeferredScalarSubscriber --|> io.reactivex.internal.subscribers.DeferredScalarSubscription
io.reactivex.internal.subscribers.DeferredScalarSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.QueueDrainSubscriber --|> io.reactivex.internal.subscribers.QueueDrainSubscriberPad4
io.reactivex.internal.subscribers.QueueDrainSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.QueueDrainSubscriber --|> io.reactivex.internal.subscribers.QueueDrain
io.reactivex.internal.subscribers.SinglePostCompleteSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.SinglePostCompleteSubscriber --|> io.reactivex.internal.subscribers.Subscription
io.reactivex.internal.subscriptions.BasicIntQueueSubscription --|> io.reactivex.internal.fuseable.QueueSubscription
io.reactivex.internal.subscriptions.BasicQueueSubscription --|> io.reactivex.internal.fuseable.QueueSubscription
io.reactivex.observables.ConnectableObservable --|> io.reactivex.observables.Observable
io.reactivex.observables.GroupedObservable --|> io.reactivex.Observable
io.reactivex.observers.BaseTestConsumer --|> io.reactivex.disposables.Disposable
io.reactivex.observers.DefaultObserver --|> io.reactivex.Observer
io.reactivex.observers.DisposableCompletableObserver --|> io.reactivex.CompletableObserver
io.reactivex.observers.DisposableCompletableObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.DisposableMaybeObserver --|> io.reactivex.MaybeObserver
io.reactivex.observers.DisposableMaybeObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.DisposableObserver --|> io.reactivex.Observer
io.reactivex.observers.DisposableObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.DisposableSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.observers.DisposableSingleObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.ResourceCompletableObserver --|> io.reactivex.CompletableObserver
io.reactivex.observers.ResourceCompletableObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.ResourceMaybeObserver --|> io.reactivex.MaybeObserver
io.reactivex.observers.ResourceMaybeObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.ResourceObserver --|> io.reactivex.Observer
io.reactivex.observers.ResourceObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.ResourceSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.observers.ResourceSingleObserver --|> io.reactivex.disposables.Disposable
io.reactivex.processors.DelayedFlowableProcessorTest --|> io.reactivex.processors.FlowableProcessorTest
io.reactivex.processors.FlowableProcessor --|> io.reactivex.processors.Flowable
io.reactivex.processors.FlowableProcessor --|> io.reactivex.processors.FlowableSubscriber
io.reactivex.processors.FlowableProcessor --|> org.reactivestreams.Processor
io.reactivex.schedulers.AbstractSchedulerConcurrencyTests --|> io.reactivex.schedulers.AbstractSchedulerTests
io.reactivex.subjects.Subject --|> io.reactivex.subjects.Observable
io.reactivex.subjects.Subject --|> io.reactivex.subjects.Observer
io.reactivex.subscribers.DefaultSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.subscribers.DisposableSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.subscribers.DisposableSubscriber --|> io.reactivex.disposables.Disposable
io.reactivex.subscribers.ResourceSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.subscribers.ResourceSubscriber --|> io.reactivex.disposables.Disposable
io.reactivex.tck.BaseTck --|> io.reactivex.tck.PublisherVerification
io.reactivex.LatchedSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.PerfAsyncConsumer --|> io.reactivex.CountDownLatch
io.reactivex.PerfAsyncConsumer --|> io.reactivex.CompletableObserver
io.reactivex.PerfAsyncConsumer --|> io.reactivex.FlowableSubscriber
io.reactivex.PerfAsyncConsumer --|> io.reactivex.MaybeObserver
io.reactivex.PerfAsyncConsumer --|> io.reactivex.Observer
io.reactivex.PerfAsyncConsumer --|> io.reactivex.SingleObserver
io.reactivex.PerfConsumer --|> io.reactivex.CompletableObserver
io.reactivex.PerfConsumer --|> io.reactivex.FlowableSubscriber
io.reactivex.PerfConsumer --|> io.reactivex.MaybeObserver
io.reactivex.PerfConsumer --|> io.reactivex.Observer
io.reactivex.PerfConsumer --|> io.reactivex.SingleObserver
io.reactivex.PerfInteropConsumer --|> io.reactivex.CompletableObserver
io.reactivex.PerfInteropConsumer --|> io.reactivex.MaybeObserver
io.reactivex.PerfInteropConsumer --|> io.reactivex.Observer
io.reactivex.PerfInteropConsumer --|> io.reactivex.SingleObserver
io.reactivex.PerfInteropConsumer --|> io.reactivex.Subscriber
io.reactivex.PerfObserver --|> io.reactivex.Observer
io.reactivex.PerfSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.ReducePerf --|> io.reactivex.functions.BiFunction
io.reactivex.Retry --|> org.junit.rules.TestRule
io.reactivex.completable.CapturingUncaughtExceptionHandler --|> Thread.UncaughtExceptionHandler
io.reactivex.disposables.ActionDisposable --|> io.reactivex.disposables.ReferenceDisposable
io.reactivex.disposables.CompositeDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.disposables.CompositeDisposable --|> io.reactivex.internal.disposables.DisposableContainer
io.reactivex.disposables.FutureDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.disposables.RunnableDisposable --|> io.reactivex.disposables.ReferenceDisposable
io.reactivex.disposables.SerialDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.disposables.SubscriptionDisposable --|> io.reactivex.disposables.ReferenceDisposable
io.reactivex.flowable.Burst --|> io.reactivex.Flowable
io.reactivex.internal.disposables.ArrayCompositeDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.internal.disposables.CancellableDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.internal.disposables.ListCompositeDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.internal.disposables.ListCompositeDisposable --|> io.reactivex.internal.disposables.DisposableContainer
io.reactivex.internal.disposables.ObserverFullArbiter --|> io.reactivex.internal.disposables.FullArbiterPad1
io.reactivex.internal.disposables.ObserverFullArbiter --|> io.reactivex.disposables.Disposable
io.reactivex.internal.disposables.SequentialDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.BiConsumerSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.internal.observers.BiConsumerSingleObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.BlockingFirstObserver --|> io.reactivex.internal.observers.BlockingBaseObserver
io.reactivex.internal.observers.BlockingLastObserver --|> io.reactivex.internal.observers.BlockingBaseObserver
io.reactivex.internal.observers.BlockingMultiObserver --|> io.reactivex.internal.observers.CountDownLatch
io.reactivex.internal.observers.BlockingMultiObserver --|> io.reactivex.internal.observers.CompletableObserver
io.reactivex.internal.observers.BlockingMultiObserver --|> io.reactivex.internal.observers.MaybeObserver
io.reactivex.internal.observers.BlockingMultiObserver --|> io.reactivex.internal.observers.SingleObserver
io.reactivex.internal.observers.BlockingObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.BlockingObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.CallbackCompletableObserver --|> io.reactivex.CompletableObserver
io.reactivex.internal.observers.CallbackCompletableObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.CallbackCompletableObserver --|> io.reactivex.internal.observers.Consumer
io.reactivex.internal.observers.ConsumerSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.internal.observers.ConsumerSingleObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.DeferredScalarDisposable --|> io.reactivex.internal.observers.BasicIntQueueDisposable
io.reactivex.internal.observers.DisposableLambdaObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.DisposableLambdaObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.EmptyCompletableObserver --|> io.reactivex.CompletableObserver
io.reactivex.internal.observers.EmptyCompletableObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.ForEachWhileObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.ForEachWhileObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.FullArbiterObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.FutureObserver --|> io.reactivex.internal.observers.CountDownLatch
io.reactivex.internal.observers.FutureObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.FutureObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.FutureObserver --|> io.reactivex.internal.observers.Future
io.reactivex.internal.observers.FutureSingleObserver --|> io.reactivex.internal.observers.CountDownLatch
io.reactivex.internal.observers.FutureSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.internal.observers.FutureSingleObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.FutureSingleObserver --|> io.reactivex.internal.observers.Future
io.reactivex.internal.observers.InnerQueuedObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.InnerQueuedObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.LambdaObserver --|> io.reactivex.Observer
io.reactivex.internal.observers.LambdaObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.observers.ResumeSingleObserver --|> io.reactivex.SingleObserver
io.reactivex.internal.observers.SubscriberCompletableObserver --|> io.reactivex.CompletableObserver
io.reactivex.internal.observers.SubscriberCompletableObserver --|> io.reactivex.internal.observers.Subscription
io.reactivex.internal.operators.completable.CompletableAmb --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableCache --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableCache --|> io.reactivex.internal.operators.completable.CompletableObserver
io.reactivex.internal.operators.completable.CompletableCacheTest --|> io.reactivex.internal.operators.completable.Action
io.reactivex.internal.operators.completable.CompletableCacheTest --|> io.reactivex.internal.operators.completable.Consumer
io.reactivex.internal.operators.completable.CompletableConcat --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableConcatArray --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableConcatIterable --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableCreate --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableDefer --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableDelay --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableDisposeOn --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableDoFinally --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableDoFinallyTest --|> io.reactivex.internal.operators.completable.Action
io.reactivex.internal.operators.completable.CompletableDoOnEvent --|> io.reactivex.Completable
io.reactivex.internal.operators.completable.CompletableEmpty --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableError --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableErrorSupplier --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableFromAction --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableFromCallable --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableFromObservable --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableFromPublisher --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableFromRunnable --|> io.reactivex.Completable
io.reactivex.internal.operators.completable.CompletableFromSingle --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableFromUnsafeSource --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableHide --|> io.reactivex.Completable
io.reactivex.internal.operators.completable.CompletableLift --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableMerge --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableMergeArray --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableMergeDelayErrorArray --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableMergeDelayErrorIterable --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableMergeIterable --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableNever --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableObserveOn --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableOnErrorComplete --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletablePeek --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableResumeNext --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableSubscribeOn --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableTimeout --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableTimer --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.completable.CompletableToFlowable --|> io.reactivex.internal.operators.completable.Flowable
io.reactivex.internal.operators.completable.CompletableToObservable --|> io.reactivex.internal.operators.completable.Observable
io.reactivex.internal.operators.completable.CompletableToSingle --|> io.reactivex.internal.operators.completable.Single
io.reactivex.internal.operators.completable.CompletableUsing --|> io.reactivex.internal.operators.completable.Completable
io.reactivex.internal.operators.flowable.FlowableAll --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableAllSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableAllSingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableAmb --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableAny --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableAnySingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableAnySingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableAutoConnect --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableBuffer --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableBufferBoundary --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableBufferTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableCache --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableCollect --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableCollectSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableCollectSingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableCombineLatest --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableConcatArray --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableConcatMap --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableConcatMapEager --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableConcatMapEagerPublisher --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableConcatMapPublisher --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableCount --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableCountSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableCountSingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableCreate --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableDebounce --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDebounceTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDefer --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableDelay --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableDematerialize --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDetach --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDistinct --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDoAfterNext --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDoFinally --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDoFinallyTest --|> io.reactivex.internal.operators.flowable.Action
io.reactivex.internal.operators.flowable.FlowableDoOnEach --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableElementAt --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableElementAtMaybe --|> io.reactivex.internal.operators.flowable.Maybe
io.reactivex.internal.operators.flowable.FlowableElementAtMaybe --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableElementAtSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableElementAtSingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableEmpty --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableEmpty --|> io.reactivex.internal.fuseable.ScalarCallable
io.reactivex.internal.operators.flowable.FlowableError --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableFilter --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableFlatMap --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable --|> io.reactivex.internal.operators.flowable.Completable
io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableFlatMapPublisher --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableFlatMapSingle --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableFlattenIterable --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableFromArray --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableFromCallable --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableFromFuture --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableFromIterable --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableFromObservable --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableFromPublisher --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableGenerate --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableGroupBy --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableGroupJoin --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableHide --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableIgnoreElements --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable --|> io.reactivex.internal.operators.flowable.Completable
io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableInterval --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableIntervalRange --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableJoin --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableJust --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableJust --|> io.reactivex.internal.fuseable.ScalarCallable
io.reactivex.internal.operators.flowable.FlowableLastMaybe --|> io.reactivex.internal.operators.flowable.Maybe
io.reactivex.internal.operators.flowable.FlowableLastSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableLift --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableMap --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableMapNotification --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableMapPublisher --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableMaterialize --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableNever --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableObserveOn --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategy --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop --|> io.reactivex.functions.Consumer
io.reactivex.internal.operators.flowable.FlowableOnBackpressureError --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnErrorNext --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableOnErrorReturn --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowablePublish --|> io.reactivex.flowables.ConnectableFlowable
io.reactivex.internal.operators.flowable.FlowablePublish --|> io.reactivex.internal.operators.flowable.HasUpstreamPublisher
io.reactivex.internal.operators.flowable.FlowablePublishMulticast --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableRange --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableRangeLong --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableReduce --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableReduceMaybe --|> io.reactivex.internal.operators.flowable.Maybe
io.reactivex.internal.operators.flowable.FlowableReduceMaybe --|> io.reactivex.internal.operators.flowable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableReduceMaybe --|> io.reactivex.internal.operators.flowable.HasUpstreamPublisher
io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableReduceWithSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableRefCount --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableRepeat --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableRepeatUntil --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableRepeatWhen --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableReplay --|> io.reactivex.flowables.ConnectableFlowable
io.reactivex.internal.operators.flowable.FlowableReplay --|> io.reactivex.disposables.Disposable
io.reactivex.internal.operators.flowable.FlowableReplay --|> io.reactivex.internal.fuseable.HasUpstreamPublisher
io.reactivex.internal.operators.flowable.FlowableRetryBiPredicate --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableRetryPredicate --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableRetryWhen --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSamplePublisher --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableSampleTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableScan --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableScanSeed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSequenceEqual --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle --|> io.reactivex.internal.operators.flowable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableSerialized --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSingle --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSingleMaybe --|> io.reactivex.internal.operators.flowable.Maybe
io.reactivex.internal.operators.flowable.FlowableSingleMaybe --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableSingleSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableSingleSingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableSkip --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSkipLast --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSkipLastTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSkipUntil --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSkipWhile --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSubscribeOn --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSwitchIfEmpty --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableSwitchMap --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTake --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTakeLast --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTakeLastOne --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTakeLastTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTakePublisher --|> io.reactivex.Flowable
io.reactivex.internal.operators.flowable.FlowableTakeUntil --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicate --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTakeWhile --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableThrottleFirstTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTimeInterval --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTimeout --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTimeoutTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableTimer --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableToList --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableToListSingle --|> io.reactivex.internal.operators.flowable.Single
io.reactivex.internal.operators.flowable.FlowableToListSingle --|> io.reactivex.internal.fuseable.FuseToFlowable
io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableUsing --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableWindow --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableWindowBoundary --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableWindowTimed --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableWithLatestFrom --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.flowable.FlowableZip --|> io.reactivex.internal.operators.flowable.Flowable
io.reactivex.internal.operators.flowable.FlowableZipIterable --|> io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream
io.reactivex.internal.operators.maybe.MaybeAmb --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeCache --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeCache --|> io.reactivex.internal.operators.maybe.MaybeObserver
io.reactivex.internal.operators.maybe.MaybeCallbackObserver --|> io.reactivex.MaybeObserver
io.reactivex.internal.operators.maybe.MaybeCallbackObserver --|> io.reactivex.disposables.Disposable
io.reactivex.internal.operators.maybe.MaybeConcatArray --|> io.reactivex.internal.operators.maybe.Flowable
io.reactivex.internal.operators.maybe.MaybeConcatArrayDelayError --|> io.reactivex.internal.operators.maybe.Flowable
io.reactivex.internal.operators.maybe.MaybeConcatIterable --|> io.reactivex.internal.operators.maybe.Flowable
io.reactivex.internal.operators.maybe.MaybeContains --|> io.reactivex.internal.operators.maybe.Single
io.reactivex.internal.operators.maybe.MaybeContains --|> io.reactivex.internal.fuseable.HasUpstreamMaybeSource
io.reactivex.internal.operators.maybe.MaybeCount --|> io.reactivex.internal.operators.maybe.Single
io.reactivex.internal.operators.maybe.MaybeCount --|> io.reactivex.internal.fuseable.HasUpstreamMaybeSource
io.reactivex.internal.operators.maybe.MaybeCreate --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeDefer --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeDelay --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable --|> io.reactivex.Maybe
io.reactivex.internal.operators.maybe.MaybeDetach --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeDoAfterSuccess --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeDoFinally --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeDoFinallyTest --|> io.reactivex.internal.operators.maybe.Action
io.reactivex.internal.operators.maybe.MaybeDoOnEvent --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeEmpty --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeEmpty --|> io.reactivex.internal.fuseable.ScalarCallable
io.reactivex.internal.operators.maybe.MaybeEqualSingle --|> io.reactivex.internal.operators.maybe.Single
io.reactivex.internal.operators.maybe.MaybeError --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeErrorCallable --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFilter --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeFilterSingle --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeFlatMapCompletable --|> io.reactivex.internal.operators.maybe.Completable
io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowable --|> io.reactivex.internal.operators.maybe.Flowable
io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservable --|> io.reactivex.internal.operators.maybe.Observable
io.reactivex.internal.operators.maybe.MaybeFlatMapNotification --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeFlatMapSingle --|> io.reactivex.Single
io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFlatten --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeFromAction --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFromCallable --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFromCompletable --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFromCompletable --|> io.reactivex.internal.fuseable.HasUpstreamCompletableSource
io.reactivex.internal.operators.maybe.MaybeFromFuture --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFromRunnable --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFromSingle --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeFromSingle --|> io.reactivex.internal.fuseable.HasUpstreamSingleSource
io.reactivex.internal.operators.maybe.MaybeHide --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeIgnoreElement --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable --|> io.reactivex.internal.operators.maybe.Completable
io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable --|> io.reactivex.internal.fuseable.FuseToMaybe
io.reactivex.internal.operators.maybe.MaybeIsEmpty --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeIsEmptySingle --|> io.reactivex.internal.operators.maybe.Single
io.reactivex.internal.operators.maybe.MaybeIsEmptySingle --|> io.reactivex.internal.operators.maybe.FuseToMaybe
io.reactivex.internal.operators.maybe.MaybeIsEmptySingle --|> io.reactivex.internal.operators.maybe.HasUpstreamMaybeSource
io.reactivex.internal.operators.maybe.MaybeJust --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeJust --|> io.reactivex.internal.fuseable.ScalarCallable
io.reactivex.internal.operators.maybe.MaybeLift --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeMap --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeMergeArray --|> io.reactivex.internal.operators.maybe.Flowable
io.reactivex.internal.operators.maybe.MaybeNever --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeObserveOn --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeOnErrorComplete --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeOnErrorNext --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeOnErrorReturn --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybePeek --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeSubscribeOn --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeTimer --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeToFlowable --|> io.reactivex.internal.operators.maybe.Flowable
io.reactivex.internal.operators.maybe.MaybeToFlowable --|> io.reactivex.internal.fuseable.HasUpstreamMaybeSource
io.reactivex.internal.operators.maybe.MaybeToObservable --|> io.reactivex.internal.operators.maybe.Observable
io.reactivex.internal.operators.maybe.MaybeToObservable --|> io.reactivex.internal.fuseable.HasUpstreamMaybeSource
io.reactivex.internal.operators.maybe.MaybeToSingle --|> io.reactivex.internal.operators.maybe.Single
io.reactivex.internal.operators.maybe.MaybeToSingle --|> io.reactivex.internal.fuseable.HasUpstreamMaybeSource
io.reactivex.internal.operators.maybe.MaybeUnsafeCreate --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeUnsubscribeOn --|> io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream
io.reactivex.internal.operators.maybe.MaybeUsing --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeZipArray --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.maybe.MaybeZipIterable --|> io.reactivex.internal.operators.maybe.Maybe
io.reactivex.internal.operators.observable.Burst --|> io.reactivex.Observable
io.reactivex.internal.operators.observable.ObservableAll --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableAllSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableAllSingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableAmb --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableAny --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableAnySingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableAnySingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableAutoConnect --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableBuffer --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableBufferBoundary --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableBufferExactBoundary --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableBufferTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableCache --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableCollect --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableCollectSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableCollectSingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableCombineLatest --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableConcatMap --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableConcatMapEager --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableCount --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableCountSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableCountSingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableCreate --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableDebounce --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDebounceTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDefer --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableDelay --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableDematerialize --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDetach --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDistinct --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDistinctUntilChanged --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDoAfterNext --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDoFinally --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDoFinallyTest --|> io.reactivex.internal.operators.observable.Action
io.reactivex.internal.operators.observable.ObservableDoOnEach --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableDoOnLifecycle --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableElementAt --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableElementAtMaybe --|> io.reactivex.internal.operators.observable.Maybe
io.reactivex.internal.operators.observable.ObservableElementAtMaybe --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableElementAtSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableElementAtSingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableEmpty --|> io.reactivex.Observable
io.reactivex.internal.operators.observable.ObservableEmpty --|> io.reactivex.internal.fuseable.ScalarCallable
io.reactivex.internal.operators.observable.ObservableError --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableFilter --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableFlatMap --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableFlatMapCompletable --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable --|> io.reactivex.internal.operators.observable.Completable
io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableFlatMapMaybe --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableFlatMapSingle --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableFlattenIterable --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableFromArray --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableFromCallable --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableFromFuture --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableFromIterable --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableFromPublisher --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableFromUnsafeSource --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableGenerate --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableGroupBy --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableGroupJoin --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableHide --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableIgnoreElements --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable --|> io.reactivex.internal.operators.observable.Completable
io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableInterval --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableIntervalRange --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableJoin --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableJust --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableJust --|> io.reactivex.internal.fuseable.ScalarCallable
io.reactivex.internal.operators.observable.ObservableLastMaybe --|> io.reactivex.internal.operators.observable.Maybe
io.reactivex.internal.operators.observable.ObservableLastSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableLift --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableMap --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableMapNotification --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableMaterialize --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableNever --|> io.reactivex.Observable
io.reactivex.internal.operators.observable.ObservableObserveOn --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableOnErrorNext --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableOnErrorReturn --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservablePublish --|> io.reactivex.observables.ConnectableObservable
io.reactivex.internal.operators.observable.ObservablePublish --|> io.reactivex.internal.fuseable.HasUpstreamObservableSource
io.reactivex.internal.operators.observable.ObservablePublishSelector --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableRange --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableRangeLong --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableReduceMaybe --|> io.reactivex.internal.operators.observable.Maybe
io.reactivex.internal.operators.observable.ObservableReduceSeedSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableReduceWithSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableRefCount --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableRepeat --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableRepeatUntil --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableRepeatWhen --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableReplay --|> io.reactivex.observables.ConnectableObservable
io.reactivex.internal.operators.observable.ObservableReplay --|> io.reactivex.disposables.Disposable
io.reactivex.internal.operators.observable.ObservableReplay --|> io.reactivex.internal.fuseable.HasUpstreamObservableSource
io.reactivex.internal.operators.observable.ObservableRetryBiPredicate --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableRetryPredicate --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableRetryWhen --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSampleTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSampleWithObservable --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableScan --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableScanSeed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSequenceEqual --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableSerialized --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSingleMaybe --|> io.reactivex.internal.operators.observable.Maybe
io.reactivex.internal.operators.observable.ObservableSingleSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableSkip --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSkipLast --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSkipLastTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSkipUntil --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSkipWhile --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSubscribeOn --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSwitchIfEmpty --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableSwitchMap --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTake --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTakeLast --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTakeLastOne --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTakeLastTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTakeUntil --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTakeWhile --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTimeInterval --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTimeout --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTimeoutTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableTimer --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableToList --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableToListSingle --|> io.reactivex.internal.operators.observable.Single
io.reactivex.internal.operators.observable.ObservableToListSingle --|> io.reactivex.internal.fuseable.FuseToObservable
io.reactivex.internal.operators.observable.ObservableUnsubscribeOn --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableUsing --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableWindow --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableWindowBoundary --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableWindowTimed --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableWithLatestFrom --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableWithLatestFromMany --|> io.reactivex.internal.operators.observable.AbstractObservableWithUpstream
io.reactivex.internal.operators.observable.ObservableZip --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObservableZipIterable --|> io.reactivex.internal.operators.observable.Observable
io.reactivex.internal.operators.observable.ObserverResourceWrapper --|> io.reactivex.Observer
io.reactivex.internal.operators.observable.ObserverResourceWrapper --|> io.reactivex.disposables.Disposable
io.reactivex.internal.operators.parallel.ParallelCollect --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelConcatMap --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelDoOnNextTry --|> io.reactivex.internal.operators.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelFilter --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelFilterTry --|> io.reactivex.internal.operators.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelFlatMap --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelFromArray --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelFromPublisher --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelJoin --|> io.reactivex.internal.operators.parallel.Flowable
io.reactivex.internal.operators.parallel.ParallelMap --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelMapTry --|> io.reactivex.internal.operators.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelPeek --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelReduce --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelReduceFull --|> io.reactivex.internal.operators.parallel.Flowable
io.reactivex.internal.operators.parallel.ParallelRunOn --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.internal.operators.parallel.ParallelSortedJoin --|> io.reactivex.internal.operators.parallel.Flowable
io.reactivex.internal.operators.single.SingleAmb --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleCache --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleCache --|> io.reactivex.internal.operators.single.SingleObserver
io.reactivex.internal.operators.single.SingleContains --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleCreate --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDefer --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDelay --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDelayWithCompletable --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDelayWithObservable --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDelayWithPublisher --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDelayWithSingle --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDoAfterSuccess --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDoAfterTerminate --|> io.reactivex.Single
io.reactivex.internal.operators.single.SingleDoFinally --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDoFinallyTest --|> io.reactivex.internal.operators.single.Action
io.reactivex.internal.operators.single.SingleDoOnDispose --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDoOnError --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDoOnEvent --|> io.reactivex.Single
io.reactivex.internal.operators.single.SingleDoOnSubscribe --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleDoOnSuccess --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleEquals --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleError --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleFlatMap --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleFlatMapCompletable --|> io.reactivex.internal.operators.single.Completable
io.reactivex.internal.operators.single.SingleFlatMapIterableFlowable --|> io.reactivex.internal.operators.single.Flowable
io.reactivex.internal.operators.single.SingleFlatMapIterableObservable --|> io.reactivex.internal.operators.single.Observable
io.reactivex.internal.operators.single.SingleFlatMapMaybe --|> io.reactivex.Maybe
io.reactivex.internal.operators.single.SingleFromCallable --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleFromPublisher --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleFromUnsafeSource --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleHide --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleJust --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleLift --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleMap --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleNever --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleObserveOn --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleOnErrorReturn --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleResumeNext --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleSubscribeOn --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleTakeUntil --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleTimeout --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleTimer --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleToFlowable --|> io.reactivex.internal.operators.single.Flowable
io.reactivex.internal.operators.single.SingleToObservable --|> io.reactivex.internal.operators.single.Observable
io.reactivex.internal.operators.single.SingleUnsubscribeOn --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleUsing --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleZipArray --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.operators.single.SingleZipIterable --|> io.reactivex.internal.operators.single.Single
io.reactivex.internal.queue.MpscLinkedQueue --|> io.reactivex.internal.fuseable.SimplePlainQueue
io.reactivex.internal.queue.SpscArrayQueue --|> io.reactivex.internal.queue.AtomicReferenceArray
io.reactivex.internal.queue.SpscArrayQueue --|> io.reactivex.internal.fuseable.SimplePlainQueue
io.reactivex.internal.queue.SpscLinkedArrayQueue --|> io.reactivex.internal.fuseable.SimplePlainQueue
io.reactivex.internal.schedulers.ComputationScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.DisposeOnCancel --|> io.reactivex.internal.schedulers.Future
io.reactivex.internal.schedulers.ExecutorScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.ImmediateThinScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.IoScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.NewThreadScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.NewThreadWorker --|> Scheduler.Worker
io.reactivex.internal.schedulers.NewThreadWorker --|> io.reactivex.internal.schedulers.Disposable
io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask --|> io.reactivex.internal.schedulers.AbstractDirectTask
io.reactivex.internal.schedulers.ScheduledDirectTask --|> io.reactivex.internal.schedulers.AbstractDirectTask
io.reactivex.internal.schedulers.ScheduledRunnable --|> io.reactivex.disposables.Disposable
io.reactivex.internal.schedulers.ScheduledRunnable --|> io.reactivex.internal.schedulers.Callable
io.reactivex.internal.schedulers.SchedulerWhen --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.SchedulerWhen --|> io.reactivex.disposables.Disposable
io.reactivex.internal.schedulers.SingleScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.schedulers.TrampolineScheduler --|> io.reactivex.Scheduler
io.reactivex.internal.subscribers.BlockingFirstSubscriber --|> io.reactivex.internal.subscribers.BlockingBaseSubscriber
io.reactivex.internal.subscribers.BlockingLastSubscriber --|> io.reactivex.internal.subscribers.BlockingBaseSubscriber
io.reactivex.internal.subscribers.BlockingSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.BlockingSubscriber --|> org.reactivestreams.Subscription
io.reactivex.internal.subscribers.ForEachWhileSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.ForEachWhileSubscriber --|> io.reactivex.disposables.Disposable
io.reactivex.internal.subscribers.FullArbiterSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.FutureSubscriber --|> io.reactivex.internal.subscribers.CountDownLatch
io.reactivex.internal.subscribers.FutureSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.FutureSubscriber --|> io.reactivex.internal.subscribers.Future
io.reactivex.internal.subscribers.FutureSubscriber --|> org.reactivestreams.Subscription
io.reactivex.internal.subscribers.InnerQueuedSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.InnerQueuedSubscriber --|> org.reactivestreams.Subscription
io.reactivex.internal.subscribers.LambdaSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.LambdaSubscriber --|> io.reactivex.disposables.Disposable
io.reactivex.internal.subscribers.LambdaSubscriber --|> org.reactivestreams.Subscription
io.reactivex.internal.subscribers.StrictSubscriber --|> io.reactivex.internal.subscribers.AtomicInteger
io.reactivex.internal.subscribers.StrictSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.StrictSubscriber --|> io.reactivex.internal.subscribers.Subscription
io.reactivex.internal.subscribers.SubscriberResourceWrapper --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.subscribers.SubscriberResourceWrapper --|> io.reactivex.disposables.Disposable
io.reactivex.internal.subscribers.SubscriberResourceWrapper --|> io.reactivex.internal.subscribers.Subscription
io.reactivex.internal.subscriptions.ArrayCompositeSubscription --|> io.reactivex.disposables.Disposable
io.reactivex.internal.subscriptions.AsyncSubscription --|> io.reactivex.internal.subscriptions.AtomicLong
io.reactivex.internal.subscriptions.AsyncSubscription --|> io.reactivex.disposables.Disposable
io.reactivex.internal.subscriptions.AsyncSubscription --|> org.reactivestreams.Subscription
io.reactivex.internal.subscriptions.BooleanSubscription --|> org.reactivestreams.Subscription
io.reactivex.internal.subscriptions.DeferredScalarSubscription --|> io.reactivex.internal.subscriptions.BasicIntQueueSubscription
io.reactivex.internal.subscriptions.FullArbiter --|> io.reactivex.internal.subscriptions.FullArbiterPad2
io.reactivex.internal.subscriptions.FullArbiter --|> io.reactivex.internal.subscriptions.Subscription
io.reactivex.internal.subscriptions.ScalarSubscription --|> io.reactivex.internal.fuseable.QueueSubscription
io.reactivex.internal.subscriptions.SubscriptionArbiter --|> io.reactivex.internal.subscriptions.AtomicInteger
io.reactivex.internal.subscriptions.SubscriptionArbiter --|> org.reactivestreams.Subscription
io.reactivex.internal.util.BlockingIgnoringReceiver --|> io.reactivex.internal.util.Action
io.reactivex.internal.util.BlockingIgnoringReceiver --|> io.reactivex.internal.util.Consumer
io.reactivex.internal.util.ConnectConsumer --|> io.reactivex.functions.Consumer
io.reactivex.internal.util.MergerBiFunction --|> io.reactivex.functions.BiFunction
io.reactivex.internal.util.SorterFunction --|> io.reactivex.functions.Function
io.reactivex.internal.util.VolatileSizeArrayList --|> io.reactivex.internal.util.List
io.reactivex.internal.util.VolatileSizeArrayList --|> io.reactivex.internal.util.RandomAccess
io.reactivex.observers.SafeObserver --|> io.reactivex.Observer
io.reactivex.observers.SafeObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.SerializedObserver --|> io.reactivex.Observer
io.reactivex.observers.SerializedObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.TestObserver --|> io.reactivex.observers.BaseTestConsumer
io.reactivex.observers.TestObserver --|> io.reactivex.disposables.Disposable
io.reactivex.observers.TestObserver --|> io.reactivex.observers.CompletableObserver
io.reactivex.observers.TestObserver --|> io.reactivex.observers.MaybeObserver
io.reactivex.observers.TestObserver --|> io.reactivex.observers.Observer
io.reactivex.observers.TestObserver --|> io.reactivex.observers.SingleObserver
io.reactivex.parallel.ParallelDoOnNextTryTest --|> io.reactivex.parallel.Consumer
io.reactivex.parallel.ParallelFilterTryTest --|> io.reactivex.parallel.Consumer
io.reactivex.parallel.ParallelInvalid --|> io.reactivex.parallel.ParallelFlowable
io.reactivex.parallel.ParallelMapTryTest --|> io.reactivex.parallel.Consumer
io.reactivex.parallel.ParallelPerf --|> io.reactivex.functions.Function
io.reactivex.processors.AsyncProcessor --|> io.reactivex.processors.FlowableProcessor
io.reactivex.processors.AsyncProcessorTest --|> io.reactivex.processors.DelayedFlowableProcessorTest
io.reactivex.processors.BehaviorProcessor --|> io.reactivex.processors.FlowableProcessor
io.reactivex.processors.BehaviorProcessorTest --|> io.reactivex.processors.DelayedFlowableProcessorTest
io.reactivex.processors.PublishProcessor --|> io.reactivex.processors.FlowableProcessor
io.reactivex.processors.PublishProcessorTest --|> io.reactivex.processors.FlowableProcessorTest
io.reactivex.processors.ReplayProcessor --|> io.reactivex.processors.FlowableProcessor
io.reactivex.processors.ReplayProcessorTest --|> io.reactivex.processors.FlowableProcessorTest
io.reactivex.processors.SerializedProcessor --|> io.reactivex.processors.FlowableProcessor
io.reactivex.processors.UnicastProcessor --|> io.reactivex.processors.FlowableProcessor
io.reactivex.processors.UnicastProcessorTest --|> io.reactivex.processors.DelayedFlowableProcessorTest
io.reactivex.schedulers.CachedThreadSchedulerTest --|> io.reactivex.schedulers.AbstractSchedulerConcurrencyTests
io.reactivex.schedulers.ComputationSchedulerTests --|> io.reactivex.schedulers.AbstractSchedulerConcurrencyTests
io.reactivex.schedulers.ExecutorSchedulerTest --|> io.reactivex.schedulers.AbstractSchedulerConcurrencyTests
io.reactivex.schedulers.NewThreadSchedulerTest --|> io.reactivex.schedulers.AbstractSchedulerConcurrencyTests
io.reactivex.schedulers.TestScheduler --|> io.reactivex.Scheduler
io.reactivex.schedulers.TrampolineSchedulerTest --|> io.reactivex.schedulers.AbstractSchedulerTests
io.reactivex.subjects.AsyncSubject --|> io.reactivex.subjects.Subject
io.reactivex.subjects.BehaviorSubject --|> io.reactivex.subjects.Subject
io.reactivex.subjects.CompletableSubject --|> io.reactivex.subjects.Completable
io.reactivex.subjects.CompletableSubject --|> io.reactivex.subjects.CompletableObserver
io.reactivex.subjects.MaybeSubject --|> io.reactivex.subjects.Maybe
io.reactivex.subjects.MaybeSubject --|> io.reactivex.subjects.MaybeObserver
io.reactivex.subjects.PublishSubject --|> io.reactivex.subjects.Subject
io.reactivex.subjects.ReplaySubject --|> io.reactivex.subjects.Subject
io.reactivex.subjects.SerializedSubject --|> io.reactivex.subjects.Subject
io.reactivex.subjects.SerializedSubject --|> io.reactivex.internal.util.AppendOnlyLinkedArrayList.NonThrowingPredicate
io.reactivex.subjects.SingleSubject --|> io.reactivex.subjects.Single
io.reactivex.subjects.SingleSubject --|> io.reactivex.subjects.SingleObserver
io.reactivex.subjects.UnicastSubject --|> io.reactivex.subjects.Subject
io.reactivex.subscribers.SafeSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.subscribers.SafeSubscriber --|> io.reactivex.subscribers.Subscription
io.reactivex.subscribers.SerializedSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.subscribers.SerializedSubscriber --|> io.reactivex.subscribers.Subscription
io.reactivex.subscribers.TestSubscriber --|> io.reactivex.observers.BaseTestConsumer
io.reactivex.subscribers.TestSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.subscribers.TestSubscriber --|> io.reactivex.disposables.Disposable
io.reactivex.subscribers.TestSubscriber --|> io.reactivex.subscribers.Subscription
io.reactivex.tck.AllTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.AmbArrayTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.AmbTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.AnyTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.AsyncProcessorAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.BehaviorProcessorAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.BufferBoundaryTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.BufferExactSizeTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CacheTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CollectTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CombineLatestArrayDelayErrorTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CombineLatestArrayTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CombineLatestIterableDelayErrorTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CombineLatestIterableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatArrayEagerTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatIterableEagerTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatMapIterableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatMapTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatPublisherEagerTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ConcatTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.CreateTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DefaultIfEmptyTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DeferTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DelaySubscriptionTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DelayTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DistinctTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DistinctUntilChangedTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DoAfterNextTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DoFinallyTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.DoOnNextTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ElementAtTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.EmptyTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FilterTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FirstTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FlatMapTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FromArrayTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FromCallableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FromFutureTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.FromIterableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.GenerateTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.GroupByTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.HideTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.IgnoreElementsTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.IntervalRangeTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.IntervalTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.IsEmptyTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.JustTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.LastTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.MapTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.MergeIterableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.MergePublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.MergeTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ObserveOnTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.OnBackpressureBufferTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.OnErrorResumeNextTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.OnErrorReturnItemTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.PublishProcessorAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.PublishSelectorTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.PublishTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.RangeTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.RebatchRequestsTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReduceTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReduceWithTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.RepeatTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReplayProcessorSizeBoundAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReplayProcessorTimeBoundAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReplayProcessorUnboundedAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReplaySelectorTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ReplayTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.RetryTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ScanTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SequenceEqualTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ShareTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SingleTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SkipLastTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SkipTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SkipUntilTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SkipWhileTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SortedTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SubscribeOnTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SwitchIfEmptyTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SwitchMapDelayErrorTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SwitchMapTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.SwitchOnNextTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TakeLastTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TakeTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TakeUntilTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TakeWhileTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TimeIntervalTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TimeoutTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TimerTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.TimestampTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ToListTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ToMapTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ToMultimapTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ToSortedListTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.UnicastProcessorAsPublisherTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.UnsubscribeOnTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.UsingTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.WindowBoundaryTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.WindowExactSizeTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.WithLatestFromTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ZipIterableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ZipTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ZipWithIterableTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.tck.ZipWithTckTest --|> io.reactivex.tck.BaseTck
io.reactivex.FlowableEmitter --|> io.reactivex.Emitter
io.reactivex.FlowableSubscriber --|> io.reactivex.Subscriber
io.reactivex.ObservableEmitter --|> io.reactivex.Emitter
io.reactivex.internal.fuseable.ConditionalSubscriber --|> io.reactivex.FlowableSubscriber
io.reactivex.internal.fuseable.QueueDisposable --|> io.reactivex.disposables.Disposable
io.reactivex.internal.fuseable.QueueDisposable --|> io.reactivex.internal.fuseable.QueueFuseable
io.reactivex.internal.fuseable.QueueFuseable --|> io.reactivex.internal.fuseable.SimpleQueue
io.reactivex.internal.fuseable.QueueSubscription --|> io.reactivex.internal.fuseable.QueueFuseable
io.reactivex.internal.fuseable.QueueSubscription --|> org.reactivestreams.Subscription
io.reactivex.internal.fuseable.SimplePlainQueue --|> io.reactivex.internal.fuseable.SimpleQueue
@enduml