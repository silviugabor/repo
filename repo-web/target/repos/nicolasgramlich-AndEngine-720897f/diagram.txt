@startuml
abstract class org.andengine.audio.BaseAudioEntity {
 + boolean isReleased() 
+ float getActualLeftVolume() 
+ float getActualRightVolume() 
# float getMasterVolume() 
# {abstract} void throwOnReleased() 
+ float getLeftVolume() 
+ float getRightVolume() 
+ final void setVolume(final float pVolume) 
+ void setVolume(final float pLeftVolume, final float pRightVolume) 
+ void onMasterVolumeChanged(final float pMasterVolume) 
+ void play() 
+ void pause() 
+ void resume() 
+ void stop() 
+ void setLooping(final boolean pLooping) 
+ void release() 
# void assertNotReleased() 
	- boolean mReleased;
 
}
abstract class org.andengine.audio.BaseAudioManager {
 + float getMasterVolume() 
+ void setMasterVolume(final float pMasterVolume) 
+ void add(final T pAudioEntity) 
+ boolean remove(final T pAudioEntity) 
+ void releaseAll() 
 
}
abstract class org.andengine.engine.camera.hud.controls.BaseOnScreenControl {
 + boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
+ void onTimePassed(final TimerHandler pTimerHandler) 
+ Sprite getControlBase() 
+ Sprite getControlKnob() 
+ IOnScreenControlListener getOnScreenControlListener() 
+ boolean onSceneTouchEvent(final Scene pScene, final TouchEvent pSceneTouchEvent) 
+ void refreshControlKnobPosition() 
# void onHandleControlBaseLeft() 
# void onHandleControlKnobReleased() 
# boolean onHandleControlBaseTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
- void updateControlKnob(final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
# void onUpdateControlKnob(final float pRelativeX, final float pRelativeY) 
+ void onControlChange(final BaseOnScreenControl pBaseOnScreenControl, final float pValueX, final float pValueY)
	- final Sprite mControlBase;
	- final Sprite mControlKnob;
	- float mControlValueX;
	- float mControlValueY;
	- final IOnScreenControlListener mOnScreenControlListener;
 
}
abstract class org.andengine.engine.handler.BaseEntityUpdateHandler {
 + IEntity getEntity() 
+ void setEntity(final IEntity pEntity) 
# {abstract} void onUpdate(final float pSecondsElapsed, final IEntity pEntity)
+ void reset() 
	- IEntity mEntity;
 
}
abstract class org.andengine.engine.options.resolutionpolicy.BaseResolutionPolicy {
 # {static} void throwOnNotMeasureSpecEXACTLY(final int pWidthMeasureSpec, final int pHeightMeasureSpec) 
 
}
abstract class org.andengine.entity.modifier.DoubleValueChangeEntityModifier {
  
}
abstract class org.andengine.entity.modifier.DoubleValueSpanEntityModifier {
  
}
abstract class org.andengine.entity.modifier.DurationEntityModifier {
  
}
abstract class org.andengine.entity.modifier.EntityModifier {
  
}
abstract class org.andengine.entity.modifier.SingleValueChangeEntityModifier {
  
}
abstract class org.andengine.entity.modifier.SingleValueSpanEntityModifier {
  
}
abstract class org.andengine.entity.modifier.TripleValueSpanEntityModifier {
  
}
abstract class org.andengine.entity.particle.emitter.BaseCircleParticleEmitter {
 + float getRadiusX() 
+ void setRadiusX(final float pRadiusX) 
+ float getRadiusY() 
+ void setRadiusY(final float pRadiusY) 
+ void setRadius(final float pRadius) 
+ void setRadius(final float pRadiusX, final float pRadiusY) 
	# float mRadiusX;
	# float mRadiusY;
 
}
abstract class org.andengine.entity.particle.emitter.BaseParticleEmitter {
 + float getCenterX() 
+ float getCenterY() 
+ void setCenterX(final float pCenterX) 
+ void setCenterY(final float pCenterY) 
+ void setCenter(final float pCenterX, final float pCenterY) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	# float mCenterX;
	# float mCenterY;
 
}
abstract class org.andengine.entity.particle.emitter.BaseRectangleParticleEmitter {
 + float getWidth() 
+ void setWidth(final float pWidth) 
+ float getHeight() 
+ void setHeight(final float pHeight) 
	# float mWidth;
	# float mHeight;
	# float mWidthHalf;
	# float mHeightHalf;
 
}
abstract class org.andengine.entity.particle.initializer.BaseDoubleValueParticleInitializer {
 # {abstract} void onInitializeParticle(final Particle<T> pParticle, final float pValueA, final float pValueB)
# float getRandomValueB() 
	# float mMinValueB;
	# float mMaxValueB;
 
}
abstract class org.andengine.entity.particle.initializer.BaseSingleValueParticleInitializer {
 # {abstract} void onInitializeParticle(final Particle<T> pParticle, final float pValue)
# float getRandomValue() 
	# float mMinValue;
	# float mMaxValue;
 
}
abstract class org.andengine.entity.particle.initializer.BaseTripleValueParticleInitializer {
 # {abstract} void onInitializeParticle(final Particle<T> pParticle, final float pValueA, final float pValueB, final float pValueC)
# float getRandomValueC() 
	# float mMinValueC;
	# float mMaxValueC;
 
}
abstract class org.andengine.entity.particle.modifier.BaseDoubleValueSpanParticleModifier {
 # {abstract} void onSetInitialValues(final Particle<T> pParticle, final float pValueA, final float pValueB)
# void onSetValue(final Particle<T> pParticle, final float pPercentageDone, final float pValueA) 
+ void reset(final float pFromValue, final float pToValue, final float pFromTime, final float pToTime) 
+ void reset(final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromTime, final float pToTime) 
	- float mFromValueB;
	- float mValueSpanB;
 
}
abstract class org.andengine.entity.particle.modifier.BaseSingleValueSpanParticleModifier {
 # {abstract} void onSetInitialValue(final Particle<T> pParticle, final float pValue)
+ void onUpdateParticle(final Particle<T> pParticle) 
+ void reset(final float pFromValue, final float pToValue, final float pFromTime, final float pToTime) 
	- float mFromTime;
	- float mToTime;
	- float mDuration;
	- float mFromValue;
	- float mValueSpan;
	- final IEaseFunction mEaseFunction;
 
}
abstract class org.andengine.entity.particle.modifier.BaseTripleValueSpanParticleModifier {
 # {abstract} void onSetInitialValues(final Particle<T> pParticle, final float pValueA, final float pValueB, final float pValueC)
# void onSetValues(final Particle<T> pParticle, final float pPercentageDone, final float pValueA, final float pValueB) 
+ void reset(float pFromValueA, float pToValueA, float pFromValueB, float pToValueB, float pFromTime, float pToTime) 
+ void reset(final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC, final float pFromTime, final float pToTime) 
	- float mFromValueC;
	- float mValueSpanC;
 
}
abstract class org.andengine.entity.scene.menu.animator.BaseMenuAnimator {
 # float getMaximumWidth(final ArrayList<IMenuItem> pMenuItems) 
# float getOverallHeight(final ArrayList<IMenuItem> pMenuItems) 
	# final float mMenuItemSpacing;
	# final HorizontalAlign mHorizontalAlign;
	# final IEaseFunction mEaseFunction;
 
}
abstract class org.andengine.entity.scene.menu.item.decorator.BaseMenuItemDecorator {
 # {abstract} void onMenuItemSelected(final IMenuItem pMenuItem)
+ VertexBufferObjectManager getVertexBufferObjectManager() 
+ IVertexBufferObject getVertexBufferObject() 
+ final void onSelected() 
+ final void onUnselected() 
+ float getX() 
+ float getY() 
+ void setX(final float pX) 
+ void setY(final float pY) 
+ void setPosition(final IEntity pOtherEntity) 
+ void setPosition(final float pX, final float pY) 
+ float getWidth() 
+ float getWidthScaled() 
+ float getHeight() 
+ float getHeightScaled() 
+ void setWidth(final float pWidth) 
+ void setHeight(final float pHeight) 
+ void setSize(final float pWidth, final float pHeight) 
+ float getRed() 
+ float getGreen() 
+ float getBlue() 
+ float getAlpha() 
+ void setRed(final float pRed) 
+ void setGreen(final float pGreen) 
+ void setBlue(final float pBlue) 
+ void setAlpha(final float pAlpha) 
+ Color getColor() 
+ void setColor(final Color pColor) 
+ void setColor(final float pRed, final float pGreen, final float pBlue) 
+ void setColor(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ boolean isRotated() 
+ float getRotation() 
+ void setRotation(final float pRotation) 
+ float getRotationCenterX() 
+ float getRotationCenterY() 
+ void setRotationCenterX(final float pRotationCenterX) 
+ void setRotationCenterY(final float pRotationCenterY) 
+ void setRotationCenter(final float pRotationCenterX, final float pRotationCenterY) 
+ boolean isScaled() 
+ float getScaleX() 
+ float getScaleY() 
+ void setScale(final float pScale) 
+ void setScale(final float pScaleX, final float pScaleY) 
+ void setScaleX(final float pScaleX) 
+ void setScaleY(final float pScaleY) 
+ float getScaleCenterX() 
+ float getScaleCenterY() 
+ void setScaleCenterX(final float pScaleCenterX) 
+ void setScaleCenterY(final float pScaleCenterY) 
+ void setScaleCenter(final float pScaleCenterX, final float pScaleCenterY) 
+ boolean isSkewed() 
+ float getSkewX() 
+ float getSkewY() 
+ void setSkew(final float pSkew) 
+ void setSkew(final float pSkewX, final float pSkewY) 
+ void setSkewX(final float pSkewX) 
+ void setSkewY(final float pSkewY) 
+ float getSkewCenterX() 
+ float getSkewCenterY() 
+ void setSkewCenterX(final float pSkewCenterX) 
+ void setSkewCenterY(final float pSkewCenterY) 
+ void setSkewCenter(final float pSkewCenterX, final float pSkewCenterY) 
+ boolean isRotatedOrScaledOrSkewed() 
+ boolean collidesWith(final IShape pOtherShape) 
+ float[] getSceneCenterCoordinates() 
+ float[] getSceneCenterCoordinates(final float[] pReuse) 
+ boolean isCullingEnabled() 
+ void registerEntityModifier(final IEntityModifier pEntityModifier) 
+ boolean unregisterEntityModifier(final IEntityModifier pEntityModifier) 
+ boolean unregisterEntityModifiers(final IEntityModifierMatcher pEntityModifierMatcher) 
+ int getEntityModifierCount() 
+ void clearEntityModifiers() 
+ boolean isBlendingEnabled() 
+ void setBlendingEnabled(final boolean pBlendingEnabled) 
+ int getBlendFunctionSource() 
+ void setBlendFunctionSource(final int pBlendFunctionSource) 
+ int getBlendFunctionDestination() 
+ void setBlendFunctionDestination(final int pBlendFunctionDestination) 
+ void setBlendFunction(final int pBlendFunctionSource, final int pBlendFunctionDestination) 
+ void setCullingEnabled(final boolean pCullingEnabled) 
+ int getTag() 
+ void setTag(final int pTag) 
+ int getZIndex() 
+ void setZIndex(final int pZIndex) 
+ ShaderProgram getShaderProgram() 
+ void setShaderProgram(final ShaderProgram pShaderProgram) 
+ void onDraw(final GLState pGLState, final Camera pCamera) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
+ boolean isDisposed() 
+ void dispose() 
+ boolean contains(final float pX, final float pY) 
+ float[] convertLocalToSceneCoordinates(final float pX, final float pY) 
+ float[] convertLocalToSceneCoordinates(final float pX, final float pY, final float[] pReuse) 
+ float[] convertLocalToSceneCoordinates(final float[] pCoordinates) 
+ float[] convertLocalToSceneCoordinates(final float[] pCoordinates, final float[] pReuse) 
+ float[] convertSceneToLocalCoordinates(final float pX, final float pY) 
+ float[] convertSceneToLocalCoordinates(final float pX, final float pY, final float[] pReuse) 
+ float[] convertSceneToLocalCoordinates(final float[] pCoordinates) 
+ float[] convertSceneToLocalCoordinates(final float[] pCoordinates, final float[] pReuse) 
+ boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
+ int getChildCount() 
+ void attachChild(final IEntity pEntity) 
+ IEntity getFirstChild() 
+ IEntity getLastChild() 
+ IEntity getChildByTag(final int pTag) 
+ IEntity getChildByIndex(final int pIndex) 
+ IEntity getChildByMatcher(IEntityMatcher pEntityMatcher) 
+ ArrayList<IEntity> query(final IEntityMatcher pEntityMatcher) 
+ IEntity queryFirst(final IEntityMatcher pEntityMatcher) 
+ <L extends List<IEntity>> L query(final IEntityMatcher pEntityMatcher, final L pResult) 
+ <S extends IEntity> S queryFirstForSubclass(final IEntityMatcher pEntityMatcher) 
+ <S extends IEntity> ArrayList<S> queryForSubclass(final IEntityMatcher pEntityMatcher) 
+ <L extends List<S>, S extends IEntity> L queryForSubclass(final IEntityMatcher pEntityMatcher, final L pResult) 
+ void sortChildren() 
+ void sortChildren(final boolean pImmediate) 
+ void sortChildren(final IEntityComparator pEntityComparator) 
+ boolean detachSelf() 
+ boolean detachChild(final IEntity pEntity) 
+ IEntity detachChild(final int pTag) 
+ IEntity detachChild(final IEntityMatcher pEntityMatcher) 
+ boolean detachChildren(final IEntityMatcher pEntityMatcher) 
+ void detachChildren() 
+ void callOnChildren(final IEntityParameterCallable pEntityParameterCallable) 
+ void callOnChildren(final IEntityParameterCallable pEntityParameterCallable, final IEntityMatcher pEntityMatcher) 
+ Transformation getLocalToSceneTransformation() 
+ Transformation getSceneToLocalTransformation() 
+ Transformation getLocalToParentTransformation() 
+ Transformation getParentToLocalTransformation() 
+ boolean hasParent() 
+ IEntity getParent() 
+ void setParent(final IEntity pEntity) 
+ boolean isVisible() 
+ void setVisible(final boolean pVisible) 
+ boolean isCulled(final Camera pCamera) 
+ boolean isChildrenVisible() 
+ void setChildrenVisible(final boolean pChildrenVisible) 
+ boolean isIgnoreUpdate() 
+ void setIgnoreUpdate(final boolean pIgnoreUpdate) 
+ boolean isChildrenIgnoreUpdate() 
+ void setChildrenIgnoreUpdate(final boolean pChildrenIgnoreUpdate) 
+ void setUserData(final Object pUserData) 
+ Object getUserData() 
+ void onAttached() 
+ void onDetached() 
+ void registerUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ boolean unregisterUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ int getUpdateHandlerCount() 
+ void clearUpdateHandlers() 
+ boolean unregisterUpdateHandlers(final IUpdateHandlerMatcher pUpdateHandlerMatcher) 
+ void toString(final StringBuilder pStringBuilder) 
	# final IMenuItem mMenuItem;
 
}
abstract class org.andengine.entity.shape.RectangularShape {
 + float getWidth() 
+ float getHeight() 
+ void setWidth(final float pWidth) 
+ void setHeight(final float pHeight) 
+ void setSize(final float pWidth, final float pHeight) 
+ float getWidthScaled() 
+ float getHeightScaled() 
+ boolean isCulled(final Camera pCamera) 
+ void reset() 
+ boolean contains(final float pX, final float pY) 
+ float[] getSceneCenterCoordinates() 
+ float[] getSceneCenterCoordinates(final float[] pReuse) 
+ boolean collidesWith(final IShape pOtherShape) 
+ void resetRotationCenter() 
+ void resetScaleCenter() 
+ void resetSkewCenter() 
	# float mWidth;
	# float mHeight;
 
}
abstract class org.andengine.entity.shape.Shape {
 + boolean isBlendingEnabled() 
+ void setBlendingEnabled(final boolean pBlendingEnabled) 
+ int getBlendFunctionSource() 
+ void setBlendFunctionSource(final int pBlendFunctionSource) 
+ int getBlendFunctionDestination() 
+ void setBlendFunctionDestination(final int pBlendFunctionDestination) 
+ void setBlendFunction(final int pBlendFunctionSource, final int pBlendFunctionDestination) 
+ ShaderProgram getShaderProgram() 
+ void setShaderProgram(final ShaderProgram pShaderProgram) 
+ VertexBufferObjectManager getVertexBufferObjectManager() 
# {abstract} void onUpdateVertices()
# void postDraw(final GLState pGLState, final Camera pCamera) 
+ boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
+ void reset() 
+ void dispose() 
# void initBlendFunction(final ITextureRegion pTextureRegion) 
# void initBlendFunction(final ITexture pTexture) 
# void initBlendFunction(final TextureOptions pTextureOptions) 
	# ShaderProgram mShaderProgram;
 
}
abstract class org.andengine.entity.sprite.batch.DynamicSpriteBatch {
 # {abstract} boolean onUpdateSpriteBatch()
 
}
abstract class org.andengine.entity.util.AverageFPSCounter {
 # {abstract} void onHandleAverageDurationElapsed(final float pFPS)
	# final float mAverageDuration;
 
}
abstract class org.andengine.input.touch.controller.BaseTouchController {
 # TouchEventRunnablePoolItem onAllocatePoolItem() 
+ void setTouchEventCallback(final ITouchEventCallback pTouchEventCallback) 
+ void reset() 
+ void onUpdate(final float pSecondsElapsed) 
# void fireTouchEvent(final float pX, final float pY, final int pAction, final int pPointerID, final MotionEvent pMotionEvent) 
+ void set(final TouchEvent pTouchEvent) 
+ void run() 
# void onRecycle() 
	- ITouchEventCallback mTouchEventCallback;
		- TouchEvent mTouchEvent;
 
}
abstract class org.andengine.input.touch.detector.BaseDetector {
 + boolean isEnabled() 
+ void setEnabled(final boolean pEnabled) 
+ {abstract} void reset()
+ final boolean onTouchEvent(final TouchEvent pSceneTouchEvent) 
 
}
abstract class org.andengine.input.touch.detector.SurfaceGestureDetector {
 # {abstract} boolean onSingleTap()
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
+ boolean onSingleTapConfirmed(final MotionEvent pMotionEvent) 
+ boolean onDoubleTap(final MotionEvent pMotionEvent) 
+ boolean onFling(final MotionEvent pMotionEventStart, final MotionEvent pMotionEventEnd, final float pVelocityX, final float pVelocityY) 
	- final GestureDetector mGestureDetector;
		- final float mSwipeMinDistance;
 
}
abstract class org.andengine.opengl.texture.Texture {
 + int getHardwareTextureID() 
+ boolean isLoadedToHardware() 
+ void setNotLoadedToHardware() 
+ boolean isUpdateOnHardwareNeeded() 
+ void setUpdateOnHardwareNeeded(final boolean pUpdateOnHardwareNeeded) 
+ PixelFormat getPixelFormat() 
+ TextureOptions getTextureOptions() 
+ ITextureStateListener getTextureStateListener() 
+ void setTextureStateListener(final ITextureStateListener pTextureStateListener) 
+ boolean hasTextureStateListener() 
# {abstract} void writeTextureToHardware(final GLState pGLState) 
+ void load(final GLState pGLState) 
+ void unload() 
+ void unload(final GLState pGLState) 
+ void loadToHardware(final GLState pGLState) 
+ void unloadFromHardware(final GLState pGLState) 
+ void reloadToHardware(final GLState pGLState) 
+ void bind(final GLState pGLState) 
+ void bind(final GLState pGLState, final int pGLActiveTexture) 
	# final TextureManager mTextureManager;
	# final PixelFormat mPixelFormat;
	# final TextureOptions mTextureOptions;
	# ITextureStateListener mTextureStateListener;
 
}
abstract class org.andengine.opengl.texture.atlas.TextureAtlas {
 + int getWidth() 
+ int getHeight() 
+ boolean hasTextureStateListener() 
+ boolean hasTextureAtlasStateListener() 
+ ITextureAtlasStateListener<T> getTextureStateListener() 
+ ITextureAtlasStateListener<T> getTextureAtlasStateListener() 
+ void setTextureStateListener(final ITextureStateListener pTextureStateListener) 
+ void setTextureAtlasStateListener(final ITextureAtlasStateListener<T> pTextureAtlasStateListener) 
+ void addTextureAtlasSource(final T pTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ void addTextureAtlasSource(final T pTextureAtlasSource, final int pTextureX, final int pTextureY, final int pTextureAtlasSourcePadding) 
+ void removeTextureAtlasSource(final T pTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ void clearTextureAtlasSources() 
- void checkTextureAtlasSourcePosition(final T pTextureAtlasSource, final int pTextureX, final int pTextureY) 
	# final int mWidth;
	# final int mHeight;
 
}
abstract class org.andengine.opengl.texture.atlas.bitmap.source.PictureBitmapTextureAtlasSource {
 + {abstract} PictureBitmapTextureAtlasSource deepCopy()
	# final Picture mPicture;
 
}
abstract class org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseBitmapTextureAtlasSourceDecorator {
 + {abstract} BaseBitmapTextureAtlasSourceDecorator deepCopy()
+ void setPaint(final Paint pPaint) 
+ TextureAtlasSourceDecoratorOptions getTextureAtlasSourceDecoratorOptions() 
+ void setTextureAtlasSourceDecoratorOptions(final TextureAtlasSourceDecoratorOptions pTextureAtlasSourceDecoratorOptions) 
# {abstract} void onDecorateBitmap(final Canvas pCanvas) 
+ int getTextureHeight() 
+ Bitmap onLoadBitmap(final Config pBitmapConfig) 
- {static} Bitmap ensureLoadedBitmapIsMutable(final Bitmap pBitmap) 
# TextureAtlasSourceDecoratorOptions deepCopy() 
+ boolean getAntiAliasing() 
+ float getInsetLeft() 
+ float getInsetRight() 
+ float getInsetTop() 
+ float getInsetBottom() 
+ TextureAtlasSourceDecoratorOptions setAntiAliasing(final boolean pAntiAliasing) 
+ TextureAtlasSourceDecoratorOptions setInsetLeft(final float pInsetLeft) 
+ TextureAtlasSourceDecoratorOptions setInsetRight(final float pInsetRight) 
+ TextureAtlasSourceDecoratorOptions setInsetTop(final float pInsetTop) 
+ TextureAtlasSourceDecoratorOptions setInsetBottom(final float pInsetBottom) 
+ TextureAtlasSourceDecoratorOptions setInsets(final float pInsets) 
+ TextureAtlasSourceDecoratorOptions setInsets(final float pInsetLeft, final float pInsetTop, final float pInsetRight, final float pInsetBottom) 
	# final IBitmapTextureAtlasSource mBitmapTextureAtlasSource;
	# TextureAtlasSourceDecoratorOptions mTextureAtlasSourceDecoratorOptions;
		- boolean mAntiAliasing;
 
}
abstract class org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator {
 + {abstract} BaseShapeBitmapTextureAtlasSourceDecorator deepCopy()
	# final IBitmapTextureAtlasSourceDecoratorShape mBitmapTextureAtlasSourceDecoratorShape;
 
}
abstract class org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource {
 + int getTextureX() 
+ int getTextureY() 
+ void setTextureX(final int pTextureX) 
+ void setTextureY(final int pTextureY) 
+ int getTextureWidth() 
+ int getTextureHeight() 
+ void setTextureWidth(final int pTextureWidth) 
+ void setTextureHeight(final int pTextureHeight) 
+ String toString() 
	# int mTextureX;
	# int mTextureY;
	# int mTextureWidth;
	# int mTextureHeight;
 
}
abstract class org.andengine.opengl.texture.compressed.etc1.ETC1Texture {
 + int getWidth() 
+ int getHeight() 
# {abstract} InputStream getInputStream() 
	- ETC1TextureHeader mETC1TextureHeader;
		- final ByteBuffer mDataByteBuffer;
		- final int mWidth;
		- final int mHeight;
 
}
abstract class org.andengine.opengl.texture.compressed.pvr.PVRCCZTexture {
 + final InflaterInputStream getInputStream() 
+ ByteBuffer getPVRTextureBuffer() 
- short getCCZCompressionFormatID() 
+ CCZCompressionFormat getCCZCompressionFormat() 
+ short getVersion() 
+ int getUserdata() 
+ int getUncompressedSize() 
+ InflaterInputStream wrap(final InputStream pInputStream) 
+ {static} CCZCompressionFormat fromID(final short pID) 
	- CCZHeader mCCZHeader;
		- final ByteBuffer mDataByteBuffer;
		- final CCZCompressionFormat mCCZCompressionFormat;
		- final short mID;
 
}
abstract class org.andengine.opengl.texture.compressed.pvr.PVRGZTexture {
 + GZIPInputStream getInputStream() 
 
}
abstract class org.andengine.opengl.texture.compressed.pvr.PVRTexture {
 + int getWidth() 
+ int getHeight() 
+ boolean hasMipMaps() 
+ PVRTextureHeader getPVRTextureHeader() 
# {abstract} InputStream onGetInputStream() 
# void writeTextureToHardware(final GLState pGLState) 
+ ByteBuffer getPVRTextureBuffer() 
+ PVRTextureFormat getPVRTextureFormat() 
+ int headerLength() 
+ int getNumMipmaps() 
+ int getFlags() 
+ int getDataLength() 
+ int getBitsPerPixel() 
+ int getBitmaskRed() 
+ int getBitmaskGreen() 
+ int getBitmaskBlue() 
+ int getBitmaskAlpha() 
+ boolean hasAlpha() 
+ int getPVRTag() 
+ int numSurfs() 
+ {static} PVRTextureFormat fromID(final int pID) 
+ {static} PVRTextureFormat fromPixelFormat(final PixelFormat pPixelFormat) 
+ int getID() 
+ boolean isCompressed() 
+ PixelFormat getPixelFormat() 
	- final PVRTextureHeader mPVRTextureHeader;
	- final IPVRTexturePixelBufferStrategy mPVRTexturePixelBufferStrategy;
		- final ByteBuffer mDataByteBuffer;
		- final PVRTextureFormat mPVRTextureFormat;
		- final int mID;
		- final boolean mCompressed;
		- final PixelFormat mPixelFormat;
 
}
abstract class org.andengine.opengl.texture.region.BaseTextureRegion {
 + {abstract} ITextureRegion deepCopy()
	# final ITexture mTexture;
 
}
abstract class org.andengine.opengl.util.criteria.IntGLCriteria {
 # {abstract} int getActualCriteria(final GLState pGLState)
	- final int mCriteria;
	- final IntOperator mIntOperator;
 
}
abstract class org.andengine.opengl.util.criteria.StringGLCriteria {
 # {abstract} String getActualCriteria(final GLState pGLState)
	- final String mCriteria;
	- final StringOperator mStringOperator;
 
}
abstract class org.andengine.opengl.vbo.SharedMemoryVertexBufferObject {
 + {static} int getSharedByteBufferByteCapacity() 
+ void dispose() 
# ByteBuffer aquireByteBuffer() 
# void releaseByteBuffer(final ByteBuffer byteBuffer) 
	- {static} ByteBuffer sSharedByteBuffer;
 
}
abstract class org.andengine.opengl.vbo.VertexBufferObject {
 + VertexBufferObjectManager getVertexBufferObjectManager() 
+ boolean isDisposed() 
+ boolean isAutoDispose() 
+ int getHardwareBufferID() 
+ boolean isLoadedToHardware() 
+ void setNotLoadedToHardware() 
+ boolean isDirtyOnHardware() 
+ void setDirtyOnHardware() 
+ int getCapacity() 
+ int getByteCapacity() 
+ int getGPUMemoryByteSize() 
# {abstract} void onBufferData()
+ void bind(final GLState pGLState, final ShaderProgram pShaderProgram) 
+ void unbind(final GLState pGLState, final ShaderProgram pShaderProgram) 
+ void unloadFromHardware(final GLState pGLState) 
+ void draw(final int pPrimitiveType, final int pCount) 
+ void draw(final int pPrimitiveType, final int pOffset, final int pCount) 
+ void dispose() 
# void finalize() 
- void loadToHardware(final GLState pGLState) 
	# final int mCapacity;
	# final boolean mAutoDispose;
	# final int mUsage;
	# final ByteBuffer mByteBuffer;
	# boolean mDisposed;
	# final VertexBufferObjectManager mVertexBufferObjectManager;
	# final VertexBufferObjectAttributes mVertexBufferObjectAttributes;
 
}
abstract class org.andengine.opengl.vbo.ZeroMemoryVertexBufferObject {
 + VertexBufferObjectManager getVertexBufferObjectManager() 
+ boolean isDisposed() 
+ boolean isAutoDispose() 
+ int getHardwareBufferID() 
+ boolean isLoadedToHardware() 
+ void setNotLoadedToHardware() 
+ boolean isDirtyOnHardware() 
+ void setDirtyOnHardware() 
+ int getCapacity() 
+ int getByteCapacity() 
+ int getHeapMemoryByteSize() 
+ int getNativeHeapMemoryByteSize() 
+ int getGPUMemoryByteSize() 
# {abstract} void onPopulateBufferData(final ByteBuffer byteBuffer)
+ void bind(final GLState pGLState, final ShaderProgram pShaderProgram) 
+ void unbind(final GLState pGLState, final ShaderProgram pShaderProgram) 
+ void unloadFromHardware(final GLState pGLState) 
+ void draw(final int pPrimitiveType, final int pCount) 
+ void draw(final int pPrimitiveType, final int pOffset, final int pCount) 
+ void dispose() 
# void finalize() 
- void loadToHardware(final GLState pGLState) 
# ByteBuffer aquireByteBuffer() 
# void releaseByteBuffer(final ByteBuffer byteBuffer) 
	# final int mCapacity;
	# final boolean mAutoDispose;
	# final int mUsage;
	# boolean mDisposed;
	# final VertexBufferObjectManager mVertexBufferObjectManager;
	# final VertexBufferObjectAttributes mVertexBufferObjectAttributes;
 
}
abstract class org.andengine.ui.activity.BaseActivity {
 + void toastOnUIThread(final CharSequence pText) 
+ void toastOnUIThread(final CharSequence pText, final int pDuration) 
+ void run() 
# <T> void doAsync(final int pTitleResourceID, final int pMessageResourceID, final Callable<T> pCallable, final Callback<T> pCallback) 
# <T> void doAsync(final int pTitleResourceID, final int pMessageResourceID, final Callable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
# <T> void doProgressAsync(final int pTitleResourceID, final int pIconResourceID, final ProgressCallable<T> pCallable, final Callback<T> pCallback) 
# <T> void doProgressAsync(final int pTitleResourceID, final int pIconResourceID, final ProgressCallable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
# <T> void doAsync(final int pTitleResourceID, final int pMessageResourceID, final AsyncCallable<T> pAsyncCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
 
}
abstract class org.andengine.ui.activity.BaseGameActivity {
 # void onCreate(final Bundle pSavedInstanceState) 
+ Engine onCreateEngine(final EngineOptions pEngineOptions) 
+ synchronized void onSurfaceCreated(final GLState pGLState) 
+ synchronized void onSurfaceChanged(final GLState pGLState, final int pWidth, final int pHeight) 
# synchronized void onCreateGame() 
+ void onPopulateSceneFinished() 
+ void onCreateSceneFinished(final Scene pScene) 
+ void onCreateResourcesFinished() 
+ synchronized void onGameCreated() 
# synchronized void onResume() 
+ synchronized void onResumeGame() 
+ synchronized void onWindowFocusChanged(final boolean pHasWindowFocus) 
+ void onReloadResources() 
# void onPause() 
+ synchronized void onPauseGame() 
# void onDestroy() 
+ void onDestroyResources() 
+ synchronized void onGameDestroyed() 
+ Engine getEngine() 
+ boolean isGamePaused() 
+ boolean isGameRunning() 
+ boolean isGameLoaded() 
+ VertexBufferObjectManager getVertexBufferObjectManager() 
+ TextureManager getTextureManager() 
+ FontManager getFontManager() 
+ ShaderProgramManager getShaderProgramManager() 
+ SoundManager getSoundManager() 
+ MusicManager getMusicManager() 
- void callGameResumedOnUIThread() 
# void onSetContentView() 
+ void runOnUpdateThread(final Runnable pRunnable) 
+ void runOnUpdateThread(final Runnable pRunnable, final boolean pOnlyWhenEngineRunning) 
- void acquireWakeLock() 
- void acquireWakeLock(final WakeLockOptions pWakeLockOptions) 
- void releaseWakeLock() 
- void applyEngineOptions() 
# {static} LayoutParams createSurfaceViewLayoutParams() 
# void enableVibrator() 
# void enableLocationSensor(final ILocationListener pLocationListener, final LocationSensorOptions pLocationSensorOptions) 
# void disableLocationSensor() 
# boolean enableAccelerationSensor(final IAccelerationListener pAccelerationListener) 
# boolean enableAccelerationSensor(final IAccelerationListener pAccelerationListener, final AccelerationSensorOptions pAccelerationSensorOptions) 
# boolean disableAccelerationSensor() 
# boolean enableOrientationSensor(final IOrientationListener pOrientationListener) 
# boolean enableOrientationSensor(final IOrientationListener pOrientationListener, final OrientationSensorOptions pLocationSensorOptions) 
# boolean disableOrientationSensor() 
	# Engine mEngine;
	- WakeLock mWakeLock;
	# RenderSurfaceView mRenderSurfaceView;
	- boolean mGamePaused;
	- boolean mGameCreated;
	- boolean mCreateGameCalled;
	- boolean mOnReloadResourcesScheduled;
 
}
abstract class org.andengine.ui.activity.LayoutGameActivity {
 # {abstract} int getLayoutID()
 
}
abstract class org.andengine.ui.activity.LegacyBaseGameActivity {
 # {abstract} Engine onLoadEngine()
+ final Engine onCreateEngine(final EngineOptions pEngineOptions) 
+ final void onCreateResources(final OnCreateResourcesCallback pOnCreateResourcesCallback) 
+ final void onCreateScene(final OnCreateSceneCallback pOnCreateSceneCallback) 
+ final void onPopulateScene(final Scene pScene, final OnPopulateSceneCallback pOnPopulateSceneCallback) 
+ final void onDestroyResources() 
+ synchronized void onGameCreated() 
 
}
abstract class org.andengine.ui.activity.SimpleAsyncGameActivity {
 + {abstract} void onCreateResourcesAsync(final IProgressListener pProgressListener) 
+ void onCallback(final Void pCallbackValue) 
+ void onCreateScene(final OnCreateSceneCallback pOnCreateSceneCallback) 
+ void onPopulateScene(final Scene pScene, final OnPopulateSceneCallback pOnPopulateSceneCallback) 
 
}
abstract class org.andengine.ui.activity.SimpleBaseGameActivity {
 # {abstract} void onCreateResources()
+ final void onCreateScene(final OnCreateSceneCallback pOnCreateSceneCallback) 
+ final void onPopulateScene(final Scene pScene, final OnPopulateSceneCallback pOnPopulateSceneCallback) 
 
}
abstract class org.andengine.ui.activity.SimpleLayoutGameActivity {
 # {abstract} void onCreateResources()
+ final void onCreateScene(final OnCreateSceneCallback pOnCreateSceneCallback) 
+ final void onPopulateScene(final Scene pScene, final OnPopulateSceneCallback pOnPopulateSceneCallback) 
 
}
abstract class org.andengine.ui.dialog.GenericInputDialogBuilder {
 # {abstract} T generateResult(final String pInput)
+ void onClick(final DialogInterface pDialog, final int pWhich) 
# void setView(final AlertDialog.Builder pBuilder, final EditText pInputEditText) 
	# final Callback<T> mSuccessCallback;
	# final OnCancelListener mOnCancelListener;
	# final int mTitleResID;
	# final int mMessageResID;
	# final int mIconResID;
	# final Context mContext;
	- final int mErrorResID;
	- final String mDefaultText;
 
}
abstract class org.andengine.util.adt.pool.GenericPool {
 + synchronized int getUnrecycledItemCount() 
+ synchronized int getAvailableItemCount() 
+ int getAvailableItemCountMaximum() 
# {abstract} T onAllocatePoolItem()
# T onHandleAllocatePoolItem() 
# void onHandleObtainItem(final T pItem) 
+ synchronized void batchAllocatePoolItems(final int pCount) 
+ synchronized T obtainPoolItem() 
+ synchronized void recyclePoolItem(final T pItem) 
+ synchronized void shufflePoolItems() 
	- final ArrayList<T> mAvailableItems;
	- final int mGrowth;
	- final int mAvailableItemCountMaximum;
	- int mUnrecycledItemCount;
 
}
abstract class org.andengine.util.adt.pool.Pool {
 # T onHandleAllocatePoolItem() 
# void onHandleObtainItem(final T pPoolItem) 
# void onHandleRecycleItem(final T pPoolItem) 
+ synchronized void recyclePoolItem(final T pPoolItem) 
+ synchronized boolean ownsPoolItem(final T pPoolItem) 
 
}
abstract class org.andengine.util.adt.pool.PoolItem {
 + boolean isRecycled() 
+ boolean isFromPool(final Pool<? extends PoolItem> pPool) 
# void onRecycle() 
# void onObtain() 
+ void recycle() 
 
}
abstract class org.andengine.util.adt.pool.PoolUpdateHandler {
 # T onAllocatePoolItem() 
# {abstract} T onAllocatePoolItem()
+ void reset() 
+ T obtainPoolItem() 
+ void postPoolItem(final T pPoolItem) 
	- final Pool<T> mPool;
 
}
abstract class org.andengine.util.adt.pool.RunnablePoolItem {
  
}
abstract class org.andengine.util.adt.pool.RunnablePoolUpdateHandler {
 # {abstract} T onAllocatePoolItem()
 
}
abstract class org.andengine.util.adt.spatial.quadtree.QuadTree {
 # {abstract} QuadTreeNode initRoot(final B pBounds)
+ B getBounds() 
# {abstract} QuadTreeNode getRoot()
+ synchronized int getItemCount() 
+ synchronized boolean isEmpty() 
+ synchronized void add(final T pItem) 
+ synchronized void addAll(final T ... pItems) 
+ synchronized void addAll(final ArrayList<T> pItems) 
+ synchronized void addAll(final Collection<T> pItems) 
+ synchronized void add(final T pItem, final B pBounds) 
+ synchronized void move(final T pItem, final B pBounds) 
+ synchronized void move(final T pItem, final B pOldBounds, final B pNewBounds) 
+ synchronized boolean remove(final T pItem) 
+ synchronized boolean remove(final T pItem, final B pBounds) 
+ synchronized ArrayList<T> query(final B pBounds) 
+ synchronized <L extends List<T>> L query(final B pBounds, final L pResult) 
+ synchronized ArrayList<T> query(final B pBounds, final IMatcher<T> pMatcher) 
+ synchronized <L extends List<T>> L query(final B pBounds, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized <L extends List<S>, S extends T> L queryForSubclass(final B pBounds, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized boolean containsAny(final B pBounds) 
+ synchronized boolean containsAny(final B pBounds, final IMatcher<T> pMatcher) 
+ synchronized void callItems(final ParameterCallable<T> pParameterCallable) 
+ synchronized void callNodes(final ParameterCallable<QuadTreeNode> pParameterCallable) 
+ synchronized void clear() 
+ boolean hasChildren() 
+ List<T> getItems() 
# {abstract} boolean contains(final B pBounds)
+ String toString(final int pIndent) 
+ int getItemCount() 
+ void callItems(final ParameterCallable<T> pParameterCallable) 
+ void callNodes(final ParameterCallable<QuadTreeNode> pParameterCallable) 
+ ArrayList<T> getItemsAndItemsBelow() 
+ <L extends List<T>> L getItemsAndItemsBelow(final L pResult) 
+ ArrayList<T> getItemsAndItemsBelow(final IMatcher<T> pMatcher) 
+ <L extends List<T>> L getItemsAndItemsBelow(final IMatcher<T> pMatcher, final L pResult) 
+ <L extends List<S>, S extends T> L getItemsAndItemsBelowForSubclass(final IMatcher<T> pMatcher, final L pResult) 
+ ArrayList<T> query(final B pBounds) 
+ <L extends List<T>> L query(final B pBounds, final L pResult) 
+ <L extends List<T>> L query(final B pBounds, final IMatcher<T> pMatcher, final L pResult) 
+ <L extends List<S>, S extends T> L queryForSubclass(final B pBounds, final IMatcher<T> pMatcher, final L pResult) 
- <L extends List<T>> boolean queryChild(final B pBounds, final L pResult, final QuadTreeNode pChild) 
- <L extends List<T>> boolean queryChild(final B pBounds, final IMatcher<T> pMatcher, final L pResult, final QuadTreeNode pChild) 
- <L extends List<S>, S extends T> boolean queryChildForSubclass(final B pBounds, final IMatcher<T> pMatcher, final L pResult, final QuadTreeNode pChild) 
+ boolean containsAny(final B pBounds, final IMatcher<T> pMatcher) 
+ boolean containsAny(final B pBounds) 
- boolean containsAnyChild(final B pBounds, final IMatcher<T> pMatcher, final QuadTreeNode pChild) 
- boolean containsAnyChild(final B pBounds, final QuadTreeNode pChild) 
+ void add(final T pItem, final B pBounds) 
+ boolean remove(final T pItem) 
+ boolean remove(final T pItem, final B pBounds) 
- void addItemSafe(final T pItem) 
# void clear() 
	# final B mBounds;
	# final QuadTreeNode mRoot;
	# final int mMaxLevel;
		# final int mLevel;
		# List<T> mItems;
		# QuadTreeNode mTopLeftChild;
		# QuadTreeNode mTopRightChild;
		# QuadTreeNode mBottomLeftChild;
		# QuadTreeNode mBottomRightChild;
 
}
abstract class org.andengine.util.algorithm.sort.Sorter {
 + {abstract} void sort(final T[] pArray, final int pStart, final int pEnd, final Comparator<T> pComparator)
+ final void sort(final List<T> pList, final Comparator<T> pComparator)
+ final void sort(final IList<T> pList, final Comparator<T> pComparator)
 
}
abstract class org.andengine.util.modifier.BaseDoubleValueChangeModifier {
 # void onChangeValue(final float pSecondsElapsed, final T pItem, final float pValueA) 
# {abstract} void onChangeValues(float pSecondsElapsed, T pItem, float pValueA, float pValueB)
	- float mValueChangeBPerSecond;
 
}
abstract class org.andengine.util.modifier.BaseDoubleValueSpanModifier {
 + float getFromValue() 
+ float getToValue() 
+ float getFromValueA() 
+ float getToValueA() 
+ float getFromValueB() 
+ float getToValueB() 
# {abstract} void onSetInitialValues(final T pItem, final float pValueA, final float pValueB)
# void onSetValue(final T pItem, final float pPercentageDone, final float pValueA) 
+ void reset(final float pDuration, final float pFromValue, final float pToValue) 
+ void reset(final float pDuration, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB) 
	- float mFromValueB;
	- float mValueSpanB;
 
}
abstract class org.andengine.util.modifier.BaseDurationModifier {
 + float getSecondsElapsed() 
+ float getDuration() 
# {abstract} void onManagedUpdate(final float pSecondsElapsed, final T pItem)
+ void reset() 
	- float mSecondsElapsed;
	# float mDuration;
~			final float secondsElapsedUsed;
 
}
abstract class org.andengine.util.modifier.BaseModifier {
 + boolean isFinished() 
+ final boolean isAutoUnregisterWhenFinished() 
+ final void setAutoUnregisterWhenFinished(final boolean pAutoUnregisterWhenFinished) 
+ void addModifierListener(final IModifierListener<T> pModifierListener) 
+ boolean removeModifierListener(final IModifierListener<T> pModifierListener) 
+ {abstract} IModifier<T> deepCopy() 
# void onModifierFinished(final T pItem) 
# {static} final <T> void assertNoNullModifier(final IModifier<T> pModifier) 
# {static} final <T> void assertNoNullModifier(final IModifier<T> ... pModifiers) 
	# boolean mFinished;
 
}
abstract class org.andengine.util.modifier.BaseQuadrupelValueSpanModifier {
 # {abstract} void onSetInitialValues(final T pItem, final float pValueA, final float pValueB, final float pValueC, final float pValueD)
# void onSetValues(final T pItem, final float pPercentageDone, final float pValueA, final float pValueB, final float pValueC) 
+ void reset(final float pDuration, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC) 
+ void reset(final float pDuration, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC, final float pFromValueD, final float pToValueD) 
	- float mFromValueD;
	- float mValueSpanD;
 
}
abstract class org.andengine.util.modifier.BaseSingleValueChangeModifier {
 # {abstract} void onChangeValue(final float pSecondsElapsed, final T pItem, final float pValue)
# void onManagedUpdate(final float pSecondsElapsed, final T pItem) 
	- final float mValueChangePerSecond;
 
}
abstract class org.andengine.util.modifier.BaseSingleValueSpanModifier {
 + float getFromValue() 
+ float getToValue() 
# {abstract} void onSetInitialValue(final T pItem, final float pValue)
# void onManagedUpdate(final float pSecondsElapsed, final T pItem) 
+ void reset(final float pDuration, final float pFromValue, final float pToValue) 
	- float mFromValue;
	- float mValueSpan;
	# final IEaseFunction mEaseFunction;
 
}
abstract class org.andengine.util.modifier.BaseTripleValueSpanModifier {
 + float getFromValueC() 
+ float getToValueC() 
# {abstract} void onSetInitialValues(final T pItem, final float pValueA, final float pValueB, final float pValueC)
# void onSetValues(final T pItem, final float pPercentageDone, final float pValueA, final float pValueB) 
+ void reset(final float pDuration, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB) 
+ void reset(final float pDuration, final float pFromValueA, final float pToValueA, final float pFromValueB, final float pToValueB, final float pFromValueC, final float pToValueC) 
	- float mFromValueC;
	- float mValueSpanC;
 
}
class android.app.Activity
class android.app.AlertDialog
class android.app.AlertDialog.Builder
class android.app.Dialog
class android.app.ProgressDialog
class android.content.Context
class android.content.DialogInterface
class android.content.DialogInterface.OnCancelListener
class android.content.DialogInterface.OnClickListener
class android.content.Intent
class android.content.SharedPreferences
class android.content.SharedPreferences.Editor
class android.content.pm.ActivityInfo
class android.content.pm.PackageInfo
class android.content.pm.PackageManager
class android.content.pm.PackageManager.NameNotFoundException
class android.content.res.AssetFileDescriptor
class android.content.res.AssetManager
class android.content.res.Resources
class android.graphics.AvoidXfermode
class android.graphics.AvoidXfermode.Mode
class android.graphics.Bitmap
class android.graphics.Bitmap.CompressFormat
class android.graphics.Bitmap.Config
class android.graphics.BitmapFactory
class android.graphics.Canvas
class android.graphics.LinearGradient
class android.graphics.Paint
class android.graphics.Paint.FontMetrics
class android.graphics.Paint.Style
class android.graphics.Picture
class android.graphics.RadialGradient
class android.graphics.Rect
class android.graphics.RectF
class android.graphics.Shader.TileMode
class android.graphics.Typeface
class android.hardware.Sensor
class android.hardware.SensorEvent
class android.hardware.SensorManager
class android.location.Criteria
class android.location.Location
class android.location.LocationManager
class android.location.LocationProvider
class android.media.AudioManager
class android.media.MediaPlayer
class android.media.MediaPlayer.OnCompletionListener
class android.media.SoundPool
class android.opengl.ETC1
class android.opengl.ETC1Util
class android.opengl.GLES20
class android.opengl.GLSurfaceView
class android.opengl.GLU
class android.opengl.GLUtils
class android.opengl.Matrix
class android.os.AsyncTask
class android.os.Build
class android.os.Bundle
class android.os.Environment
class android.os.Looper
class android.os.PowerManager
class android.os.PowerManager.WakeLock
class android.os.Vibrator
class android.preference.PreferenceManager
class android.speech.tts.TextToSpeech.Engine
class android.util.AttributeSet
class android.util.Base64OutputStream
class android.util.DisplayMetrics
class android.util.FloatMath
class android.util.Log
class android.util.SparseArray
class android.util.SparseBooleanArray
class android.util.SparseIntArray
class android.view.Display
class android.view.GestureDetector
class android.view.GestureDetector.SimpleOnGestureListener
class android.view.Gravity
class android.view.LayoutInflater
class android.view.MotionEvent
class android.view.Surface
class android.view.View
class android.view.View.MeasureSpec
class android.view.ViewGroup
class android.view.Window
class android.view.WindowManager
class android.widget.EditText
class android.widget.FrameLayout.LayoutParams
class android.widget.Toast
class org.andengine.AndEngine {
 + {static} boolean isDeviceSupported() 
+ {static} void checkDeviceSupported() 
- {static} void checkCodePathSupport() 
- {static} void checkOpenGLSupport() 
- {static} void checkEGLConfigChooserSupport() 
 
}
class org.andengine.BuildConfig
class org.andengine.audio.exception.AudioException {
  
}
class org.andengine.audio.music.Music {
 + boolean isPlaying() 
+ MediaPlayer getMediaPlayer() 
# MusicManager getAudioManager() 
# void throwOnReleased() 
+ void play() 
+ void stop() 
+ void resume() 
+ void pause() 
+ void setLooping(final boolean pLooping) 
+ void setVolume(final float pLeftVolume, final float pRightVolume) 
+ void onMasterVolumeChanged(final float pMasterVolume) 
+ void release() 
+ void seekTo(final int pMilliseconds) 
+ void setOnCompletionListener(final OnCompletionListener pOnCompletionListener) 
	- MediaPlayer mMediaPlayer;
 
}
class org.andengine.audio.music.MusicFactory {
 + {static} void setAssetBasePath(final String pAssetBasePath) 
+ {static} String getAssetBasePath() 
+ {static} void onCreate() 
+ {static} Music createMusicFromFile(final MusicManager pMusicManager, final File pFile) 
+ {static} Music createMusicFromAsset(final MusicManager pMusicManager, final Context pContext, final String pAssetPath) 
+ {static} Music createMusicFromResource(final MusicManager pMusicManager, final Context pContext, final int pMusicResID) 
+ {static} Music createMusicFromAssetFileDescriptor(final MusicManager pMusicManager, final AssetFileDescriptor pAssetFileDescriptor) 
 
}
class org.andengine.audio.music.MusicLibrary {
  
}
class org.andengine.audio.music.MusicManager {
  
}
class org.andengine.audio.music.exception.MusicException {
  
}
class org.andengine.audio.music.exception.MusicReleasedException {
  
}
class org.andengine.audio.sound.Sound {
 + int getSoundID() 
+ int getStreamID() 
+ boolean isLoaded() 
+ void setLoaded(final boolean pLoaded) 
+ void setLoopCount(final int pLoopCount) 
+ float getRate() 
+ void setRate(final float pRate) 
- SoundPool getSoundPool() 
# SoundManager getAudioManager() 
# void throwOnReleased() 
+ void play() 
+ void stop() 
+ void resume() 
+ void pause() 
+ void release() 
+ void setLooping(final boolean pLooping) 
+ void setVolume(final float pLeftVolume, final float pRightVolume) 
+ void onMasterVolumeChanged(final float pMasterVolume) 
	- int mSoundID;
	- int mStreamID;
	- boolean mLoaded;
	- int mLoopCount;
 
}
class org.andengine.audio.sound.SoundFactory {
 + {static} void setAssetBasePath(final String pAssetBasePath) 
+ {static} String getAssetBasePath() 
+ {static} void onCreate() 
+ {static} Sound createSoundFromPath(final SoundManager pSoundManager, final String pPath) 
+ {static} Sound createSoundFromAsset(final SoundManager pSoundManager, final Context pContext, final String pAssetPath) 
+ {static} Sound createSoundFromResource(final SoundManager pSoundManager, final Context pContext, final int pSoundResID) 
+ {static} Sound createSoundFromFile(final SoundManager pSoundManager, final File pFile) 
+ {static} Sound createSoundFromAssetFileDescriptor(final SoundManager pSoundManager, final AssetFileDescriptor pAssetFileDescriptor) 
+ {static} Sound createSoundFromFileDescriptor(final SoundManager pSoundManager, final FileDescriptor pFileDescriptor, final long pOffset, final long pLength) 
 
}
class org.andengine.audio.sound.SoundLibrary {
  
}
class org.andengine.audio.sound.SoundManager {
 + void add(final Sound pSound) 
+ boolean remove(final Sound pSound) 
+ void releaseAll() 
+ synchronized void onLoadComplete(final SoundPool pSoundPool, final int pSoundID, final int pStatus) 
	- final SoundPool mSoundPool;
 
}
class org.andengine.audio.sound.exception.SoundException {
  
}
class org.andengine.audio.sound.exception.SoundReleasedException {
  
}
class org.andengine.engine.Engine {
 + void startUpdateThread() 
+ synchronized boolean isRunning() 
+ synchronized void start() 
+ synchronized void stop() 
+ EngineLock getEngineLock() 
+ Scene getScene() 
+ void setScene(final Scene pScene) 
+ EngineOptions getEngineOptions() 
+ Camera getCamera() 
+ float getSecondsElapsedTotal() 
+ void setSurfaceSize(final int pSurfaceWidth, final int pSurfaceHeight) 
# void onUpdateCameraSurface() 
+ int getSurfaceWidth() 
+ int getSurfaceHeight() 
+ ITouchController getTouchController() 
+ void setTouchController(final ITouchController pTouchController) 
+ AccelerationData getAccelerationData() 
+ OrientationData getOrientationData() 
+ VertexBufferObjectManager getVertexBufferObjectManager() 
+ TextureManager getTextureManager() 
+ FontManager getFontManager() 
+ ShaderProgramManager getShaderProgramManager() 
+ SoundManager getSoundManager() 
+ MusicManager getMusicManager() 
+ void registerUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ void unregisterUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ void clearUpdateHandlers() 
+ void registerDrawHandler(final IDrawHandler pDrawHandler) 
+ void unregisterDrawHandler(final IDrawHandler pDrawHandler) 
+ void clearDrawHandlers() 
+ void onAccuracyChanged(final Sensor pSensor, final int pAccuracy) 
+ void onSensorChanged(final SensorEvent pEvent) 
+ void onLocationChanged(final Location pLocation) 
+ void onProviderDisabled(final String pProvider) 
+ void onProviderEnabled(final String pProvider) 
+ void onStatusChanged(final String pProvider, final int pStatus, final Bundle pExtras) 
+ boolean onTouch(final View pView, final MotionEvent pSurfaceMotionEvent) 
+ boolean onTouchEvent(final TouchEvent pSurfaceTouchEvent) 
# boolean onTouchHUD(final Camera pCamera, final TouchEvent pSceneTouchEvent) 
# boolean onTouchScene(final Scene pScene, final TouchEvent pSceneTouchEvent) 
+ void runOnUpdateThread(final Runnable pRunnable) 
+ void runOnUpdateThread(final Runnable pRunnable, final boolean pOnlyWhenEngineRunning) 
+ void runSafely(final Runnable pRunnable) 
+ void onDestroy() 
+ void onReloadResources() 
# Camera getCameraFromSurfaceTouchEvent(final TouchEvent pTouchEvent) 
# Scene getSceneFromSurfaceTouchEvent(final TouchEvent pTouchEvent) 
# void convertSurfaceToSceneTouchEvent(final Camera pCamera, final TouchEvent pSurfaceTouchEvent) 
# void convertSceneToSurfaceTouchEvent(final Camera pCamera, final TouchEvent pSurfaceTouchEvent) 
- void throwOnDestroyed() 
+ void onUpdate(final long pNanosecondsElapsed) 
# void onUpdateScene(final float pSecondsElapsed) 
# void onUpdateUpdateHandlers(final float pSecondsElapsed) 
# void onUpdateDrawHandlers(final GLState pGLState, final Camera pCamera) 
+ void onDrawFrame(final GLState pGLState) 
# void onDrawScene(final GLState pGLState, final Camera pCamera) 
- long getNanosecondsElapsed() 
+ boolean enableVibrator(final Context pContext) 
+ void vibrate(final long pMilliseconds) 
+ void vibrate(final long[] pPattern, final int pRepeat) 
+ void enableLocationSensor(final Context pContext, final ILocationListener pLocationListener, final LocationSensorOptions pLocationSensorOptions) 
+ void disableLocationSensor(final Context pContext) 
+ boolean enableAccelerationSensor(final Context pContext, final IAccelerationListener pAccelerationListener) 
+ boolean enableAccelerationSensor(final Context pContext, final IAccelerationListener pAccelerationListener, final AccelerationSensorOptions pAccelerationSensorOptions) 
+ boolean disableAccelerationSensor(final Context pContext) 
+ boolean enableOrientationSensor(final Context pContext, final IOrientationListener pOrientationListener) 
+ boolean enableOrientationSensor(final Context pContext, final IOrientationListener pOrientationListener, final OrientationSensorOptions pOrientationSensorOptions) 
+ boolean disableOrientationSensor(final Context pContext) 
- {static} boolean isSensorSupported(final SensorManager pSensorManager, final int pType) 
- void registerSelfAsSensorListener(final SensorManager pSensorManager, final int pType, final SensorDelay pSensorDelay) 
- void unregisterSelfAsSensorListener(final SensorManager pSensorManager, final int pType) 
+ void setEngine(final Engine pEngine) 
+ void run() 
+ void postRunnable(final Runnable pRunnable) 
	- boolean mRunning;
	- boolean mDestroyed;
	- long mLastTick;
	- float mSecondsElapsedTotal;
	- final EngineLock mEngineLock;
	- final UpdateThread mUpdateThread;
	- final EngineOptions mEngineOptions;
	# final Camera mCamera;
	- ITouchController mTouchController;
	- final SoundManager mSoundManager;
	- final MusicManager mMusicManager;
	# Scene mScene;
	- Vibrator mVibrator;
	- ILocationListener mLocationListener;
	- Location mLocation;
	- IAccelerationListener mAccelerationListener;
	- AccelerationData mAccelerationData;
	- IOrientationListener mOrientationListener;
	- OrientationData mOrientationData;
		- Engine mEngine;
 
}
class org.andengine.engine.Engine.EngineLock
class org.andengine.engine.Engine.UpdateThread
class org.andengine.engine.FixedStepEngine {
 + void onUpdate(final long pNanosecondsElapsed) 
	- final long mStepLength;
	- long mSecondsElapsedAccumulator;
 
}
class org.andengine.engine.LimitedFPSEngine {
 + void onUpdate(final long pNanosecondsElapsed) 
	- final long mPreferredFrameLengthNanoseconds;
 
}
class org.andengine.engine.camera.BoundCamera {
 + boolean isBoundsEnabled() 
+ void setBoundsEnabled(final boolean pBoundsEnabled) 
+ void setBounds(final float pBoundsXMin, final float pBoundsYMin, final float pBoundsXMax, final float pBoundsYMax) 
+ float getBoundsXMin() 
+ float getBoundsXMax() 
+ float getBoundsYMin() 
+ float getBoundsYMax() 
+ float getBoundsWidth() 
+ float getBoundsHeight() 
+ void setCenter(final float pCenterX, final float pCenterY) 
# void ensureInBounds() 
# float getBoundedX(final float pX) 
# float getBoundedY(final float pY) 
	# boolean mBoundsEnabled;
	# float mBoundsXMin;
	# float mBoundsXMax;
	# float mBoundsYMin;
	# float mBoundsYMax;
	# float mBoundsCenterX;
	# float mBoundsCenterY;
	# float mBoundsWidth;
	# float mBoundsHeight;
~		final float centerY;
 
}
class org.andengine.engine.camera.Camera {
 + float getXMin() 
+ void setXMin(final float pXMin) 
+ float getXMax() 
+ void setXMax(final float pXMax) 
+ float getYMin() 
+ void setYMin(final float pYMin) 
+ float getYMax() 
+ void setYMax(final float pYMax) 
+ void set(final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
+ float getZNear() 
+ float getZFar() 
+ void setZNear(final float pZNear) 
+ void setZFar(final float pZFar) 
+ void setZClippingPlanes(final float pNearZClippingPlane, final float pFarZClippingPlane) 
+ float getWidth() 
+ float getHeight() 
+ float getWidthRaw() 
+ float getHeightRaw() 
+ float getCenterX() 
+ float getCenterY() 
+ void setCenter(final float pCenterX, final float pCenterY) 
+ void offsetCenter(final float pX, final float pY) 
+ HUD getHUD() 
+ void setHUD(final HUD pHUD) 
+ boolean hasHUD() 
+ void setChaseEntity(final IEntity pChaseEntity) 
+ boolean isRotated() 
+ float getRotation() 
+ void setRotation(final float pRotation) 
+ float getCameraSceneRotation() 
+ void setCameraSceneRotation(final float pCameraSceneRotation) 
+ int getSurfaceX() 
+ int getSurfaceY() 
+ int getSurfaceWidth() 
+ int getSurfaceHeight() 
+ void setSurfaceSize(final int pSurfaceX, final int pSurfaceY, final int pSurfaceWidth, final int pSurfaceHeight) 
+ boolean isResizeOnSurfaceSizeChanged() 
+ void setResizeOnSurfaceSizeChanged(final boolean pResizeOnSurfaceSizeChanged) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
+ void onDrawHUD(final GLState pGLState) 
+ void updateChaseEntity() 
+ boolean isLineVisible(final Line pLine) 
+ boolean isRectangularShapeVisible(final RectangularShape pRectangularShape) 
+ boolean isRectangularShapeVisible(final float pX, final float pY, final float pWidth, final float pHeight, final Transformation pLocalToSceneTransformation) 
+ void onApplySceneMatrix(final GLState pGLState) 
+ void onApplySceneBackgroundMatrix(final GLState pGLState) 
+ void onApplyCameraSceneMatrix(final GLState pGLState) 
- {static} void applyRotation(final GLState pGLState, final float pRotationCenterX, final float pRotationCenterY, final float pAngle) 
+ void convertSceneToCameraSceneTouchEvent(final TouchEvent pSceneTouchEvent) 
+ float[] getCameraSceneCoordinatesFromSceneCoordinates(final float pSceneX, final float pSceneY) 
+ float[] getCameraSceneCoordinatesFromSceneCoordinates(final float[] pSceneCoordinates) 
+ void convertCameraSceneToSceneTouchEvent(final TouchEvent pCameraSceneTouchEvent) 
+ float[] getSceneCoordinatesFromCameraSceneCoordinates(final float pCameraSceneX, final float pCameraSceneY) 
+ float[] getSceneCoordinatesFromCameraSceneCoordinates(final float[] pCameraSceneCoordinates) 
# void applySceneToCameraSceneOffset(final TouchEvent pSceneTouchEvent) 
# void applySceneToCameraSceneOffset(final float[] pSceneCoordinates) 
# void unapplySceneToCameraSceneOffset(final TouchEvent pCameraSceneTouchEvent) 
# void unapplySceneToCameraSceneOffset(final float[] pCameraSceneCoordinates) 
- void applySceneRotation(final float[] pCameraSceneCoordinates) 
- void applySceneRotation(final TouchEvent pCameraSceneTouchEvent) 
- void unapplySceneRotation(final float[] pSceneCoordinates) 
- void unapplySceneRotation(final TouchEvent pSceneTouchEvent) 
- void applyCameraSceneRotation(final float[] pSceneCoordinates) 
- void applyCameraSceneRotation(final TouchEvent pSceneTouchEvent) 
- void unapplyCameraSceneRotation(final float[] pCameraSceneCoordinates) 
- void unapplyCameraSceneRotation(final TouchEvent pCameraSceneTouchEvent) 
+ void convertSurfaceToSceneTouchEvent(final TouchEvent pSurfaceTouchEvent, final int pSurfaceWidth, final int pSurfaceHeight) 
- void convertAxisAlignedSurfaceToSceneTouchEvent(final TouchEvent pSurfaceTouchEvent, final float pRelativeX, final float pRelativeY) 
+ void convertSceneToSurfaceTouchEvent(final TouchEvent pSceneTouchEvent, final int pSurfaceWidth, final int pSurfaceHeight) 
- void convertAxisAlignedSceneToSurfaceTouchEvent(final TouchEvent pSceneTouchEvent, final int pSurfaceWidth, final int pSurfaceHeight) 
+ void registerUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ boolean unregisterUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ boolean unregisterUpdateHandlers(final IUpdateHandlerMatcher pUpdateHandlerMatcher) 
+ void clearUpdateHandlers() 
- void allocateUpdateHandlers() 
# void onSurfaceSizeInitialized(final int pSurfaceX, final int pSurfaceY, final int pSurfaceWidth, final int pSurfaceHeight) 
# void onSurfaceSizeChanged(final int pOldSurfaceX, final int pOldSurfaceY, final int pOldSurfaceWidth, final int pOldSurfaceHeight, final int pNewSurfaceX, final int pNewSurfaceY, final int pNewSurfaceWidth, final int pNewSurfaceHeight) 
	# float mXMin;
	# float mXMax;
	# float mYMin;
	# float mYMax;
	- HUD mHUD;
	- IEntity mChaseEntity;
	# int mSurfaceX;
	# int mSurfaceY;
	# int mSurfaceWidth;
	# int mSurfaceHeight;
	# boolean mResizeOnSurfaceSizeChanged;
	# UpdateHandlerList mUpdateHandlers;
 
}
class org.andengine.engine.camera.CameraFactory {
 + {static} Camera createPixelPerfectCamera(final Context pContext, final float pCenterX, final float pCenterY) 
- {static} DisplayMetrics getDisplayMetrics(final Context pContext) 
 
}
class org.andengine.engine.camera.SmoothCamera {
 + float getTargetCenterX() 
+ float getTargetCenterY() 
+ float getTargetZoomFactor() 
+ void setCenter(final float pCenterX, final float pCenterY) 
+ void setCenterDirect(final float pCenterX, final float pCenterY) 
+ void setZoomFactor(final float pZoomFactor) 
+ void setZoomFactorDirect(final float pZoomFactor) 
+ float getMaxVelocityX() 
+ void setMaxVelocityX(final float pMaxVelocityX) 
+ float getMaxVelocityY() 
+ void setMaxVelocityY(final float pMaxVelocityY) 
+ void setMaxVelocity(final float pMaxVelocityX, final float pMaxVelocityY) 
+ float getMaxZoomFactorChange() 
+ void setMaxZoomFactorChange(final float pMaxZoomFactorChange) 
# void onSmoothZoomStarted() 
# void onSmoothZoomFinished() 
+ void onUpdate(final float pSecondsElapsed) 
- float limitToMaxVelocityX(final float pValue, final float pSecondsElapsed) 
- float limitToMaxVelocityY(final float pValue, final float pSecondsElapsed) 
- float limitToMaxZoomFactorChange(final float pValue, final float pSecondsElapsed) 
	# float mMaxVelocityX;
	# float mMaxVelocityY;
	# float mMaxZoomFactorChange;
	# float mTargetCenterX;
	# float mTargetCenterY;
	# float mTargetZoomFactor;
 
}
class org.andengine.engine.camera.ZoomCamera {
 + float getZoomFactor() 
+ void setZoomFactor(final float pZoomFactor) 
+ float getXMin() 
+ float getXMax() 
+ float getYMin() 
+ float getYMax() 
+ float getWidth() 
+ float getHeight() 
# void applySceneToCameraSceneOffset(final TouchEvent pSceneTouchEvent) 
# void applySceneToCameraSceneOffset(final float[] pSceneCoordinates) 
# void unapplySceneToCameraSceneOffset(final TouchEvent pCameraSceneTouchEvent) 
# void unapplySceneToCameraSceneOffset(final float[] pCameraSceneCoordinates) 
 
}
class org.andengine.engine.camera.hud.HUD {
  
}
class org.andengine.engine.camera.hud.controls.AnalogOnScreenControl {
 + IAnalogOnScreenControlListener getOnScreenControlListener() 
+ void setOnControlClickEnabled(final boolean pOnControlClickEnabled) 
+ void setOnControlClickMaximumMilliseconds(final long pOnControlClickMaximumMilliseconds) 
+ void onClick(final ClickDetector pClickDetector, final int pPointerID, final float pSceneX, final float pSceneY) 
# boolean onHandleControlBaseTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
# void onUpdateControlKnob(final float pRelativeX, final float pRelativeY) 
+ void onControlClick(final AnalogOnScreenControl pAnalogOnScreenControl)
 
}
class org.andengine.engine.camera.hud.controls.DigitalOnScreenControl {
 + boolean isAllowDiagonal() 
+ void setAllowDiagonal(final boolean pAllowDiagonal) 
# void onUpdateControlKnob(final float pRelativeX, final float pRelativeY) 
- {static} boolean testDiagonalAngle(final float pTestAngle, final float pActualAngle) 
	- boolean mAllowDiagonal;
 
}
class org.andengine.engine.handler.DrawHandlerList {
 + void onDraw(final GLState pGLState, final Camera pCamera) 
 
}
class org.andengine.engine.handler.UpdateHandlerList {
 + void onUpdate(final float pSecondsElapsed) 
+ void reset() 
 
}
class org.andengine.engine.handler.collision.CollisionHandler {
 + void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	- final ICollisionCallback mCollisionCallback;
	- final IShape mCheckShape;
 
}
class org.andengine.engine.handler.physics.PhysicsHandler {
 + boolean isEnabled() 
+ void setEnabled(final boolean pEnabled) 
+ float getVelocityX() 
+ float getVelocityY() 
+ void setVelocityX(final float pVelocityX) 
+ void setVelocityY(final float pVelocityY) 
+ void setVelocity(final float pVelocity) 
+ void setVelocity(final float pVelocityX, final float pVelocityY) 
+ float getAccelerationX() 
+ float getAccelerationY() 
+ void setAccelerationX(final float pAccelerationX) 
+ void setAccelerationY(final float pAccelerationY) 
+ void setAcceleration(final float pAccelerationX, final float pAccelerationY) 
+ void setAcceleration(final float pAcceleration) 
+ void accelerate(final float pAccelerationX, final float pAccelerationY) 
+ float getAngularVelocity() 
+ void setAngularVelocity(final float pAngularVelocity) 
# void onUpdate(final float pSecondsElapsed, final IEntity pEntity) 
+ void reset() 
 
}
class org.andengine.engine.handler.runnable.RunnableHandler {
 + synchronized void onUpdate(final float pSecondsElapsed) 
+ synchronized void reset() 
+ synchronized void postRunnable(final Runnable pRunnable) 
 
}
class org.andengine.engine.handler.timer.TimerHandler {
 + boolean isAutoReset() 
+ void setAutoReset(final boolean pAutoReset) 
+ void setTimerSeconds(final float pTimerSeconds) 
+ float getTimerSeconds() 
+ float getTimerSecondsElapsed() 
+ boolean isTimerCallbackTriggered() 
+ void setTimerCallbackTriggered(boolean pTimerCallbackTriggered) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	- float mTimerSeconds;
	- float mTimerSecondsElapsed;
	- boolean mTimerCallbackTriggered;
	# final ITimerCallback mTimerCallback;
	- boolean mAutoReset;
 
}
class org.andengine.engine.options.AudioOptions {
 + SoundOptions getSoundOptions() 
+ MusicOptions getMusicOptions() 
+ boolean needsSound() 
+ AudioOptions setNeedsSound(final boolean pNeedsSound) 
+ boolean needsMusic() 
+ AudioOptions setNeedsMusic(final boolean pNeedsMusic) 
 
}
class org.andengine.engine.options.EngineOptions {
 + boolean hasEngineLock() 
+ EngineLock getEngineLock() 
+ void setEngineLock(final EngineLock pEngineLock) 
+ TouchOptions getTouchOptions() 
+ AudioOptions getAudioOptions() 
+ RenderOptions getRenderOptions() 
+ boolean isFullscreen() 
+ ScreenOrientation getScreenOrientation() 
+ IResolutionPolicy getResolutionPolicy() 
+ Camera getCamera() 
+ boolean hasUpdateThread() 
+ UpdateThread getUpdateThread() 
+ void setUpdateThread(final UpdateThread pUpdateThread) 
+ int getUpdateThreadPriority() 
+ void setUpdateThreadPriority(final int pUpdateThreadPriority) 
+ WakeLockOptions getWakeLockOptions() 
+ EngineOptions setWakeLockOptions(final WakeLockOptions pWakeLockOptions) 
	- EngineLock mEngineLock;
	- final boolean mFullscreen;
	- final ScreenOrientation mScreenOrientation;
	- final IResolutionPolicy mResolutionPolicy;
	- final Camera mCamera;
	- UpdateThread mUpdateThread;
 
}
class org.andengine.engine.options.MusicOptions {
 + boolean needsMusic() 
+ MusicOptions setNeedsMusic(final boolean pNeedsMusic) 
	- boolean mNeedsMusic;
 
}
class org.andengine.engine.options.RenderOptions {
 + boolean isMultiSampling() 
+ void setMultiSampling(final boolean pMultiSampling) 
+ boolean isDithering() 
+ void setDithering(final boolean pDithering) 
 
}
class org.andengine.engine.options.SoundOptions {
 + boolean needsSound() 
+ SoundOptions setNeedsSound(final boolean pNeedsSound) 
+ int getMaxSimultaneousStreams() 
+ SoundOptions setMaxSimultaneousStreams(final int pMaxSimultaneousStreams) 
	- boolean mNeedsSound;
 
}
class org.andengine.engine.options.TouchOptions {
 + boolean needsMultiTouch() 
+ TouchOptions setNeedsMultiTouch(final boolean pNeedsMultiTouch) 
+ long getTouchEventIntervalMilliseconds() 
+ void setTouchEventIntervalMilliseconds(final long pTouchEventIntervalMilliseconds) 
	- boolean mNeedsMultiTouch;
 
}
class org.andengine.engine.options.resolutionpolicy.FillResolutionPolicy {
 + void onMeasure(final RenderSurfaceView pRenderSurfaceView, final int pWidthMeasureSpec, final int pHeightMeasureSpec) 
 
}
class org.andengine.engine.options.resolutionpolicy.FixedResolutionPolicy {
 + void onMeasure(final RenderSurfaceView pRenderSurfaceView, final int pWidthMeasureSpec, final int pHeightMeasureSpec) 
	- final int mWidth;
	- final int mHeight;
 
}
class org.andengine.engine.options.resolutionpolicy.RatioResolutionPolicy {
 + void onMeasure(final RenderSurfaceView pRenderSurfaceView, final int pWidthMeasureSpec, final int pHeightMeasureSpec) 
	- final float mRatio;
 
}
class org.andengine.engine.options.resolutionpolicy.RelativeResolutionPolicy {
 + void onMeasure(final RenderSurfaceView pRenderSurfaceView, final int pWidthMeasureSpec, final int pHeightMeasureSpec) 
	- final float mWidthScale;
	- final float mHeightScale;
 
}
class org.andengine.engine.splitscreen.DoubleSceneSplitScreenEngine {
 + Camera getCamera() 
+ Camera getFirstCamera() 
+ Camera getSecondCamera() 
+ Scene getScene() 
+ Scene getFirstScene() 
+ Scene getSecondScene() 
+ void setScene(final Scene pScene) 
+ void setFirstScene(final Scene pScene) 
+ void setSecondScene(final Scene pScene) 
# void onDrawScene(final GLState pGLState, final Camera pFirstCamera) 
# Camera getCameraFromSurfaceTouchEvent(final TouchEvent pTouchEvent) 
# Scene getSceneFromSurfaceTouchEvent(final TouchEvent pTouchEvent) 
# void onUpdateScene(final float pSecondsElapsed) 
# void convertSurfaceToSceneTouchEvent(final Camera pCamera, final TouchEvent pSurfaceTouchEvent) 
# void onUpdateUpdateHandlers(final float pSecondsElapsed) 
# void onUpdateCameraSurface() 
	- Scene mSecondScene;
	- final Camera mSecondCamera;
 
}
class org.andengine.engine.splitscreen.SingleSceneSplitScreenEngine {
 + Camera getCamera() 
+ Camera getFirstCamera() 
+ Camera getSecondCamera() 
# void onDrawScene(final GLState pGLState, final Camera pFirstCamera) 
# Camera getCameraFromSurfaceTouchEvent(final TouchEvent pTouchEvent) 
# void convertSurfaceToSceneTouchEvent(final Camera pCamera, final TouchEvent pSurfaceTouchEvent) 
# void onUpdateUpdateHandlers(final float pSecondsElapsed) 
# void onUpdateCameraSurface() 
	- final Camera mSecondCamera;
 
}
class org.andengine.entity.Entity {
 + void call(final IEntity pEntity) 
# void onUpdateColor() 
+ boolean isDisposed() 
+ boolean isVisible() 
+ void setVisible(final boolean pVisible) 
+ boolean isCullingEnabled() 
+ void setCullingEnabled(final boolean pCullingEnabled) 
+ boolean isCulled(final Camera pCamera) 
+ boolean isChildrenVisible() 
+ void setChildrenVisible(final boolean pChildrenVisible) 
+ boolean isIgnoreUpdate() 
+ void setIgnoreUpdate(final boolean pIgnoreUpdate) 
+ boolean isChildrenIgnoreUpdate() 
+ void setChildrenIgnoreUpdate(final boolean pChildrenIgnoreUpdate) 
+ boolean hasParent() 
+ IEntity getParent() 
+ void setParent(final IEntity pEntity) 
+ int getTag() 
+ void setTag(final int pTag) 
+ int getZIndex() 
+ void setZIndex(final int pZIndex) 
+ float getX() 
+ float getY() 
+ void setX(final float pX) 
+ void setY(final float pY) 
+ void setPosition(final IEntity pOtherEntity) 
+ void setPosition(final float pX, final float pY) 
+ float getRotation() 
+ boolean isRotated() 
+ void setRotation(final float pRotation) 
+ float getRotationCenterX() 
+ float getRotationCenterY() 
+ void setRotationCenterX(final float pRotationCenterX) 
+ void setRotationCenterY(final float pRotationCenterY) 
+ void setRotationCenter(final float pRotationCenterX, final float pRotationCenterY) 
+ boolean isScaled() 
+ float getScaleX() 
+ float getScaleY() 
+ void setScaleX(final float pScaleX) 
+ void setScaleY(final float pScaleY) 
+ void setScale(final float pScale) 
+ void setScale(final float pScaleX, final float pScaleY) 
+ float getScaleCenterX() 
+ float getScaleCenterY() 
+ void setScaleCenterX(final float pScaleCenterX) 
+ void setScaleCenterY(final float pScaleCenterY) 
+ void setScaleCenter(final float pScaleCenterX, final float pScaleCenterY) 
+ boolean isSkewed() 
+ float getSkewX() 
+ float getSkewY() 
+ void setSkewX(final float pSkewX) 
+ void setSkewY(final float pSkewY) 
+ void setSkew(final float pSkew) 
+ void setSkew(final float pSkewX, final float pSkewY) 
+ float getSkewCenterX() 
+ float getSkewCenterY() 
+ void setSkewCenterX(final float pSkewCenterX) 
+ void setSkewCenterY(final float pSkewCenterY) 
+ void setSkewCenter(final float pSkewCenterX, final float pSkewCenterY) 
+ boolean isRotatedOrScaledOrSkewed() 
+ float getRed() 
+ float getGreen() 
+ float getBlue() 
+ float getAlpha() 
+ Color getColor() 
+ void setColor(final Color pColor) 
+ void setRed(final float pRed) 
+ void setGreen(final float pGreen) 
+ void setBlue(final float pBlue) 
+ void setAlpha(final float pAlpha) 
+ void setColor(final float pRed, final float pGreen, final float pBlue) 
+ void setColor(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ int getChildCount() 
+ IEntity getChildByTag(final int pTag) 
+ IEntity getChildByIndex(final int pIndex) 
+ IEntity getChildByMatcher(final IEntityMatcher pEntityMatcher) 
+ IEntity getFirstChild() 
+ IEntity getLastChild() 
+ ArrayList<IEntity> query(final IEntityMatcher pEntityMatcher) 
+ IEntity queryFirst(final IEntityMatcher pEntityMatcher) 
+ <S extends IEntity> S queryFirstForSubclass(final IEntityMatcher pEntityMatcher) 
+ <L extends List<IEntity>> L query(final IEntityMatcher pEntityMatcher, final L pResult) 
+ <S extends IEntity> ArrayList<S> queryForSubclass(final IEntityMatcher pEntityMatcher) 
+ <L extends List<S>, S extends IEntity> L queryForSubclass(final IEntityMatcher pEntityMatcher, final L pResult) 
+ boolean detachSelf() 
+ void detachChildren() 
+ void attachChild(final IEntity pEntity) 
+ void sortChildren() 
+ void sortChildren(final boolean pImmediate) 
+ void sortChildren(final IEntityComparator pEntityComparator) 
+ boolean detachChild(final IEntity pEntity) 
+ IEntity detachChild(final int pTag) 
+ IEntity detachChild(final IEntityMatcher pEntityMatcher) 
+ boolean detachChildren(final IEntityMatcher pEntityMatcher) 
+ void callOnChildren(final IEntityParameterCallable pEntityParameterCallable) 
+ void callOnChildren(final IEntityParameterCallable pEntityParameterCallable, final IEntityMatcher pEntityMatcher) 
+ void registerUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ boolean unregisterUpdateHandler(final IUpdateHandler pUpdateHandler) 
+ boolean unregisterUpdateHandlers(final IUpdateHandlerMatcher pUpdateHandlerMatcher) 
+ int getUpdateHandlerCount() 
+ void clearUpdateHandlers() 
+ void registerEntityModifier(final IEntityModifier pEntityModifier) 
+ boolean unregisterEntityModifier(final IEntityModifier pEntityModifier) 
+ boolean unregisterEntityModifiers(final IEntityModifierMatcher pEntityModifierMatcher) 
+ int getEntityModifierCount() 
+ void clearEntityModifiers() 
+ float[] getSceneCenterCoordinates() 
+ float[] getSceneCenterCoordinates(final float[] pReuse) 
+ Transformation getLocalToParentTransformation() 
+ Transformation getParentToLocalTransformation() 
+ Transformation getLocalToSceneTransformation() 
+ Transformation getSceneToLocalTransformation() 
+ float[] convertLocalToSceneCoordinates(final float pX, final float pY) 
+ float[] convertLocalToSceneCoordinates(final float pX, final float pY, final float[] pReuse) 
+ float[] convertLocalToSceneCoordinates(final float[] pCoordinates) 
+ float[] convertLocalToSceneCoordinates(final float[] pCoordinates, final float[] pReuse) 
+ float[] convertSceneToLocalCoordinates(final float pX, final float pY) 
+ float[] convertSceneToLocalCoordinates(final float pX, final float pY, final float[] pReuse) 
+ float[] convertSceneToLocalCoordinates(final float[] pCoordinates) 
+ float[] convertSceneToLocalCoordinates(final float[] pCoordinates, final float[] pReuse) 
+ void onAttached() 
+ void onDetached() 
+ Object getUserData() 
+ void setUserData(final Object pUserData) 
+ final void onDraw(final GLState pGLState, final Camera pCamera) 
+ final void onUpdate(final float pSecondsElapsed) 
+ void reset() 
+ void dispose() 
# void finalize() 
+ String toString() 
+ void toString(final StringBuilder pStringBuilder) 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
- void allocateEntityModifiers() 
- void allocateChildren() 
- void allocateUpdateHandlers() 
# void onApplyTransformations(final GLState pGLState) 
# void applyTranslation(final GLState pGLState) 
# void applyRotation(final GLState pGLState) 
# void applySkew(final GLState pGLState) 
# void applyScale(final GLState pGLState) 
# void onManagedDraw(final GLState pGLState, final Camera pCamera) 
# void onManagedUpdate(final float pSecondsElapsed) 
- void assertEntityHasNoParent(final IEntity pEntity) 
	# boolean mDisposed;
	# boolean mCullingEnabled;
	# boolean mIgnoreUpdate;
	# boolean mChildrenIgnoreUpdate;
	# boolean mChildrenSortPending;
	- IEntity mParent;
	# SmartList<IEntity> mChildren;
	- EntityModifierList mEntityModifiers;
	- UpdateHandlerList mUpdateHandlers;
	# float mX;
	# float mY;
	- Transformation mLocalToParentTransformation;
	- Transformation mParentToLocalTransformation;
	- Transformation mLocalToSceneTransformation;
	- Transformation mSceneToLocalTransformation;
	- Object mUserData;
 
}
class org.andengine.entity.TagEntityMatcher {
 + int getTag() 
+ void setTag(final int pTag) 
+ boolean matches(final IEntity pEntity) 
	- int mTag;
 
}
class org.andengine.entity.ZIndexSorter {
 + int compare(final IEntity pEntityA, final IEntity pEntityB) 
+ {static} ZIndexSorter getInstance() 
+ void sort(final IEntity[] pEntities) 
+ void sort(final IEntity[] pEntities, final int pStart, final int pEnd) 
+ void sort(final List<IEntity> pEntities) 
+ void sort(final List<IEntity> pEntities, final int pStart, final int pEnd) 
+ void sort(final IList<IEntity> pEntities) 
+ void sort(final IList<IEntity> pEntities, final int pStart, final int pEnd) 
	- {static} ZIndexSorter INSTANCE;
 
}
class org.andengine.entity.modifier.AlphaModifier {
 + AlphaModifier deepCopy()
# void onSetInitialValue(final IEntity pEntity, final float pAlpha) 
# void onSetValue(final IEntity pEntity, final float pPercentageDone, final float pAlpha) 
 
}
class org.andengine.entity.modifier.CardinalSplineMoveModifier {
 + CardinalSplineMoveModifier deepCopy() 
+ CardinalSplineMoveModifier reverse() 
# void onManagedInitialize(final IEntity pEntity) 
# void onManagedUpdate(final float pSecondsElapsed, final IEntity pEntity) 
+ {static} final float cardinalSplineX(final float pX0, final float pX1, final float pX2, final float pX3, final float pT, final float pTension) 
+ {static} final float cardinalSplineY(final float pY0, final float pY1, final float pY2, final float pY3, final float pT, final float pTension) 
+ CardinalSplineMoveModifierConfig deepCopy() 
+ CardinalSplineMoveModifierConfig deepCopyReverse() 
+ int getControlPointCount() 
+ void setControlPoint(final int pIndex, final float pX, final float pY) 
+ float getControlPointX(final int pIndex) 
+ float getControlPointY(final int pIndex) 
	- final CardinalSplineMoveModifierConfig mCardinalSplineMoveModifierConfig;
	- final IEaseFunction mEaseFunction;
	- final int mControlSegmentCount;
	- final float mControlSegmentCountInverse;
		/* package */ - final float[] mControlPointXs;
		/* package */ - final float[] mControlPointYs;
~		/* package */ final float mTension;
 
}
class org.andengine.entity.modifier.CatmullRomSplineMoveModifier {
  
}
class org.andengine.entity.modifier.ColorModifier {
 + ColorModifier deepCopy()
# void onSetInitialValues(final IEntity pEntity, final float pRed, final float pGreen, final float pBlue) 
# void onSetValues(final IEntity pEntity, final float pPerctentageDone, final float pRed, final float pGreen, final float pBlue) 
 
}
class org.andengine.entity.modifier.CubicBezierCurveMoveModifier {
 + CubicBezierCurveMoveModifier deepCopy() 
# void onManagedInitialize(final IEntity pEntity) 
# void onManagedUpdate(final float pSecondsElapsed, final IEntity pEntity) 
	- final float mX1;
	- final float mY1;
	- final float mX2;
	- final float mY2;
	- final float mX3;
	- final float mY3;
	- final float mX4;
	- final float mY4;
	- final IEaseFunction mEaseFunction;
 
}
class org.andengine.entity.modifier.DelayModifier {
 + DelayModifier deepCopy()
# void onManagedInitialize(final IEntity pEntity) 
# void onManagedUpdate(final float pSecondsElapsed, final IEntity pEntity) 
 
}
class org.andengine.entity.modifier.EntityModifierList {
  
}
class org.andengine.entity.modifier.FadeInModifier {
 + FadeInModifier deepCopy() 
 
}
class org.andengine.entity.modifier.FadeOutModifier {
 + FadeOutModifier deepCopy() 
 
}
class org.andengine.entity.modifier.IEntityModifier {
 + IEntityModifier deepCopy() 
 
}.IEntityModifierMatcher
class org.andengine.entity.modifier.JumpModifier {
 + JumpModifier deepCopy() 
# void onSetValues(final IEntity pEntity, final float pPercentageDone, final float pX, final float pY) 
	# final float mJumpHeight;
	# final int mJumpCount;
 
}
class org.andengine.entity.modifier.LoopEntityModifier {
 + LoopEntityModifier deepCopy() 
 
}
class org.andengine.entity.modifier.MoveByModifier {
 + MoveByModifier deepCopy()
# void onChangeValues(final float pSecondsElapsed, final IEntity pEntity, final float pX, final float pY) 
 
}
class org.andengine.entity.modifier.MoveModifier {
 + MoveModifier deepCopy()
# void onSetInitialValues(final IEntity pEntity, final float pX, final float pY) 
# void onSetValues(final IEntity pEntity, final float pPercentageDone, final float pX, final float pY) 
 
}
class org.andengine.entity.modifier.MoveXModifier {
 + MoveXModifier deepCopy()
# void onSetInitialValue(final IEntity pEntity, final float pX) 
# void onSetValue(final IEntity pEntity, final float pPercentageDone, final float pX) 
 
}
class org.andengine.entity.modifier.MoveYModifier {
 + MoveYModifier deepCopy()
# void onSetInitialValue(final IEntity pEntity, final float pY) 
# void onSetValue(final IEntity pEntity, final float pPercentageDone, final float pY) 
 
}
class org.andengine.entity.modifier.ParallelEntityModifier {
 + ParallelEntityModifier deepCopy() 
 
}
class org.andengine.entity.modifier.PathModifier {
 + void onSubSequenceStarted(final IModifier<IEntity> pModifier, final IEntity pEntity, final int pIndex) 
+ void onSubSequenceFinished(final IModifier<IEntity> pEntityModifier, final IEntity pEntity, final int pIndex) 
+ void onModifierStarted(final IModifier<IEntity> pModifier, final IEntity pEntity) 
+ void onModifierFinished(final IModifier<IEntity> pEntityModifier, final IEntity pEntity) 
+ PathModifier deepCopy() 
+ Path getPath() 
+ boolean isFinished() 
+ float getSecondsElapsed() 
+ float getDuration() 
+ IPathModifierListener getPathModifierListener() 
+ void setPathModifierListener(final IPathModifierListener pPathModifierListener) 
+ void reset() 
+ float onUpdate(final float pSecondsElapsed, final IEntity pEntity) 
+ void onPathStarted(final PathModifier pPathModifier, final IEntity pEntity)
+ Path deepCopy() 
+ Path to(final float pX, final float pY) 
+ float[] getCoordinatesX() 
+ float[] getCoordinatesY() 
+ int getSize() 
+ float getLength() 
+ float getSegmentLength(final int pSegmentIndex) 
- void updateLength() 
	- final SequenceModifier<IEntity> mSequenceModifier;
	- IPathModifierListener mPathModifierListener;
	- final Path mPath;
		- final float[] mXs;
		- final float[] mYs;
		- int mIndex;
		- float mLength;
 
}
class org.andengine.entity.modifier.QuadraticBezierCurveMoveModifier {
 + QuadraticBezierCurveMoveModifier deepCopy() 
# void onManagedInitialize(final IEntity pEntity) 
# void onManagedUpdate(final float pSecondsElapsed, final IEntity pEntity) 
	- final float mX1;
	- final float mY1;
	- final float mX2;
	- final float mY2;
	- final float mX3;
	- final float mY3;
	- final IEaseFunction mEaseFunction;
 
}
class org.andengine.entity.modifier.RotationAtModifier {
 + RotationAtModifier deepCopy()
# void onManagedInitialize(final IEntity pEntity) 
	- final float mRotationCenterX;
	- final float mRotationCenterY;
 
}
class org.andengine.entity.modifier.RotationByModifier {
 + RotationByModifier deepCopy()
# void onChangeValue(final float pSecondsElapsed, final IEntity pEntity, final float pRotation) 
 
}
class org.andengine.entity.modifier.RotationModifier {
 + RotationModifier deepCopy()
# void onSetInitialValue(final IEntity pEntity, final float pRotation) 
# void onSetValue(final IEntity pEntity, final float pPercentageDone, final float pRotation) 
 
}
class org.andengine.entity.modifier.ScaleAtModifier {
 + ScaleAtModifier deepCopy()
# void onManagedInitialize(final IEntity pEntity) 
	- final float mScaleCenterX;
	- final float mScaleCenterY;
 
}
class org.andengine.entity.modifier.ScaleModifier {
 + ScaleModifier deepCopy()
# void onSetInitialValues(final IEntity pEntity, final float pScaleA, final float pScaleB) 
# void onSetValues(final IEntity pEntity, final float pPercentageDone, final float pScaleA, final float pScaleB) 
 
}
class org.andengine.entity.modifier.SequenceEntityModifier {
 + SequenceEntityModifier deepCopy() 
 
}
class org.andengine.entity.modifier.SkewModifier {
 + SkewModifier deepCopy()
# void onSetInitialValues(final IEntity pEntity, final float pSkewX, final float pSkewY) 
# void onSetValues(final IEntity pEntity, final float pPercentageDone, final float pSkewX, final float pSkewY) 
 
}
class org.andengine.entity.modifier.SkewXModifier {
 + SkewXModifier deepCopy()
# void onSetInitialValue(final IEntity pEntity, final float pSkewX) 
# void onSetValue(final IEntity pEntity, final float pPercentageDone, final float pSkewX) 
 
}
class org.andengine.entity.modifier.SkewYModifier {
 + SkewYModifier deepCopy()
# void onSetInitialValue(final IEntity pEntity, final float pSkewY) 
# void onSetValue(final IEntity pEntity, final float pPercentageDone, final float pSkewY) 
 
}
class org.andengine.entity.particle.BatchedPseudoSpriteParticleSystem {
 + Entity create(final float pX, final float pY) 
# void onManagedDraw(final GLState pGLState, final Camera pCamera) 
	# final ITextureRegion mTextureRegion;
	# final SpriteBatch mSpriteBatch;
 
}
class org.andengine.entity.particle.BatchedSpriteParticleSystem {
 + UncoloredSprite create(final float pX, final float pY) 
# void onManagedDraw(final GLState pGLState, final Camera pCamera) 
	# final SpriteBatch mSpriteBatch;
 
}
class org.andengine.entity.particle.BlendFunctionParticleSystem {
 + boolean isBlendingEnabled() 
+ void setBlendingEnabled(final boolean pBlendingEnabled) 
+ int getBlendFunctionSource() 
+ void setBlendFunctionSource(final int pBlendFunctionSource) 
+ int getBlendFunctionDestination() 
+ void setBlendFunctionDestination(final int pBlendFunctionDestination) 
+ void setBlendFunction(final int pBlendFunctionSource, final int pBlendFunctionDestination) 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
 
}
class org.andengine.entity.particle.Particle {
 + T getEntity() 
+ void setEntity(final T pEntity) 
+ float getLifeTime() 
+ float getExpireTime() 
+ void setExpireTime(final float pExpireTime) 
+ boolean isExpired() 
+ void setExpired(final boolean pExpired) 
+ PhysicsHandler getPhysicsHandler() 
# void onUpdate(final float pSecondsElapsed) 
+ void onDraw(final GLState pGLState, final Camera pCamera) 
+ void reset() 
	- float mLifeTime;
	- T mEntity;
 
}
class org.andengine.entity.particle.ParticleSystem {
 + boolean isParticlesSpawnEnabled() 
+ void setParticlesSpawnEnabled(final boolean pParticlesSpawnEnabled) 
+ IEntityFactory<T> getParticleFactory() 
+ IParticleEmitter getParticleEmitter() 
+ void reset() 
# void onManagedDraw(final GLState pGLState, final Camera pCamera) 
# void onManagedUpdate(final float pSecondsElapsed) 
# void moveParticleToEnd(final int pIndex) 
+ void addParticleModifier(final IParticleModifier<T> pParticleModifier) 
+ void removeParticleModifier(final IParticleModifier<T> pParticleModifier) 
+ void addParticleInitializer(final IParticleInitializer<T> pParticleInitializer) 
+ void removeParticleInitializer(final IParticleInitializer<T> pParticleInitializer) 
- void spawnParticles(final float pSecondsElapsed) 
- void spawnParticle() 
# float determineCurrentRate() 
	# final IEntityFactory<T> mEntityFactory;
	# final IParticleEmitter mParticleEmitter;
	# final Particle<T>[] mParticles;
	- final float mRateMinimum;
	- final float mRateMaximum;
	# final int mParticlesMaximum;
	# int mParticlesAlive;
	- float mParticlesDueToSpawn;
 
}
class org.andengine.entity.particle.SpriteParticleSystem {
 + Sprite create(final float pX, final float pY) 
 
}
class org.andengine.entity.particle.emitter.CircleOutlineParticleEmitter {
 + void getPositionOffset(final float[] pOffset) 
 
}
class org.andengine.entity.particle.emitter.CircleParticleEmitter {
 + void getPositionOffset(final float[] pOffset) 
 
}
class org.andengine.entity.particle.emitter.PointParticleEmitter {
 + void getPositionOffset(final float[] pOffset) 
 
}
class org.andengine.entity.particle.emitter.RectangleOutlineParticleEmitter {
 + void getPositionOffset(final float[] pOffset) 
 
}
class org.andengine.entity.particle.emitter.RectangleParticleEmitter {
 + void getPositionOffset(final float[] pOffset) 
 
}
class org.andengine.entity.particle.initializer.AccelerationParticleInitializer {
 + float getMinAccelerationX() 
+ float getMaxAccelerationX() 
+ float getMinAccelerationY() 
+ float getMaxAccelerationY() 
+ void setAccelerationX(final float pAccelerationX) 
+ void setAccelerationY(final float pAccelerationY) 
+ void setAccelerationX(final float pMinAccelerationX, final float pMaxAccelerationX) 
+ void setAccelerationY(final float pMinAccelerationY, final float pMaxAccelerationY) 
+ void setAcceleration(final float pMinAccelerationX, final float pMaxAccelerationX, final float pMinAccelerationY, final float pMaxAccelerationY) 
+ void onInitializeParticle(final Particle<T> pParticle, final float pAccelerationX, final float pAccelerationY) 
 
}
class org.andengine.entity.particle.initializer.AlphaParticleInitializer {
 # void onInitializeParticle(final Particle<T> pParticle, final float pAlpha) 
 
}
class org.andengine.entity.particle.initializer.BlendFunctionParticleInitializer {
 + void onInitializeParticle(final Particle<T> pParticle) 
	# int mBlendFunctionSource;
	# int mBlendFunctionDestination;
 
}
class org.andengine.entity.particle.initializer.ColorParticleInitializer {
 # void onInitializeParticle(final Particle<T> pParticle, final float pRed, final float pGreen, final float pBlue) 
 
}
class org.andengine.entity.particle.initializer.GravityParticleInitializer {
  
}
class org.andengine.entity.particle.initializer.RotationParticleInitializer {
 + float getMinRotation() 
+ float getMaxRotation() 
+ void setRotation(final float pRotation) 
+ void setRotation(final float pMinRotation, final float pMaxRotation) 
+ void onInitializeParticle(final Particle<T> pParticle, final float pRotation) 
 
}
class org.andengine.entity.particle.initializer.ScaleParticleInitializer {
 # void onInitializeParticle(final Particle<T> pParticle, final float pScale) 
 
}
class org.andengine.entity.particle.initializer.VelocityParticleInitializer {
 + float getMinVelocityX() 
+ float getMaxVelocityX() 
+ float getMinVelocityY() 
+ float getMaxVelocityY() 
+ void setVelocityX(final float pVelocityX) 
+ void setVelocityY(final float pVelocityY) 
+ void setVelocityX(final float pMinVelocityX, final float pMaxVelocityX) 
+ void setVelocityY(final float pMinVelocityY, final float pMaxVelocityY) 
+ void setVelocity(final float pMinVelocityX, final float pMaxVelocityX, final float pMinVelocityY, final float pMaxVelocityY) 
+ void onInitializeParticle(final Particle<T> pParticle, final float pVelocityX, final float pVelocityY) 
 
}
class org.andengine.entity.particle.modifier.AlphaParticleModifier {
 # void onSetInitialValue(final Particle<T> pParticle, final float pAlpha) 
# void onSetValue(final Particle<T> pParticle, final float pPercentageDone, final float pAlpha) 
 
}
class org.andengine.entity.particle.modifier.ColorParticleModifier {
 # void onSetInitialValues(final Particle<T> pParticle, final float pRed, final float pGreen, final float pBlue) 
# void onSetValues(final Particle<T> pParticle, final float pPercentageDone, final float pRed, final float pGreen, final float pBlue) 
 
}
class org.andengine.entity.particle.modifier.ExpireParticleInitializer {
 + float getMinLifeTime() 
+ float getMaxLifeTime() 
+ void setLifeTime(final float pLifeTime) 
+ void setLifeTime(final float pMinLifeTime, final float pMaxLifeTime) 
+ void onInitializeParticle(final Particle<T> pParticle) 
	- float mMinLifeTime;
	- float mMaxLifeTime;
 
}
class org.andengine.entity.particle.modifier.OffCameraExpireParticleModifier {
 + Camera getCamera() 
+ void onInitializeParticle(final Particle<T> pParticle) 
+ void onUpdateParticle(final Particle<T> pParticle) 
	- final Camera mCamera;
 
}
class org.andengine.entity.particle.modifier.RotationParticleModifier {
 # void onSetInitialValue(final Particle<T> pParticle, final float pRotation) 
# void onSetValue(final Particle<T> pParticle, final float pPercentageDone, final float pRotation) 
 
}
class org.andengine.entity.particle.modifier.ScaleParticleModifier {
 # void onSetInitialValues(final Particle<T> pParticle, final float pScaleX, final float pScaleY) 
# void onSetValues(final Particle<T> pParticle, final float pPercentageDone, final float pScaleX, final float pScaleY) 
 
}
class org.andengine.entity.primitive.Line {
 + float getX() 
+ float getY() 
+ float getX1() 
+ float getY1() 
+ float getX2() 
+ float getY2() 
+ float getLineWidth() 
+ void setLineWidth(final float pLineWidth) 
+ void setX(final float pX) 
+ void setY(final float pY) 
+ void setPosition(final float pX, final float pY) 
+ void setPosition(final float pX1, final float pY1, final float pX2, final float pY2) 
+ ILineVertexBufferObject getVertexBufferObject() 
+ boolean isCulled(final Camera pCamera) 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
# void onUpdateColor() 
# void onUpdateVertices() 
+ float[] getSceneCenterCoordinates() 
+ float[] getSceneCenterCoordinates(final float[] pReuse) 
+ boolean contains(final float pX, final float pY) 
+ boolean collidesWith(final IShape pOtherShape) 
	# float mX2;
	# float mY2;
	# float mLineWidth;
	# final ILineVertexBufferObject mLineVertexBufferObject;
 
}
class org.andengine.entity.primitive.Mesh {
 + float[] getBufferData() 
+ void setVertexCountToDraw(final int pVertexCountToDraw) 
+ void setDrawMode(final DrawMode pDrawMode) 
+ IMeshVertexBufferObject getVertexBufferObject() 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
# void onUpdateColor() 
# void onUpdateVertices() 
+ boolean contains(final float pX, final float pY) 
+ boolean collidesWith(final IShape pOtherShape) 
	# final IMeshVertexBufferObject mMeshVertexBufferObject;
	- int mVertexCountToDraw;
	- int mDrawMode;
 
}
class org.andengine.entity.primitive.Rectangle {
 + IRectangleVertexBufferObject getVertexBufferObject() 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
# void onUpdateColor() 
# void onUpdateVertices() 
	# final IRectangleVertexBufferObject mRectangleVertexBufferObject;
 
}
class org.andengine.entity.primitive.vbo.HighPerformanceLineVertexBufferObject {
 + void onUpdateColor(final Line pLine) 
+ void onUpdateVertices(final Line pLine) 
 
}
class org.andengine.entity.primitive.vbo.HighPerformanceMeshVertexBufferObject {
 + void onUpdateColor(final Mesh pMesh) 
+ void onUpdateVertices(final Mesh pMesh) 
	- final int mVertexCount;
 
}
class org.andengine.entity.primitive.vbo.HighPerformanceRectangleVertexBufferObject {
 + void onUpdateColor(final Rectangle pRectangle) 
+ void onUpdateVertices(final Rectangle pRectangle) 
 
}
class org.andengine.entity.primitive.vbo.LowMemoryLineVertexBufferObject {
 + void onUpdateColor(final Line pLine) 
+ void onUpdateVertices(final Line pLine) 
 
}
class org.andengine.entity.primitive.vbo.LowMemoryRectangleVertexBufferObject {
 + void onUpdateColor(final Rectangle pRectangle) 
+ void onUpdateVertices(final Rectangle pRectangle) 
 
}
class org.andengine.entity.scene.CameraScene {
 + Camera getCamera() 
+ void setCamera(final Camera pCamera) 
+ boolean onSceneTouchEvent(final TouchEvent pSceneTouchEvent) 
# boolean onChildSceneTouchEvent(final TouchEvent pSceneTouchEvent) 
# void onApplyMatrix(final GLState pGLState, final Camera pCamera) 
+ void centerShapeInCamera(final IAreaShape pAreaShape) 
+ void centerShapeInCameraHorizontally(final IAreaShape pAreaShape) 
+ void centerShapeInCameraVertically(final IAreaShape pAreaShape) 
	# Camera mCamera;
 
}
class org.andengine.entity.scene.ITouchArea {
 + boolean contains(final float pX, final float pY)
+ boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY)
 
}.ITouchAreaMatcher
class org.andengine.entity.scene.Scene {
 + float getSecondsElapsedTotal() 
+ IBackground getBackground() 
+ void setBackground(final IBackground pBackground) 
+ boolean isBackgroundEnabled() 
+ void setBackgroundEnabled(final boolean pEnabled) 
+ void setOnSceneTouchListener(final IOnSceneTouchListener pOnSceneTouchListener) 
+ IOnSceneTouchListener getOnSceneTouchListener() 
+ boolean hasOnSceneTouchListener() 
+ void setOnAreaTouchListener(final IOnAreaTouchListener pOnAreaTouchListener) 
+ IOnAreaTouchListener getOnAreaTouchListener() 
+ boolean hasOnAreaTouchListener() 
- void setParentScene(final Scene pParentScene) 
+ boolean hasChildScene() 
+ Scene getChildScene() 
+ void setChildSceneModal(final Scene pChildScene) 
+ void setChildScene(final Scene pChildScene) 
+ void setChildScene(final Scene pChildScene, final boolean pModalDraw, final boolean pModalUpdate, final boolean pModalTouch) 
+ void clearChildScene() 
+ void setOnAreaTouchTraversalBackToFront() 
+ void setOnAreaTouchTraversalFrontToBack() 
+ boolean isTouchAreaBindingOnActionDownEnabled() 
+ boolean isTouchAreaBindingOnActionMoveEnabled() 
+ void setTouchAreaBindingOnActionDownEnabled(final boolean pTouchAreaBindingOnActionDownEnabled) 
+ void setTouchAreaBindingOnActionMoveEnabled(final boolean pTouchAreaBindingOnActionMoveEnabled) 
+ boolean isOnSceneTouchListenerBindingOnActionDownEnabled() 
+ void setOnSceneTouchListenerBindingOnActionDownEnabled(final boolean pOnSceneTouchListenerBindingOnActionDownEnabled) 
# void onManagedDraw(final GLState pGLState, final Camera pCamera) 
# void onApplyMatrix(final GLState pGLState, final Camera pCamera) 
# void onManagedUpdate(final float pSecondsElapsed) 
+ boolean onSceneTouchEvent(final TouchEvent pSceneTouchEvent) 
- Boolean onAreaTouchEvent(final TouchEvent pSceneTouchEvent, final float sceneTouchEventX, final float sceneTouchEventY, final ITouchArea touchArea) 
# boolean onChildSceneTouchEvent(final TouchEvent pSceneTouchEvent) 
+ void reset() 
+ void setParent(final IEntity pEntity) 
+ void postRunnable(final Runnable pRunnable) 
+ void registerTouchArea(final ITouchArea pTouchArea) 
+ boolean unregisterTouchArea(final ITouchArea pTouchArea) 
+ boolean unregisterTouchAreas(final ITouchAreaMatcher pTouchAreaMatcher) 
+ void clearTouchAreas() 
+ SmartList<ITouchArea> getTouchAreas() 
+ void back() 
	- float mSecondsElapsedTotal;
	# Scene mParentScene;
	# Scene mChildScene;
	- boolean mChildSceneModalDraw;
	- boolean mChildSceneModalUpdate;
	- boolean mChildSceneModalTouch;
	- IOnSceneTouchListener mOnSceneTouchListener;
	- IOnAreaTouchListener mOnAreaTouchListener;
 
}
class org.andengine.entity.scene.background.AutoParallaxBackground {
 + void setParallaxChangePerSecond(final float pParallaxChangePerSecond) 
+ void onUpdate(final float pSecondsElapsed) 
	- float mParallaxChangePerSecond;
 
}
class org.andengine.entity.scene.background.Background {
 + void setColor(final float pRed, final float pGreen, final float pBlue) 
+ void setColor(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void setColor(final Color pColor) 
+ boolean isColorEnabled() 
+ void setColorEnabled(final boolean pColorEnabled) 
+ void registerBackgroundModifier(final IModifier<IBackground> pBackgroundModifier) 
+ boolean unregisterBackgroundModifier(final IModifier<IBackground> pBackgroundModifier) 
+ void clearBackgroundModifiers() 
+ void onUpdate(final float pSecondsElapsed) 
+ void onDraw(final GLState pGLState, final Camera pCamera) 
+ void reset() 
- void allocateBackgroundModifiers() 
 
}
class org.andengine.entity.scene.background.EntityBackground {
 + void onDraw(final GLState pGLState, final Camera pCamera) 
	# IEntity mEntity;
 
}
class org.andengine.entity.scene.background.ParallaxBackground {
 + void setParallaxValue(final float pParallaxValue) 
+ void onDraw(final GLState pGLState, final Camera pCamera) 
+ void attachParallaxEntity(final ParallaxEntity pParallaxEntity) 
+ boolean detachParallaxEntity(final ParallaxEntity pParallaxEntity) 
+ void onDraw(final GLState pGLState, final Camera pCamera, final float pParallaxValue) 
	- int mParallaxEntityCount;
	# float mParallaxValue;
~		final float mParallaxFactor;
~		final IAreaShape mAreaShape;
 
}
class org.andengine.entity.scene.background.RepeatingSpriteBackground {
 + BitmapTextureAtlas getBitmapTextureAtlas() 
- Sprite loadSprite(final float pCameraWidth, final float pCameraHeight, final TextureManager pTextureManager, final IBitmapTextureAtlasSource pBitmapTextureAtlasSource, final VertexBufferObjectManager pVertexBufferObjectManager) 
	- BitmapTextureAtlas mBitmapTextureAtlas;
	- final float mScale;
 
}
class org.andengine.entity.scene.background.SpriteBackground {
 + Sprite getSprite() 
 
}
class org.andengine.entity.scene.background.modifier.ColorBackgroundModifier {
 + ColorBackgroundModifier deepCopy()
# void onSetInitialValues(final IBackground pBackground, final float pRed, final float pGreen, final float pBlue) 
# void onSetValues(final IBackground pBackground, final float pPerctentageDone, final float pRed, final float pGreen, final float pBlue) 
 
}
class org.andengine.entity.scene.background.modifier.LoopBackgroundModifier {
 + LoopBackgroundModifier deepCopy() 
 
}
class org.andengine.entity.scene.background.modifier.ParallelBackgroundModifier {
 + ParallelBackgroundModifier deepCopy() 
 
}
class org.andengine.entity.scene.background.modifier.SequenceBackgroundModifier {
 + SequenceBackgroundModifier deepCopy() 
 
}
class org.andengine.entity.scene.menu.MenuScene {
 + IOnMenuItemClickListener getOnMenuItemClickListener() 
+ void setOnMenuItemClickListener(final IOnMenuItemClickListener pOnMenuItemClickListener) 
+ int getMenuItemCount() 
+ void addMenuItem(final IMenuItem pMenuItem) 
+ void clearMenuItems() 
+ MenuScene getChildScene() 
+ void setChildScene(final Scene pChildScene, final boolean pModalDraw, final boolean pModalUpdate, final boolean pModalTouch) 
+ void clearChildScene() 
+ void setMenuAnimator(final IMenuAnimator pMenuAnimator) 
+ boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final ITouchArea pTouchArea, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
+ boolean onSceneTouchEvent(final Scene pScene, final TouchEvent pSceneTouchEvent) 
+ void back() 
+ void reset() 
+ void closeMenuScene() 
+ void buildAnimations() 
+ void prepareAnimations() 
+ boolean onMenuItemClicked(final MenuScene pMenuScene, final IMenuItem pMenuItem, final float pMenuItemLocalX, final float pMenuItemLocalY)
	- IOnMenuItemClickListener mOnMenuItemClickListener;
	- IMenuItem mSelectedMenuItem;
 
}
class org.andengine.entity.scene.menu.animator.AlphaMenuAnimator {
 + void buildAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight) 
+ void prepareAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight) 
 
}
class org.andengine.entity.scene.menu.animator.DirectMenuAnimator {
 + void buildAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight) 
+ void prepareAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight) 
 
}
class org.andengine.entity.scene.menu.animator.SlideMenuAnimator {
 + void buildAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight) 
+ void prepareAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight) 
 
}
class org.andengine.entity.scene.menu.item.AnimatedSpriteMenuItem {
 + int getID() 
+ void onSelected() 
+ void onUnselected() 
	- final int mID;
 
}
class org.andengine.entity.scene.menu.item.SpriteMenuItem {
 + int getID() 
+ void onSelected() 
+ void onUnselected() 
	- final int mID;
 
}
class org.andengine.entity.scene.menu.item.TextMenuItem {
 + int getID() 
+ void onSelected() 
+ void onUnselected() 
	- final int mID;
 
}
class org.andengine.entity.scene.menu.item.decorator.ColorMenuItemDecorator {
 + void onMenuItemSelected(final IMenuItem pMenuItem) 
+ void onMenuItemUnselected(final IMenuItem pMenuItem) 
+ void onMenuItemReset(final IMenuItem pMenuItem) 
	- final Color mSelectedColor;
	- final Color mUnselectedColor;
 
}
class org.andengine.entity.scene.menu.item.decorator.ScaleMenuItemDecorator {
 + void onMenuItemSelected(final IMenuItem pMenuItem) 
+ void onMenuItemUnselected(final IMenuItem pMenuItem) 
+ void onMenuItemReset(final IMenuItem pMenuItem) 
	- final float mSelectedScale;
	- final float mUnselectedScale;
 
}
class org.andengine.entity.sprite.AnimatedSprite {
 + boolean isAnimationRunning() 
# void onManagedUpdate(final float pSecondsElapsed) 
+ void stopAnimation() 
+ void stopAnimation(final int pTileIndex) 
+ void animate(final long pFrameDurationEach) 
+ void animate(final long pFrameDurationEach, final IAnimationListener pAnimationListener) 
+ void animate(final long pFrameDurationEach, final boolean pLoop) 
+ void animate(final long pFrameDurationEach, final boolean pLoop, final IAnimationListener pAnimationListener) 
+ void animate(final long pFrameDurationEach, final int pLoopCount) 
+ void animate(final long pFrameDurationEach, final int pLoopCount, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations) 
+ void animate(final long[] pFrameDurations, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final boolean pLoop) 
+ void animate(final long[] pFrameDurations, final boolean pLoop, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final int pLoopCount) 
+ void animate(final long[] pFrameDurations, final int pLoopCount, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final int pFirstTileIndex, final int pLastTileIndex, final boolean pLoop) 
+ void animate(final long[] pFrameDurations, final int pFirstTileIndex, final int pLastTileIndex, final boolean pLoop, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final int pFirstTileIndex, final int pLastTileIndex, final int pLoopCount) 
+ void animate(final long[] pFrameDurations, final int pFirstTileIndex, final int pLastTileIndex, final int pLoopCount, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final int[] pFrames) 
+ void animate(final long[] pFrameDurations, final int[] pFrames, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final int[] pFrames, final boolean pLoop) 
+ void animate(final long[] pFrameDurations, final int[] pFrames, final boolean pLoop, final IAnimationListener pAnimationListener) 
+ void animate(final long[] pFrameDurations, final int[] pFrames, final int pLoopCount) 
+ void animate(final long[] pFrameDurations, final int[] pFrames, final int pLoopCount, final IAnimationListener pAnimationListener) 
+ void animate(final IAnimationData pAnimationData) 
+ void animate(final IAnimationData pAnimationData, final IAnimationListener pAnimationListener) 
- void initAnimation(final IAnimationListener pAnimationListener) 
+ void onAnimationStarted(final AnimatedSprite pAnimatedSprite, final int pInitialLoopCount)
+ void onAnimationFrameChanged(final AnimatedSprite pAnimatedSprite, final int pOldFrameIndex, final int pNewFrameIndex)
+ void onAnimationLoopFinished(final AnimatedSprite pAnimatedSprite, final int pRemainingLoopCount, final int pInitialLoopCount)
	- boolean mAnimationRunning;
	- boolean mAnimationStartedFired;
	- int mCurrentFrameIndex;
	- long mAnimationProgress;
	- int mRemainingLoopCount;
	- IAnimationListener mAnimationListener;
 
}
class org.andengine.entity.sprite.AnimationData {
 + IAnimationData deepCopy() 
+ int[] getFrames() 
+ long[] getFrameDurations() 
+ int getLoopCount() 
+ int getFrameCount() 
+ int getFirstFrameIndex() 
+ long getAnimationDuration() 
+ int calculateCurrentFrameIndex(final long pAnimationProgress) 
+ void set(final long pFrameDurationEach, final int pFrameCount) 
+ void set(final long pFrameDurationEach, final int pFrameCount, final boolean pLoop) 
+ void set(final long pFrameDurationEach, final int pFrameCount, final int pLoopCount) 
+ void set(final long[] pFrameDurations) 
+ void set(final long[] pFrameDurations, final boolean pLoop) 
+ void set(final long[] pFrameDurations, final int pLoopCount) 
+ void set(final long[] pFrameDurations, final int pFirstFrameIndex, final int pLastFrameIndex) 
+ void set(final long[] pFrameDurations, final int pFirstFrameIndex, final int pLastFrameIndex, final boolean pLoop) 
+ void set(final long[] pFrameDurations, final int pFirstFrameIndex, final int pLastFrameIndex, final int pLoopCount) 
+ void set(final long[] pFrameDurations, final int[] pFrames) 
+ void set(final long[] pFrameDurations, final int[] pFrames, final boolean pLoop) 
+ void set(final long[] pFrameDurations, final int[] pFrames, final int pLoopCount) 
+ void set(final IAnimationData pAnimationData) 
- void set(final long[] pFrameDurations, final int pFrameCount, final int[] pFrames, final int pFirstFrameIndex, final int pLoopCount) 
- {static} long[] fillFrameDurations(final long pFrameDurationEach, final int pFrameCount) 
	- int mFrameCount;
	- int[] mFrames;
	- long[] mFrameDurations;
	- int mFirstFrameIndex;
	- int mLoopCount;
	- long[] mFrameEndsInNanoseconds;
	- long mAnimationDuration;
 
}
class org.andengine.entity.sprite.ButtonSprite {
 + boolean isEnabled() 
+ void setEnabled(final boolean pEnabled) 
+ boolean isPressed() 
+ State getState() 
+ void setOnClickListener(final OnClickListener pOnClickListener) 
+ boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY) 
+ boolean contains(final float pX, final float pY) 
- void changeState(final State pState) 
+ void onClick(final ButtonSprite pButtonSprite, final float pTouchAreaLocalX, final float pTouchAreaLocalY)
+ int getTiledTextureRegionIndex() 
	- final int mStateCount;
	- OnClickListener mOnClickListener;
	- State mState;
		- final int mTiledTextureRegionIndex;
 
}
class org.andengine.entity.sprite.DiamondSprite {
  
}
class org.andengine.entity.sprite.Sprite {
 + ITextureRegion getTextureRegion() 
+ boolean isFlippedHorizontal() 
+ void setFlippedHorizontal(final boolean pFlippedHorizontal) 
+ boolean isFlippedVertical() 
+ void setFlippedVertical(final boolean pFlippedVertical) 
+ void setFlipped(final boolean pFlippedHorizontal, final boolean pFlippedVertical) 
+ ISpriteVertexBufferObject getVertexBufferObject() 
+ void reset() 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
# void onUpdateVertices() 
# void onUpdateColor() 
# void onUpdateTextureCoordinates() 
	# final ITextureRegion mTextureRegion;
	# final ISpriteVertexBufferObject mSpriteVertexBufferObject;
	# boolean mFlippedVertical;
	# boolean mFlippedHorizontal;
 
}
class org.andengine.entity.sprite.TiledSprite {
 + ITextureRegion getTextureRegion() 
+ ITiledTextureRegion getTiledTextureRegion() 
+ ITiledSpriteVertexBufferObject getVertexBufferObject() 
# void draw(final GLState pGLState, final Camera pCamera) 
# void onUpdateColor() 
# void onUpdateVertices() 
# void onUpdateTextureCoordinates() 
+ int getCurrentTileIndex() 
+ void setCurrentTileIndex(final int pCurrentTileIndex) 
+ int getTileCount() 
	- int mCurrentTileIndex;
	- final ITiledSpriteVertexBufferObject mTiledSpriteVertexBufferObject;
 
}
class org.andengine.entity.sprite.UncoloredSprite {
 # void onUpdateColor() 
 
}
class org.andengine.entity.sprite.UniformColorSprite {
 # void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
 
}
class org.andengine.entity.sprite.batch.SpriteBatch {
 + int getIndex() 
+ ITexture getTexture() 
+ void setTexture(final ITexture pTexture) 
+ void setIndex(final int pIndex) 
+ ISpriteBatchVertexBufferObject getVertexBufferObject() 
+ boolean collidesWith(final IShape pOtherShape) 
+ boolean contains(final float pX, final float pY) 
# void onUpdateVertices() 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
+ void reset() 
+ void dispose() 
# void begin() 
# void end() 
+ void draw(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pColorABGRPackedInt) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pColorABGRPackedInt) 
+ void draw(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pScaleX, final float pScaleY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pScaleX, final float pScaleY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pScaleX, final float pScaleY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pScaleX, final float pScaleY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX4, final float pY4, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX4, final float pY4, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final Sprite pSprite) 
+ void drawWithoutChecks(final Sprite pSprite) 
+ void draw(final Sprite pSprite, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final Sprite pSprite, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final Sprite pSprite, final float pColorABGRPackedInt) 
+ void drawWithoutChecks(final Sprite pSprite, final float pColorABGRPackedInt) 
+ void draw(final ITextureRegion pTextureRegion, final IEntity pEntity, final float pWidth, final float pHeight) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final IEntity pEntity, final float pWidth, final float pHeight) 
+ void draw(final ITextureRegion pTextureRegion, final IEntity pEntity, final float pWidth, final float pHeight, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final IEntity pEntity, final float pWidth, final float pHeight, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void draw(final ITextureRegion pTextureRegion, final IEntity pEntity, final float pWidth, final float pHeight, final float pColorABGRPackedInt) 
+ void drawWithoutChecks(final ITextureRegion pTextureRegion, final IEntity pEntity, final float pWidth, final float pHeight, final float pColorABGRPackedInt) 
+ void submit() 
# void onSubmit() 
- void assertCapacity(final int pIndex) 
- void assertCapacity() 
# void assertTexture(final ITextureRegion pTextureRegion) 
# void add(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
# void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pColorABGRPackedInt) 
# void add(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pScaleX, final float pScaleY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
# void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pScaleX, final float pScaleY, final float pColorABGRPackedInt) 
# void add(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pScaleX, final float pScaleY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
# void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRotation, final float pScaleX, final float pScaleY, final float pColorABGRPackedInt) 
# void add(final ITextureRegion pTextureRegion, final float pWidth, final float pHeight, final Transformation pTransformation, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
# void addWithPackedColor(final ITextureRegion pTextureRegion, final float pWidth, final float pHeight, final Transformation pTransformation, final float pColorABGRPackedInt) 
# void add(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
# void add(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pColorABGRPackedInt) 
# void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX, final float pY, final float pWidth, final float pHeight, final float pColorABGRPackedInt) 
- void addInner(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
- void addInner(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX4, final float pY4, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
	# ITexture mTexture;
	# final int mCapacity;
	# final ISpriteBatchVertexBufferObject mSpriteBatchVertexBufferObject;
	# int mIndex;
	# int mVertices;
 
}
class org.andengine.entity.sprite.batch.SpriteGroup {
 + void attachChild(final IEntity pEntity) 
+ void attachChild(final Sprite pSprite) 
+ void attachChildren(final ArrayList<? extends Sprite> pSprites) 
# boolean onUpdateSpriteBatch() 
- void assertCapacity() 
 
}
class org.andengine.entity.sprite.batch.vbo.HighPerformanceSpriteBatchVertexBufferObject {
 + int getBufferDataOffset() 
+ void setBufferDataOffset(final int pBufferDataOffset) 
+ void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX4, final float pY4, final float pColorABGRPackedInt) 
+ void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pColorABGRPackedInt) 
	# int mBufferDataOffset;
 
}
class org.andengine.entity.sprite.batch.vbo.LowMemorySpriteBatchVertexBufferObject {
 + int getBufferDataOffset() 
+ void setBufferDataOffset(final int pBufferDataOffset) 
+ void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX4, final float pY4, final float pColorABGRPackedInt) 
+ void addWithPackedColor(final ITextureRegion pTextureRegion, final float pX1, final float pY1, final float pX2, final float pY2, final float pColorABGRPackedInt) 
	# int mBufferDataOffset;
 
}
class org.andengine.entity.sprite.vbo.HighPerformanceDiamondSpriteVertexBufferObject {
 + void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.HighPerformanceSpriteVertexBufferObject {
 + void onUpdateColor(final Sprite pSprite) 
+ void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.HighPerformanceTiledSpriteVertexBufferObject {
 + void onUpdateColor(final TiledSprite pTiledSprite) 
+ void onUpdateVertices(final TiledSprite pTiledSprite) 
+ void onUpdateTextureCoordinates(final TiledSprite pTiledSprite) 
 
}
class org.andengine.entity.sprite.vbo.HighPerformanceUncoloredSpriteVertexBufferObject {
 + void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.HighPerformanceUniformColorSpriteVertexBufferObject {
 + void onUpdateColor(final Sprite pSprite) 
+ void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.LowMemoryDiamondSpriteVertexBufferObject {
 + void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.LowMemorySpriteVertexBufferObject {
 + void onUpdateColor(final Sprite pSprite) 
+ void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.LowMemoryTiledSpriteVertexBufferObject {
 + void onUpdateColor(final TiledSprite pTiledSprite) 
+ void onUpdateVertices(final TiledSprite pTiledSprite) 
+ void onUpdateTextureCoordinates(final TiledSprite pTiledSprite) 
 
}
class org.andengine.entity.sprite.vbo.LowMemoryUncoloredSpriteVertexBufferObject {
 + void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.sprite.vbo.LowMemoryUniformColorSpriteVertexBufferObject {
 + void onUpdateColor(final Sprite pSprite) 
+ void onUpdateVertices(final Sprite pSprite) 
+ void onUpdateTextureCoordinates(final Sprite pSprite) 
 
}
class org.andengine.entity.text.Text {
 + IFont getFont() 
+ int getCharactersMaximum() 
+ CharSequence getText() 
+ void setText(final CharSequence pText) 
+ ArrayList<CharSequence> getLines() 
+ IFloatList getLineWidths() 
+ float getLineAlignmentWidth() 
+ float getLineWidthMaximum() 
+ float getLeading() 
+ void setLeading(final float pLeading) 
+ HorizontalAlign getHorizontalAlign() 
+ void setHorizontalAlign(final HorizontalAlign pHorizontalAlign) 
+ AutoWrap getAutoWrap() 
+ void setAutoWrap(final AutoWrap pAutoWrap) 
+ float getAutoWrapWidth() 
+ void setAutoWrapWidth(final float pAutoWrapWidth) 
+ TextOptions getTextOptions() 
+ void setTextOptions(final TextOptions pTextOptions) 
+ void setCharactersToDraw(final int pCharactersToDraw) 
+ ITextVertexBufferObject getVertexBufferObject() 
# void preDraw(final GLState pGLState, final Camera pCamera) 
# void draw(final GLState pGLState, final Camera pCamera) 
# void postDraw(final GLState pGLState, final Camera pCamera) 
# void onUpdateColor() 
# void onUpdateVertices() 
+ void invalidateText() 
	# final IFont mFont;
	# float mLineWidthMaximum;
	# float mLineAlignmentWidth;
	# TextOptions mTextOptions;
	# final int mCharactersMaximum;
	# int mCharactersToDraw;
	# int mVertexCountToDraw;
	# final int mVertexCount;
	# final ITextVertexBufferObject mTextVertexBufferObject;
	# CharSequence mText;
 
}
class org.andengine.entity.text.TextOptions {
 + AutoWrap getAutoWrap() 
+ void setAutoWrap(final AutoWrap pAutoWrap) 
+ float getAutoWrapWidth() 
+ void setAutoWrapWidth(final float pAutoWrapWidth) 
+ float getLeading() 
+ void setLeading(final float pLeading) 
+ HorizontalAlign getHorizontalAlign() 
+ void setHorizontalAlign(final HorizontalAlign pHorizontalAlign) 
 
}
class org.andengine.entity.text.TickerText {
 + TickerTextOptions getTextOptions() 
+ boolean isReverse() 
+ void setReverse(final boolean pReverse) 
+ float getCharactersPerSecond() 
+ void setCharactersPerSecond(final float pCharactersPerSecond) 
+ int getCharactersVisible() 
+ void setText(CharSequence pText) 
# void onManagedUpdate(final float pSecondsElapsed) 
# void draw(final GLState pGLState, final Camera pCamera) 
+ void reset() 
	- final TickerTextOptions mTickerTextOptions;
	- int mCharactersVisible;
	- float mSecondsElapsed;
	- float mDuration;
 
}
class org.andengine.entity.text.exception.OutOfCharactersException {
  
}
class org.andengine.entity.text.exception.TextException {
  
}
class org.andengine.entity.text.vbo.HighPerformanceTextVertexBufferObject {
 + void onUpdateColor(final Text pText) 
+ void onUpdateVertices(final Text pText) 
 
}
class org.andengine.entity.text.vbo.LowMemoryTextVertexBufferObject {
 + void onUpdateColor(final Text pText) 
+ void onUpdateVertices(final Text pText) 
 
}
class org.andengine.entity.util.FPSCounter {
 + float getFPS() 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	# float mSecondsElapsed;
	# int mFrames;
 
}
class org.andengine.entity.util.FPSLogger {
 # void onHandleAverageDurationElapsed(final float pFPS) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
# void onLogFPS() 
 
}
class org.andengine.entity.util.FrameCountCrasher {
 + void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	- int mFramesLeft;
	- final float[] mFrameLengths;
 
}
class org.andengine.entity.util.FrameCounter {
 + int getFrames() 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	- int mFrames;
 
}
class org.andengine.entity.util.ScreenCapture {
 # void onManagedDraw(final GLState pGLState, final Camera pCamera) 
# void onManagedUpdate(final float pSecondsElapsed) 
+ void reset() 
+ void onScreenGrabbed(final Bitmap pBitmap) 
+ void onScreenGrabFailed(final Exception pException) 
+ void capture(final int pCaptureWidth, final int pCaptureHeight, final String pFilePath, final IScreenCaptureCallback pScreenCaptureCallback) 
+ void capture(final int pCaptureX, final int pCaptureY, final int pCaptureWidth, final int pCaptureHeight, final String pFilePath, final IScreenCaptureCallback pScreencaptureCallback) 
- {static} void saveCapture(final Bitmap pBitmap, final String pFilePath) 
+ void onScreenCaptured(final String pFilePath)
	- String mFilePath;
	- IScreenCaptureCallback mScreenCaptureCallback;
 
}
class org.andengine.entity.util.ScreenGrabber {
 # void onManagedDraw(final GLState pGLState, final Camera pCamera) 
# void onManagedUpdate(final float pSecondsElapsed) 
+ void reset() 
+ void grab(final int pGrabWidth, final int pGrabHeight, final IScreenGrabberCallback pScreenGrabCallback) 
+ void grab(final int pGrabX, final int pGrabY, final int pGrabWidth, final int pGrabHeight, final IScreenGrabberCallback pScreenGrabCallback) 
- {static} Bitmap grab(final int pGrabX, final int pGrabY, final int pGrabWidth, final int pGrabHeight) 
+ void onScreenGrabbed(final Bitmap pBitmap)
	- int mGrabX;
	- int mGrabY;
	- int mGrabWidth;
	- int mGrabHeight;
	- IScreenGrabberCallback mScreenGrabCallback;
 
}
class org.andengine.input.sensor.BaseSensorData {
 + float[] getValues() 
+ void setValues(final float[] pValues) 
+ void setAccuracy(final int pAccuracy) 
+ int getAccuracy() 
+ String toString() 
	# final float[] mValues;
	# int mAccuracy;
	# int mDisplayRotation;
 
}
class org.andengine.input.sensor.acceleration.AccelerationData {
 + void swapAxis(final float[] pValues) 
+ float getX() 
+ float getY() 
+ float getZ() 
+ void setX(final float pX) 
+ void setY(final float pY) 
+ void setZ(final float pZ) 
+ void setValues(final float[] pValues) 
+ String toString() 
+ void swapAxis(final float[] pValues)
 
}
class org.andengine.input.sensor.acceleration.AccelerationSensorOptions {
 + SensorDelay getSensorDelay() 
~	final SensorDelay mSensorDelay;
 
}
class org.andengine.input.sensor.location.LocationSensorOptions {
 + void setEnabledOnly(final boolean pEnabledOnly) 
+ boolean isEnabledOnly() 
+ long getMinimumTriggerTime() 
+ void setMinimumTriggerTime(final long pMinimumTriggerTime) 
+ long getMinimumTriggerDistance() 
+ void setMinimumTriggerDistance(final long pMinimumTriggerDistance) 
 
}
class org.andengine.input.sensor.orientation.OrientationData {
 + float getRoll() 
+ float getPitch() 
+ float getYaw() 
+ void setValues(final float[] pValues) 
+ void setAccuracy(final int pAccuracy) 
+ void setAccelerationValues(final float[] pValues) 
+ void setMagneticFieldValues(final float[] pValues) 
- void updateOrientation() 
+ int getAccelerationAccuracy() 
+ void setAccelerationAccuracy(final int pAccelerationAccuracy) 
+ int getMagneticFieldAccuracy() 
+ void setMagneticFieldAccuracy(final int pMagneticFieldAccuracy) 
+ String toString() 
	- int mMagneticFieldAccuracy;
 
}
class org.andengine.input.sensor.orientation.OrientationSensorOptions {
 + SensorDelay getSensorDelay() 
~	final SensorDelay mSensorDelay;
 
}
class org.andengine.input.touch.TouchEvent {
 + {static} TouchEvent obtain(final float pX, final float pY, final int pAction, final int pPointerID, final MotionEvent pMotionEvent) 
- void set(final float pX, final float pY, final int pAction, final int pPointerID, final MotionEvent pMotionEvent) 
+ void recycle() 
+ {static} void recycle(final TouchEvent pTouchEvent) 
+ float getX() 
+ float getY() 
+ void set(final float pX, final float pY) 
+ void offset(final float pDeltaX, final float pDeltaY) 
+ int getPointerID() 
+ int getAction() 
+ boolean isActionDown() 
+ boolean isActionUp() 
+ boolean isActionMove() 
+ boolean isActionCancel() 
+ boolean isActionOutside() 
+ MotionEvent getMotionEvent() 
# TouchEvent onAllocatePoolItem() 
	# int mPointerID;
	# float mX;
	# float mY;
	# int mAction;
	# MotionEvent mMotionEvent;
 
}
class org.andengine.input.touch.controller.MultiTouch {
 + {static} boolean isSupported(final Context pContext) 
+ {static} boolean isSupportedDistinct(final Context pContext) 
 
}
class org.andengine.input.touch.controller.MultiTouchController {
 + void onHandleMotionEvent(final MotionEvent pMotionEvent) 
- void onHandleTouchMove(final MotionEvent pMotionEvent) 
- void onHandleTouchAction(final int pAction, final MotionEvent pMotionEvent) 
- {static} int getPointerIndex(final MotionEvent pMotionEvent) 
 
}
class org.andengine.input.touch.controller.SingleTouchController {
 + void onHandleMotionEvent(final MotionEvent pMotionEvent) 
 
}
class org.andengine.input.touch.detector.ClickDetector {
 + long getTriggerClickMaximumMilliseconds() 
+ void setTriggerClickMaximumMilliseconds(final long pClickMaximumMilliseconds) 
+ void reset() 
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
- void prepareClick(final TouchEvent pSceneTouchEvent) 
+ void onClick(final ClickDetector pClickDetector, final int pPointerID, final float pSceneX, final float pSceneY)
	- long mTriggerClickMaximumMilliseconds;
	- final IClickDetectorListener mClickDetectorListener;
 
}
class org.andengine.input.touch.detector.ContinuousHoldDetector {
 + void onTimePassed(final TimerHandler pTimerHandler) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
# void prepareHold(final TouchEvent pSceneTouchEvent) 
	- final TimerHandler mTimerHandler;
 
}
class org.andengine.input.touch.detector.HoldDetector {
 + long getTriggerHoldMinimumMilliseconds() 
+ void setTriggerHoldMinimumMilliseconds(final long pTriggerHoldMinimumMilliseconds) 
+ float getTriggerHoldMaximumDistance() 
+ void setTriggerHoldMaximumDistance(final float pTriggerHoldMaximumDistance) 
+ boolean isHolding() 
+ void reset() 
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
# void prepareHold(final TouchEvent pSceneTouchEvent) 
# void triggerOnHoldStarted() 
# void triggerOnHold(final long pHoldTimeMilliseconds) 
# void triggerOnHoldFinished(final long pHoldTimeMilliseconds) 
+ void onHoldStarted(final HoldDetector pHoldDetector, final int pPointerID, final float pHoldX, final float pHoldY)
	# long mTriggerHoldMinimumMilliseconds;
	# float mTriggerHoldMaximumDistance;
	# final IHoldDetectorListener mHoldDetectorListener;
	# float mDownX;
	# float mDownY;
	# float mHoldX;
	# float mHoldY;
	# boolean mMaximumDistanceExceeded;
	# boolean mTriggering;
 
}
class org.andengine.input.touch.detector.PinchZoomDetector {
 + boolean isZooming() 
+ void reset() 
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
- float getZoomFactor() 
- {static} float calculatePointerDistance(final MotionEvent pMotionEvent) 
- {static} boolean hasTwoOrMorePointers(final MotionEvent pMotionEvent) 
+ void onPinchZoomStarted(final PinchZoomDetector pPinchZoomDetector, final TouchEvent pSceneTouchEvent)
	- final IPinchZoomDetectorListener mPinchZoomDetectorListener;
	- float mInitialDistance;
	- float mCurrentDistance;
	- boolean mPinchZooming;
 
}
class org.andengine.input.touch.detector.ScrollDetector {
 + float getTriggerScrollMinimumDistance() 
+ void setTriggerScrollMinimumDistance(final float pTriggerScrollMinimumDistance) 
+ void reset() 
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
- void prepareScroll(final int pPointerID, final float pTouchX, final float pTouchY) 
- void triggerOnScrollStarted(final float pDistanceX, final float pDistanceY) 
- void triggerOnScroll(final float pDistanceX, final float pDistanceY) 
- void triggerOnScrollFinished(final float pDistanceX, final float pDistanceY) 
# float getX(final TouchEvent pTouchEvent) 
# float getY(final TouchEvent pTouchEvent) 
+ void onScrollStarted(final ScrollDetector pScollDetector, final int pPointerID, final float pDistanceX, final float pDistanceY)
	- float mTriggerScrollMinimumDistance;
	- final IScrollDetectorListener mScrollDetectorListener;
	- boolean mTriggering;
	- float mLastX;
	- float mLastY;
 
}
class org.andengine.input.touch.detector.SurfaceGestureDetectorAdapter {
 # boolean onDoubleTap() 
# boolean onSingleTap() 
# boolean onSwipeDown() 
# boolean onSwipeLeft() 
# boolean onSwipeRight() 
# boolean onSwipeUp() 
 
}
class org.andengine.input.touch.detector.SurfaceScrollDetector {
 # float getX(final TouchEvent pTouchEvent) 
# float getY(final TouchEvent pTouchEvent) 
 
}
class org.andengine.opengl.GLES20Fix {
 + {static} native void glVertexAttribPointer(final int pIndex, final int pSize, final int pType, final boolean pNormalized, final int pStride, final int pOffset)
+ {static} void glDrawElementsFix(final int pMode, final int pCount, final int pType, final int pOffset) 
	- {static} boolean NATIVE_LIB_LOADED;
	- {static} final boolean WORKAROUND_MISSING_GLES20_METHODS;
 
}
class org.andengine.opengl.exception.GLException {
 + int getError() 
- {static} String getErrorString(final int pError) 
	- final int mError;
 
}
class org.andengine.opengl.exception.GLFrameBufferException {
  
}
class org.andengine.opengl.exception.RenderTextureInitializationException {
  
}
class org.andengine.opengl.font.BitmapFont {
 + BitmapFontInfo getBitmapFontInfo() 
+ int getBase() 
+ int getScaleWidth() 
+ int getScaleHeight() 
+ int getBitmapFontPageCount() 
+ BitmapFontPage[] getBitmapFontPages() 
+ BitmapFontPage getBitmapFontPage(final int pIndex) 
+ boolean isPacked() 
+ ITexture getTexture() 
+ void load() 
+ void unload() 
+ float getLineHeight() 
+ Letter getLetter(final char pChar) 
+ void loadTextures() 
+ void unloadTextures() 
- void parseCharacters(final int pCharacterCount, final BufferedReader pBufferedReader) 
- void parseKernings(final int pKerningsCount, final BufferedReader pBufferedReader) 
- {static} boolean getBooleanAttribute(final String[] pData, final int pPosition, final String pAttribute) 
- {static} char getCharAttribute(final String[] pData, final int pPosition, final String pAttribute) 
- {static} int getIntAttribute(final String[] pData, final int pPosition, final String pAttribute) 
- {static} String getStringAttribute(final String[] pData, final int pPosition, final String pAttribute) 
- {static} String getAttribute(final String[] pData, final int pPosition, final String pAttribute) 
+ int getTextureOffsetX() 
+ int getTextureOffsetY() 
+ String getFace() 
+ int getSize() 
+ boolean isBold() 
+ boolean isItalic() 
+ String getCharset() 
+ int getUnicode() 
+ int getStretchHeight() 
+ boolean isSmooth() 
+ boolean isAntiAliased() 
+ int getPaddingLeft() 
+ int getPaddingTop() 
+ int getPaddingRight() 
+ int getPaddingBottom() 
+ int getSpacingX() 
+ int getSpacingY() 
+ int getID() 
	- final TextureManager mTextureManager;
	- final BitmapTextureFormat mBitmapTextureFormat;
	- final TextureOptions mTextureOptions;
	- final BitmapFontInfo mBitmapFontInfo;
	- final BitmapFontPage[] mBitmapFontPages;
	- final int mLineHeight;
	- final int mBase;
	- final int mScaleWidth;
	- final int mScaleHeight;
	- final int mBitmapFontPageCount;
	- final boolean mPacked;
	- final BitmapFontOptions mBitmapFontOptions;
~			final String assetBasePath;
		- final int mTextureOffsetX;
		- final int mTextureOffsetY;
		- final String mFace;
		- final int mSize;
		- final boolean mBold;
		- final boolean mItalic;
		- final String mCharset;
		- final int mUnicode;
		- final int mStretchHeight;
		- final boolean mSmooth;
		- final boolean mAntiAliased;
		- final int mPaddingLeft;
		- final int mPaddingTop;
		- final int mPaddingRight;
		- final int mPaddingBottom;
		- final int mSpacingX;
		- final int mSpacingY;
		- int mID;
		- final ITexture mTexture;
 
}
class org.andengine.opengl.font.Font {
 + float getLeading() 
+ float getAscent() 
+ float getDescent() 
+ ITexture getTexture() 
+ void load() 
+ void unload() 
+ float getLineHeight() 
+ synchronized Letter getLetter(final char pCharacter) 
+ synchronized void invalidateLetters() 
- float getLetterAdvance(final String pCharacterAsString) 
# Bitmap getLetterBitmap(final Letter pLetter) 
# void drawLetter(final String pCharacterAsString, final float pLeft, final float pTop) 
+ void prepareLetters(final char... pCharacters) 
- Letter createLetter(final char pCharacter) 
# void updateTextBounds(final String pCharacterAsString) 
+ synchronized void update(final GLState pGLState) 
	- final FontManager mFontManager;
	- final ITexture mTexture;
	- final int mTextureWidth;
	- final int mTextureHeight;
	- int mCurrentTextureYHeightMax;
	# final Paint mPaint;
	- final Paint mBackgroundPaint;
	# final FontMetrics mFontMetrics;
 
}
class org.andengine.opengl.font.FontFactory {
 + {static} void setAssetBasePath(final String pAssetBasePath) 
+ {static} String getAssetBasePath() 
+ {static} void onCreate() 
+ {static} Font create(final FontManager pFontManager, final ITexture pTexture, final float pSize) 
+ {static} Font create(final FontManager pFontManager, final ITexture pTexture, final float pSize, final boolean pAntiAlias) 
+ {static} Font create(final FontManager pFontManager, final ITexture pTexture, final float pSize, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final ITexture pTexture, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final TextureOptions pTextureOptions, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final Typeface pTypeface, final float pSize) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final Typeface pTypeface, final float pSize, final boolean pAntiAlias) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final Typeface pTypeface, final float pSize, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final Typeface pTypeface, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize, final boolean pAntiAlias) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize, final boolean pAntiAlias) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions, final Typeface pTypeface, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font create(final FontManager pFontManager, final ITexture pTexture, final Typeface pTypeface, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font createFromAsset(final FontManager pFontManager, final ITexture pTexture, final AssetManager pAssetManager, final String pAssetPath, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font createFromAsset(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final AssetManager pAssetManager, final String pAssetPath, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font createFromAsset(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final TextureOptions pTextureOptions, final AssetManager pAssetManager, final String pAssetPath, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} Font createFromAsset(final FontManager pFontManager, final TextureManager pTextureManager, final int pTextureWidth, final int pTextureHeight, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions, final AssetManager pAssetManager, final String pAssetPath, final float pSize, final boolean pAntiAlias, final int pColor) 
+ {static} StrokeFont createStroke(final FontManager pFontManager, final ITexture pTexture, final Typeface pTypeface, final float pSize, final boolean pAntiAlias, final int pColor, final float pStrokeWidth, final int pStrokeColor) 
+ {static} StrokeFont createStroke(final FontManager pFontManager, final ITexture pTexture, final Typeface pTypeface, final float pSize, final boolean pAntiAlias, final int pColor, final float pStrokeWidth, final int pStrokeColor, final boolean pStrokeOnly) 
+ {static} StrokeFont createStrokeFromAsset(final FontManager pFontManager, final ITexture pTexture, final AssetManager pAssetManager, final String pAssetPath, final float pSize, final boolean pAntiAlias, final int pColor, final float pStrokeWidth, final int pStrokeColor) 
+ {static} StrokeFont createStrokeFromAsset(final FontManager pFontManager, final ITexture pTexture, final AssetManager pAssetManager, final String pAssetPath, final float pSize, final boolean pAntiAlias, final int pColor, final float pStrokeWidth, final int pStrokeColor, final boolean pStrokeOnly) 
 
}
class org.andengine.opengl.font.FontLibrary {
 + void loadFonts(final FontManager pFontManager) 
 
}
class org.andengine.opengl.font.FontManager {
 + void onCreate() 
+ synchronized void onDestroy() 
+ synchronized void loadFont(final Font pFont) 
+ synchronized void loadFonts(final Font ...pFonts) 
+ synchronized void unloadFont(final Font pFont) 
+ synchronized void unloadFonts(final Font ...pFonts) 
+ synchronized void updateFonts(final GLState pGLState) 
+ synchronized void onReload() 
 
}
class org.andengine.opengl.font.FontUtils {
 + {static} float measureText(final IFont pFont, final CharSequence pText) 
+ {static} float measureText(final IFont pFont, final CharSequence pText, final int pStart, final int pEnd) 
+ {static} float measureText(final IFont pFont, final CharSequence pText, final float[] pWidths) 
+ {static} float measureText(final IFont pFont, final CharSequence pText, final int pStart, final int pEnd, final float[] pWidths) 
+ {static} int breakText(final IFont pFont, final CharSequence pText, final MeasureDirection pMeasureDirection, final float pWidthMaximum, final float[] pMeasuredWidth) 
+ {static} <L extends List<CharSequence>> L splitLines(final CharSequence pText, final L pResult) 
+ {static} <L extends List<CharSequence>> L splitLines(final IFont pFont, final CharSequence pText, final L pResult, final AutoWrap pAutoWrap, final float pAutoWrapWidth) 
- {static} <L extends List<CharSequence>> L splitLinesByLetters(final IFont pFont, final CharSequence pText, final L pResult, final float pAutoWrapWidth) 
- {static} <L extends List<CharSequence>> L splitLinesByWords(final IFont pFont, final CharSequence pText, final L pResult, final float pAutoWrapWidth) 
- {static} <L extends List<CharSequence>> L splitLinesByCJK(final IFont pFont, final CharSequence pText, final L pResult, final float pAutoWrapWidth) 
- {static} float getAdvanceCorrection(final IFont pFont, final CharSequence pText, final int pIndex) 
~			final float widthNeeded;
 
}
class org.andengine.opengl.font.Letter {
 + int getKerning(final int pCharacter) 
+ boolean isWhitespace() 
+ int hashCode() 
+ boolean equals(final Object pObject) 
+ String toString() 
	+ final char mCharacter;
	- final boolean mWhitespace;
	+ final int mTextureX;
	+ final int mTextureY;
	+ final int mWidth;
	+ final int mHeight;
	+ final float mOffsetX;
	+ final float mOffsetY;
	+ final float mAdvance;
	+ final float mU;
	+ final float mV;
	+ final float mU2;
	+ final float mV2;
	- SparseIntArray mKernings;
 
}
class org.andengine.opengl.font.StrokeFont {
 # void updateTextBounds(final String pCharacterAsString) 
# void drawLetter(final String pCharacterAsString, final float pLeft, final float pTop) 
	- final Paint mStrokePaint;
	- final boolean mStrokeOnly;
	- final float mStrokeWidth;
 
}
class org.andengine.opengl.font.exception.FontException {
  
}
class org.andengine.opengl.font.exception.LetterNotFoundException {
  
}
class org.andengine.opengl.shader.PositionColorShaderProgram {
 + {static} PositionColorShaderProgram getInstance() 
# void link(final GLState pGLState) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
+ void unbind(final GLState pGLState) 
	- {static} PositionColorShaderProgram INSTANCE;
 
}
class org.andengine.opengl.shader.PositionColorTextureCoordinatesShaderProgram {
 + {static} PositionColorTextureCoordinatesShaderProgram getInstance() 
# void link(final GLState pGLState) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
	- {static} PositionColorTextureCoordinatesShaderProgram INSTANCE;
 
}
class org.andengine.opengl.shader.PositionTextureCoordinatesPositionInterpolationTextureSelectShaderProgram {
 + {static} PositionTextureCoordinatesPositionInterpolationTextureSelectShaderProgram getInstance() 
# void link(final GLState pGLState) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
+ void unbind(final GLState pGLState) 
	- {static} PositionTextureCoordinatesPositionInterpolationTextureSelectShaderProgram INSTANCE;
 
}
class org.andengine.opengl.shader.PositionTextureCoordinatesShaderProgram {
 + {static} PositionTextureCoordinatesShaderProgram getInstance() 
# void link(final GLState pGLState) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
+ void unbind(final GLState pGLState) 
	- {static} PositionTextureCoordinatesShaderProgram INSTANCE;
 
}
class org.andengine.opengl.shader.PositionTextureCoordinatesTextureSelectShaderProgram {
 + {static} PositionTextureCoordinatesTextureSelectShaderProgram getInstance() 
# void link(final GLState pGLState) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
+ void unbind(final GLState pGLState) 
	- {static} PositionTextureCoordinatesTextureSelectShaderProgram INSTANCE;
 
}
class org.andengine.opengl.shader.PositionTextureCoordinatesUniformColorShaderProgram {
 + {static} PositionTextureCoordinatesUniformColorShaderProgram getInstance() 
# void link(final GLState pGLState) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
+ void unbind(final GLState pGLState) 
	- {static} PositionTextureCoordinatesUniformColorShaderProgram INSTANCE;
 
}
class org.andengine.opengl.shader.ShaderProgram {
 + boolean isCompiled() 
+ void setCompiled(final boolean pCompiled) 
+ int getAttributeLocation(final String pAttributeName) 
+ int getAttributeLocationOptional(final String pAttributeName) 
+ int getUniformLocation(final String pUniformName) 
+ int getUniformLocationOptional(final String pUniformName) 
+ void bind(final GLState pGLState, final VertexBufferObjectAttributes pVertexBufferObjectAttributes) 
+ void unbind(final GLState pGLState) 
+ void delete(final GLState pGLState) 
# void compile(final GLState pGLState) 
# void link(final GLState pGLState) 
- {static} int compileShader(final String pSource, final int pType) 
- void initUniformLocations() 
- void initAttributeLocations() 
+ void setUniform(final String pUniformName, final float[] pGLMatrix) 
+ void setUniformOptional(final String pUniformName, final float[] pGLMatrix) 
+ void setUniform(final String pUniformName, final float pX) 
+ void setUniformOptional(final String pUniformName, final float pX) 
+ void setUniform(final String pUniformName, final float pX, final float pY) 
+ void setUniformOptional(final String pUniformName, final float pX, final float pY) 
+ void setUniform(final String pUniformName, final float pX, final float pY, final float pZ) 
+ void setUniformOptional(final String pUniformName, final float pX, final float pY, final float pZ) 
+ void setUniform(final String pUniformName, final float pX, final float pY, final float pZ, final float pW) 
+ void setUniformOptional(final String pUniformName, final float pX, final float pY, final float pZ, final float pW) 
+ void setTexture(final String pUniformName, final int pTexture) 
+ void setTextureOptional(final String pUniformName, final int pTexture) 
	# final IShaderSource mVertexShaderSource;
	# final IShaderSource mFragmentShaderSource;
	# boolean mCompiled;
 
}
class org.andengine.opengl.shader.ShaderProgramManager {
 + synchronized void onCreate() 
+ synchronized void onDestroy() 
+ synchronized void loadShaderProgram(final ShaderProgram pShaderProgram) 
+ void loadShaderPrograms(final ShaderProgram ... pShaderPrograms) 
+ synchronized void onReload() 
 
}
class org.andengine.opengl.shader.exception.ShaderProgramCompileException {
  
}
class org.andengine.opengl.shader.exception.ShaderProgramException {
  
}
class org.andengine.opengl.shader.exception.ShaderProgramLinkException {
  
}
class org.andengine.opengl.shader.source.CriteriaShaderSource {
 + String getShaderSource(final GLState pGLState) 
+ String getShaderSource() 
+ boolean isMet(final GLState pGLState) 
	- final CriteriaShaderSourceEntry[] mCriteriaShaderSourceEntries;
		- final String mShaderSource;
		- final IGLCriteria[] mGLCriterias;
 
}
class org.andengine.opengl.shader.source.StringShaderSource {
 + String getShaderSource(final GLState pGLState) 
	- final String mShaderSource;
 
}
class org.andengine.opengl.texture.DebugTextureStateListener {
 + void onLoadedToHardware(final ITexture pTexture) 
+ void onUnloadedFromHardware(final ITexture pTexture) 
 
}
class org.andengine.opengl.texture.TextureManager {
 + synchronized void onCreate() 
+ synchronized void onReload() 
+ synchronized void onDestroy() 
+ synchronized boolean hasMappedTexture(final String pID) 
+ synchronized ITexture getMappedTexture(final String pID) 
+ synchronized void addMappedTexture(final String pID, final ITexture pTexture) 
+ synchronized ITexture removedMappedTexture(final String pID) 
+ synchronized boolean loadTexture(final ITexture pTexture) 
+ synchronized boolean loadTexture(final GLState pGLState, final ITexture pTexture) 
+ synchronized boolean unloadTexture(final ITexture pTexture) 
+ synchronized boolean unloadTexture(final GLState pGLState, final ITexture pTexture) 
+ synchronized void updateTextures(final GLState pGLState) 
+ synchronized ITexture getTexture(final String pID, final AssetManager pAssetManager, final String pAssetPath) 
+ synchronized ITexture getTexture(final String pID, final AssetManager pAssetManager, final String pAssetPath, final TextureOptions pTextureOptions) 
+ synchronized ITexture getTexture(final String pID, final IInputStreamOpener pInputStreamOpener) 
+ synchronized ITexture getTexture(final String pID, final IInputStreamOpener pInputStreamOpener, final TextureOptions pTextureOptions) 
+ synchronized ITexture getTexture(final String pID, final IInputStreamOpener pInputStreamOpener, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions) 
+ synchronized ITexture getTexture(final String pID, final IInputStreamOpener pInputStreamOpener, final BitmapTextureFormat pBitmapTextureFormat, final TextureOptions pTextureOptions, final boolean pLoadToHardware) 
	- TextureWarmUpVertexBufferObject mTextureWarmUpVertexBufferObject;
 
}
class org.andengine.opengl.texture.TextureOptions {
 + void apply() 
	+ final int mMagFilter;
	+ final int mMinFilter;
	+ final float mWrapT;
	+ final float mWrapS;
	+ final boolean mPreMultiplyAlpha;
 
}
class org.andengine.opengl.texture.TextureStateAdapter {
 + void onLoadedToHardware(final ITexture pTexture) 
+ void onUnloadedFromHardware(final ITexture pTexture) 
 
}
class org.andengine.opengl.texture.TextureWarmUpVertexBufferObject {
 + int getHeapMemoryByteSize() 
+ int getNativeHeapMemoryByteSize() 
# void onBufferData() 
+ void warmup(final GLState pGLState, final ITexture pTexture) 
	# final FloatBuffer mFloatBuffer;
 
}
class org.andengine.opengl.texture.atlas.bitmap.BitmapTextureAtlas {
 + BitmapTextureFormat getBitmapTextureFormat() 
+ void addEmptyTextureAtlasSource(final int pTextureX, final int pTextureY, final int pWidth, final int pHeight) 
# void writeTextureToHardware(final GLState pGLState) 
	- final BitmapTextureFormat mBitmapTextureFormat;
 
}
class org.andengine.opengl.texture.atlas.bitmap.BitmapTextureAtlasTextureRegionFactory {
 + {static} void setAssetBasePath(final String pAssetBasePath) 
+ {static} String getAssetBasePath() 
+ {static} void reset() 
+ {static} TextureRegion createFromAsset(final BitmapTextureAtlas pBitmapTextureAtlas, final Context pContext, final String pAssetPath, final int pTextureX, final int pTextureY) 
+ {static} TextureRegion createFromAsset(final BitmapTextureAtlas pBitmapTextureAtlas, final AssetManager pAssetManager, final String pAssetPath, final int pTextureX, final int pTextureY) 
+ {static} TiledTextureRegion createTiledFromAsset(final BitmapTextureAtlas pBitmapTextureAtlas, final Context pContext, final String pAssetPath, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion createTiledFromAsset(final BitmapTextureAtlas pBitmapTextureAtlas, final AssetManager pAssetManager, final String pAssetPath, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows) 
+ {static} TextureRegion createFromResource(final BitmapTextureAtlas pBitmapTextureAtlas, final Context pContext, final int pDrawableResourceID, final int pTextureX, final int pTextureY) 
+ {static} TextureRegion createFromResource(final BitmapTextureAtlas pBitmapTextureAtlas, final Resources pResources, final int pDrawableResourceID, final int pTextureX, final int pTextureY) 
+ {static} TiledTextureRegion createTiledFromResource(final BitmapTextureAtlas pBitmapTextureAtlas, final Context pContext, final int pDrawableResourceID, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion createTiledFromResource(final BitmapTextureAtlas pBitmapTextureAtlas, final Resources pResources, final int pDrawableResourceID, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows) 
+ {static} TextureRegion createFromSource(final BitmapTextureAtlas pBitmapTextureAtlas, final IBitmapTextureAtlasSource pBitmapTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ {static} TiledTextureRegion createTiledFromSource(final BitmapTextureAtlas pBitmapTextureAtlas, final IBitmapTextureAtlasSource pBitmapTextureAtlasSource, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows) 
+ {static} TextureRegion createFromAsset(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Context pContext, final String pAssetPath) 
+ {static} TextureRegion createFromAsset(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final AssetManager pAssetManager, final String pAssetPath) 
+ {static} TextureRegion createFromAsset(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Context pContext, final String pAssetPath, final boolean pRotated) 
+ {static} TextureRegion createFromAsset(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final AssetManager pAssetManager, final String pAssetPath, final boolean pRotated) 
+ {static} TiledTextureRegion createTiledFromAsset(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Context pContext, final String pAssetPath, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion createTiledFromAsset(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final AssetManager pAssetManager, final String pAssetPath, final int pTileColumns, final int pTileRows) 
+ {static} TextureRegion createFromResource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Context pContext, final int pDrawableResourceID) 
+ {static} TextureRegion createFromResource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Resources pResources, final int pDrawableResourceID) 
+ {static} TextureRegion createFromResource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Context pContext, final int pDrawableResourceID, final boolean pRotated) 
+ {static} TextureRegion createFromResource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Resources pResources, final int pDrawableResourceID, final boolean pRotated) 
+ {static} TiledTextureRegion createTiledFromResource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Context pContext, final int pDrawableResourceID, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion createTiledFromResource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final Resources pResources, final int pDrawableResourceID, final int pTileColumns, final int pTileRows) 
+ {static} TextureRegion createFromSource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final IBitmapTextureAtlasSource pBitmapTextureAtlasSource) 
+ {static} TextureRegion createFromSource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final IBitmapTextureAtlasSource pBitmapTextureAtlasSource, final boolean pRotated) 
+ {static} TiledTextureRegion createTiledFromSource(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final IBitmapTextureAtlasSource pBitmapTextureAtlasSource, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion createTiledFromAssetDirectory(final BuildableBitmapTextureAtlas pBuildableBitmapTextureAtlas, final AssetManager pAssetManager, final String pAssetSubdirectory) 
 
}
class org.andengine.opengl.texture.atlas.bitmap.BuildableBitmapTextureAtlas {
  
}
class org.andengine.opengl.texture.atlas.bitmap.source.AssetBitmapTextureAtlasSource {
 + {static} AssetBitmapTextureAtlasSource create(final AssetManager pAssetManager, final String pAssetPath) 
+ {static} AssetBitmapTextureAtlasSource create(final AssetManager pAssetManager, final String pAssetPath, final int pTextureX, final int pTextureY) 
+ AssetBitmapTextureAtlasSource deepCopy() 
+ Bitmap onLoadBitmap(final Config pBitmapConfig) 
+ String toString() 
	- final AssetManager mAssetManager;
	- final String mAssetPath;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.EmptyBitmapTextureAtlasSource {
 + EmptyBitmapTextureAtlasSource deepCopy() 
+ Bitmap onLoadBitmap(final Config pBitmapConfig) 
+ String toString() 
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.FileBitmapTextureAtlasSource {
 + {static} FileBitmapTextureAtlasSource create(final File pFile) 
+ {static} FileBitmapTextureAtlasSource create(final File pFile, final int pTextureX, final int pTextureY) 
+ {static} FileBitmapTextureAtlasSource createFromInternalStorage(final Context pContext, final String pFilePath, final int pTextureX, final int pTextureY) 
+ {static} FileBitmapTextureAtlasSource createFromExternalStorage(final Context pContext, final String pFilePath, final int pTextureX, final int pTextureY) 
+ FileBitmapTextureAtlasSource deepCopy() 
+ Bitmap onLoadBitmap(final Config pBitmapConfig) 
+ String toString() 
	- final File mFile;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.ResourceBitmapTextureAtlasSource {
 + {static} ResourceBitmapTextureAtlasSource create(final Resources pResources, final int pDrawableResourceID) 
+ {static} ResourceBitmapTextureAtlasSource create(final Resources pResources, final int pDrawableResourceID, final int pTextureX, final int pTextureY) 
+ ResourceBitmapTextureAtlasSource deepCopy() 
+ Bitmap onLoadBitmap(final Config pBitmapConfig) 
+ String toString() 
	- final Resources mResources;
	- final int mDrawableResourceID;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseBitmapTextureAtlasSourceDecorator.TextureAtlasSourceDecoratorOptions
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.ColorKeyBitmapTextureAtlasSourceDecorator {
 + ColorKeyBitmapTextureAtlasSourceDecorator deepCopy() 
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.ColorSwapBitmapTextureAtlasSourceDecorator {
 + ColorSwapBitmapTextureAtlasSourceDecorator deepCopy() 
	# final int mColorKeyColorARGBPackedInt;
	# final int mTolerance;
	# final int mColorSwapColorARGBPackedInt;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.FillBitmapTextureAtlasSourceDecorator {
 + FillBitmapTextureAtlasSourceDecorator deepCopy() 
	# final int mFillColor;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.LinearGradientFillBitmapTextureAtlasSourceDecorator {
 + LinearGradientFillBitmapTextureAtlasSourceDecorator deepCopy() 
~final int getFromX(int pRight) 
~final int getFromY(int pBottom) 
~final int getToX(int pRight) 
~final int getToY(int pBottom) 
	# final LinearGradientDirection mLinearGradientDirection;
	# final int[] mColors;
	# final float[] mPositions;
		- final int mFromX;
		- final int mFromY;
		- final int mToX;
		- final int mToY;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.OutlineBitmapTextureAtlasSourceDecorator {
 + OutlineBitmapTextureAtlasSourceDecorator deepCopy() 
	# final int mOutlineColor;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.RadialGradientFillBitmapTextureAtlasSourceDecorator {
 + RadialGradientFillBitmapTextureAtlasSourceDecorator deepCopy() 
	# final RadialGradientDirection mRadialGradientDirection;
	# final int[] mColors;
	# final float[] mPositions;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.ArcBitmapTextureAtlasSourceDecoratorShape {
 + {static} ArcBitmapTextureAtlasSourceDecoratorShape getDefaultInstance() 
+ void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureAtlasSourceDecoratorOptions pDecoratorOptions) 
	- {static} ArcBitmapTextureAtlasSourceDecoratorShape sDefaultInstance;
	- final float mStartAngle;
	- final float mSweepAngle;
	- final boolean mUseCenter;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.CircleBitmapTextureAtlasSourceDecoratorShape {
 + {static} CircleBitmapTextureAtlasSourceDecoratorShape getDefaultInstance() 
+ void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureAtlasSourceDecoratorOptions pDecoratorOptions) 
	- {static} CircleBitmapTextureAtlasSourceDecoratorShape sDefaultInstance;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.EllipseBitmapTextureAtlasSourceDecoratorShape {
 + {static} EllipseBitmapTextureAtlasSourceDecoratorShape getDefaultInstance() 
+ void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureAtlasSourceDecoratorOptions pDecoratorOptions) 
	- {static} EllipseBitmapTextureAtlasSourceDecoratorShape sDefaultInstance;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.RectangleBitmapTextureAtlasSourceDecoratorShape {
 + {static} RectangleBitmapTextureAtlasSourceDecoratorShape getDefaultInstance() 
+ void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureAtlasSourceDecoratorOptions pDecoratorOptions) 
	- {static} RectangleBitmapTextureAtlasSourceDecoratorShape sDefaultInstance;
 
}
class org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.RoundedRectangleBitmapTextureAtlasSourceDecoratorShape {
 + {static} RoundedRectangleBitmapTextureAtlasSourceDecoratorShape getDefaultInstance() 
+ void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureAtlasSourceDecoratorOptions pDecoratorOptions) 
	- final float mCornerRadiusX;
	- final float mCornerRadiusY;
	- {static} RoundedRectangleBitmapTextureAtlasSourceDecoratorShape sDefaultInstance;
 
}
class org.andengine.opengl.texture.atlas.buildable.BuildableTextureAtlas {
 + int getWidth() 
+ int getHeight() 
+ int getHardwareTextureID() 
+ boolean isLoadedToHardware() 
+ void setNotLoadedToHardware() 
+ boolean isUpdateOnHardwareNeeded() 
+ void setUpdateOnHardwareNeeded(final boolean pUpdateOnHardwareNeeded) 
+ void load() 
+ void load(final GLState pGLState) 
+ void unload() 
+ void unload(final GLState pGLState) 
+ void loadToHardware(final GLState pGLState) 
+ void unloadFromHardware(final GLState pGLState) 
+ void reloadToHardware(final GLState pGLState) 
+ void bind(final GLState pGLState) 
+ void bind(final GLState pGLState, final int pGLActiveTexture) 
+ PixelFormat getPixelFormat() 
+ TextureOptions getTextureOptions() 
+ void addTextureAtlasSource(final S pTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ void addTextureAtlasSource(final S pTextureAtlasSource, final int pTextureX, final int pTextureY, final int pTextureAtlasSourcePadding) 
+ void removeTextureAtlasSource(final S pTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ void clearTextureAtlasSources() 
+ boolean hasTextureStateListener() 
+ boolean hasTextureAtlasStateListener() 
+ ITextureAtlasStateListener<S> getTextureStateListener() 
+ ITextureAtlasStateListener<S> getTextureAtlasStateListener() 
+ void setTextureStateListener(final ITextureStateListener pTextureStateListener) 
+ void setTextureAtlasStateListener(final ITextureAtlasStateListener<S> pTextureAtlasStateListener) 
+ void addEmptyTextureAtlasSource(final int pTextureX, final int pTextureY, final int pWidth, final int pHeight) 
+ void addTextureAtlasSource(final S pTextureAtlasSource, final Callback<S> pCallback) 
+ void removeTextureAtlasSource(final ITextureAtlasSource pTextureAtlasSource) 
+ IBuildableTextureAtlas<S, T> build(final ITextureAtlasBuilder<S, T> pTextureAtlasBuilder) 
+ T getTextureAtlasSource() 
+ Callback<T> getCallback() 
	- final T mTextureAtlas;
		- final T mTextureAtlasSource;
		- final Callback<T> mCallback;
 
}
class org.andengine.opengl.texture.atlas.buildable.BuildableTextureAtlas.TextureAtlasSourceWithWithLocationCallback
class org.andengine.opengl.texture.atlas.buildable.BuildableTextureAtlasTextureRegionFactory {
 + {static} <T extends ITextureAtlasSource, A extends ITextureAtlas<T>> TextureRegion createFromSource(final BuildableTextureAtlas<T, A> pBuildableTextureAtlas, final T pTextureAtlasSource, final boolean pRotated) 
+ {static} <T extends ITextureAtlasSource, A extends ITextureAtlas<T>> TiledTextureRegion createTiledFromSource(final BuildableTextureAtlas<T, A> pBuildableTextureAtlas, final T pTextureAtlasSource, final int pTileColumns, final int pTileRows) 
 
}
class org.andengine.opengl.texture.atlas.buildable.builder.BlackPawnTextureAtlasBuilder {
 + int compare(final TextureAtlasSourceWithWithLocationCallback<?> pTextureAtlasSourceWithWithLocationCallbackA, final TextureAtlasSourceWithWithLocationCallback<?> pTextureAtlasSourceWithWithLocationCallbackB) 
+ void build(final A pTextureAtlas, final ArrayList<TextureAtlasSourceWithWithLocationCallback<T>> pTextureAtlasSourcesWithLocationCallback) 
+ int getWidth() 
+ int getHeight() 
+ int getLeft() 
+ int getTop() 
+ int getRight() 
+ int getBottom() 
+ String toString() 
+ Rect getRect() 
+ Node getChildA() 
+ Node getChildB() 
+ Node insert(final ITextureAtlasSource pTextureAtlasSource, final int pTextureWidth, final int pTextureHeight, final int pTextureAtlasSourceSpacing, final int pTextureAtlasSourcePadding) 
- Node createChildren(final ITextureAtlasSource pTextureAtlasSource, final int pTextureWidth, final int pTextureHeight, final int pTextureAtlasSourceSpacing, final int pTextureAtlasSourcePadding, final int pDeltaWidth, final int pDeltaHeight) 
	- final int mTextureAtlasBorderSpacing;
	- final int mTextureAtlasSourceSpacing;
	- final int mTextureAtlasSourcePadding;
		- final int mLeft;
		- final int mTop;
		- final int mWidth;
		- final int mHeight;
		- Node mChildA;
		- Node mChildB;
		- final Rect mRect;
		- ITextureAtlasSource mTextureAtlasSource;
 
}
class org.andengine.opengl.texture.atlas.buildable.builder.ITextureAtlasBuilder {
 + void build(final A pTextureAtlas, final ArrayList<TextureAtlasSourceWithWithLocationCallback<T>> pTextureAtlasSourcesWithLocationCallback) 
 
}.TextureAtlasBuilderException
class org.andengine.opengl.texture.bitmap.AssetBitmapTexture {
  
}
class org.andengine.opengl.texture.bitmap.BitmapTexture {
 + int getWidth() 
+ int getHeight() 
# void writeTextureToHardware(final GLState pGLState) 
# Bitmap onGetBitmap(final Config pBitmapConfig) 
	- final int mWidth;
	- final int mHeight;
	- final IInputStreamOpener mInputStreamOpener;
	- final BitmapTextureFormat mBitmapTextureFormat;
 
}
class org.andengine.opengl.texture.bitmap.ResourceBitmapTexture {
  
}
class org.andengine.opengl.texture.compressed.pvr.PVRTexture.PVRTextureFormat
class org.andengine.opengl.texture.compressed.pvr.PVRTexture.PVRTextureHeader
class org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.GreedyPVRTexturePixelBufferStrategy {
 + IPVRTexturePixelBufferStrategyBufferManager newPVRTexturePixelBufferStrategyManager(final PVRTexture pPVRTexture) 
+ void loadPVRTextureData(final IPVRTexturePixelBufferStrategyBufferManager pPVRTexturePixelBufferStrategyManager, final int pWidth, final int pHeight, final int pBytesPerPixel, final PixelFormat pPixelFormat, final int pLevel, final int pCurrentPixelDataOffset, final int pCurrentPixelDataSize) 
+ ByteBuffer getPixelBuffer(final int pStart, final int pByteCount) 
		- final ByteBuffer mByteBuffer;
 
}
class org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.IPVRTexturePixelBufferStrategy {
 + IPVRTexturePixelBufferStrategyBufferManager newPVRTexturePixelBufferStrategyManager(final PVRTexture pPVRTexture) 
 
}.IPVRTexturePixelBufferStrategyBufferManager
class org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.SmartPVRTexturePixelBufferStrategy {
 + IPVRTexturePixelBufferStrategyBufferManager newPVRTexturePixelBufferStrategyManager(final PVRTexture pPVRTexture) 
+ void loadPVRTextureData(final IPVRTexturePixelBufferStrategyBufferManager pPVRTexturePixelBufferStrategyManager, final int pWidth, final int pHeight, final int pBytesPerPixel, final PixelFormat pPixelFormat, final int pLevel, final int pCurrentPixelDataOffset, final int pCurrentPixelDataSize) 
+ ByteBuffer getPixelBuffer(final int pStart, final int pByteCount) 
	- final int mAllocationSizeMaximum;
		- final InputStream mInputStream;
		- int mInputStreamPosition;
		- byte[] mData;
 
}
class org.andengine.opengl.texture.region.TextureRegion {
 + TextureRegion deepCopy() 
+ float getTextureX() 
+ float getTextureY() 
+ void setTextureX(final float pTextureX) 
+ void setTextureY(final float pTextureY) 
+ void setTexturePosition(final float pTextureX, final float pTextureY) 
+ float getWidth() 
+ float getHeight() 
+ void setTextureWidth(final float pTextureWidth) 
+ void setTextureHeight(final float pTextureHeight) 
+ void setTextureSize(final float pTextureWidth, final float pTextureHeight) 
+ void set(final float pTextureX, final float pTextureY, final float pTextureWidth, final float pTextureHeight) 
+ float getU() 
+ float getU2() 
+ float getV() 
+ float getV2() 
+ boolean isScaled() 
+ float getScale() 
+ boolean isRotated() 
+ void updateUV() 
	# float mTextureX;
	# float mTextureY;
	# float mTextureWidth;
	# float mTextureHeight;
	# float mU;
	# float mU2;
	# float mV;
	# float mV2;
	# final float mScale;
	# final boolean mRotated;
 
}
class org.andengine.opengl.texture.region.TextureRegionFactory {
 + {static} TextureRegion extractFromTexture(final ITexture pTexture) 
+ {static} TextureRegion extractFromTexture(final ITexture pTexture, final int pTextureX, final int pTextureY, final int pWidth, final int pHeight) 
+ {static} TextureRegion extractFromTexture(final ITexture pTexture, final boolean pRotated) 
+ {static} TextureRegion extractFromTexture(final ITexture pTexture, final int pTextureX, final int pTextureY, final int pWidth, final int pHeight, final boolean pRotated) 
+ {static} TiledTextureRegion extractTiledFromTexture(final ITexture pTexture, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion extractTiledFromTexture(final ITexture pTexture, final int pTextureX, final int pTextureY, final int pWidth, final int pHeight, final int pTileColumns, final int pTileRows) 
+ {static} <T extends ITextureAtlasSource> TextureRegion createFromSource(final ITextureAtlas<T> pTextureAtlas, final T pTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ {static} <T extends ITextureAtlasSource> TextureRegion createFromSource(final ITextureAtlas<T> pTextureAtlas, final T pTextureAtlasSource, final int pTextureX, final int pTextureY, final boolean pRotated) 
+ {static} <T extends ITextureAtlasSource> TiledTextureRegion createTiledFromSource(final ITextureAtlas<T> pTextureAtlas, final T pTextureAtlasSource, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows) 
+ {static} <T extends ITextureAtlasSource> TiledTextureRegion createTiledFromSource(final ITextureAtlas<T> pTextureAtlas, final T pTextureAtlasSource, final int pTextureX, final int pTextureY, final int pTileColumns, final int pTileRows, final boolean pRotated) 
 
}
class org.andengine.opengl.texture.region.TextureRegionLibrary {
 + TextureRegion get(final int pID) 
+ TiledTextureRegion getTiled(final int pID) 
 
}
class org.andengine.opengl.texture.region.TiledTextureRegion {
 + {static} TiledTextureRegion create(final ITexture pTexture, final int pTextureX, final int pTextureY, final int pTextureWidth, final int pTextureHeight, final int pTileColumns, final int pTileRows) 
+ {static} TiledTextureRegion create(final ITexture pTexture, final int pTextureX, final int pTextureY, final int pTextureWidth, final int pTextureHeight, final int pTileColumns, final int pTileRows, final boolean pRotated) 
+ TiledTextureRegion deepCopy() 
+ int getCurrentTileIndex() 
+ void setCurrentTileIndex(final int pCurrentTileIndex) 
+ void nextTile() 
+ ITextureRegion getTextureRegion(final int pTileIndex) 
+ int getTileCount() 
+ float getTextureX() 
+ float getTextureX(final int pTileIndex) 
+ float getTextureY() 
+ float getTextureY(final int pTileIndex) 
+ void setTextureX(final float pTextureX) 
+ void setTextureX(final int pTileIndex, final float pTextureX) 
+ void setTextureY(final float pTextureY) 
+ void setTextureY(final int pTileIndex, final float pTextureY) 
+ void setTexturePosition(final float pTextureX, final float pTextureY) 
+ void setTexturePosition(final int pTileIndex, final float pTextureX, final float pTextureY) 
+ float getWidth() 
+ float getWidth(final int pTileIndex) 
+ float getHeight() 
+ float getHeight(final int pTileIndex) 
+ void setTextureWidth(final float pTextureWidth) 
+ void setTextureWidth(final int pTileIndex, final float pTextureWidth) 
+ void setTextureHeight(final float pTextureHeight) 
+ void setTextureHeight(final int pTileIndex, final float pTextureHeight) 
+ void setTextureSize(final float pTextureWidth, final float pTextureHeight) 
+ void setTextureSize(final int pTileIndex, final float pTextureWidth, final float pTextureHeight) 
+ void set(final float pTextureX, final float pTextureY, final float pTextureWidth, final float pTextureHeight) 
+ void set(final int pTileIndex, final float pTextureX, final float pTextureY, final float pTextureWidth, final float pTextureHeight) 
+ float getU() 
+ float getU(final int pTileIndex) 
+ float getV() 
+ float getV(final int pTileIndex) 
+ float getU2() 
+ float getU2(final int pTileIndex) 
+ float getV2() 
+ float getV2(final int pTileIndex) 
+ boolean isScaled() 
+ boolean isScaled(final int pTileIndex) 
+ float getScale() 
+ float getScale(final int pTileIndex) 
+ boolean isRotated() 
+ boolean isRotated(final int pTileIndex) 
	# int mCurrentTileIndex;
	# final int mTileCount;
	# final ITextureRegion[] mTextureRegions;
 
}
class org.andengine.opengl.texture.render.RenderTexture {
 + int getWidth() 
+ int getHeight() 
+ boolean isInitialized() 
# void writeTextureToHardware(final GLState pGLState) 
+ void init(final GLState pGLState) 
+ void begin(final GLState pGLState) 
+ void begin(final GLState pGLState, final Color pColor) 
+ void begin(final GLState pGLState, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void begin(final GLState pGLState, final boolean pFlipX, final boolean pFlipY, final Color pColor) 
+ void begin(final GLState pGLState, final boolean pFlipX, final boolean pFlipY, final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ void begin(final GLState pGLState, final boolean pFlipX, final boolean pFlipY) 
+ void flush(final GLState pGLState) 
+ void finish(final GLState pGLState) 
+ void end(final GLState pGLState) 
+ void end(final GLState pGLState, final boolean pFlush, final boolean pFinish) 
+ void destroy(final GLState pGLState) 
# void savePreviousFramebufferObjectID(final GLState pGLState) 
# void restorePreviousFramebufferObjectID(final GLState pGLState) 
# void savePreviousViewport() 
# void resotorePreviousViewport() 
+ int[] getPixelsARGB_8888(final GLState pGLState) 
+ int[] getPixelsARGB_8888(final GLState pGLState, final int pX, final int pY, final int pWidth, final int pHeight) 
+ Bitmap getBitmap(final GLState pGLState) 
+ Bitmap getBitmap(final GLState pGLState, final int pX, final int pY, final int pWidth, final int pHeight) 
	# final PixelFormat mPixelFormat;
	# final int mWidth;
	# final int mHeight;
	# int mFramebufferObjectID;
	- int mPreviousFramebufferObjectID;
	- int mPreviousViewPortX;
	- int mPreviousViewPortY;
	- int mPreviousViewPortWidth;
	- int mPreviousViewPortHeight;
	- boolean mInitialized;
 
}
class org.andengine.opengl.util.BufferUtils {
 + {static} ByteBuffer allocateDirectByteBuffer(final int pCapacity) 
+ {static} void freeDirectByteBuffer(final ByteBuffer pByteBuffer) 
- native {static} ByteBuffer jniAllocateDirect(final int pCapacity)
- native {static} void jniPut(final ByteBuffer pByteBuffer, final float[] pSource, final int pLength, final int pOffset)
+ {static} void putUnsignedByte(final ByteBuffer pByteBuffer, final int pValue) 
+ {static} short getUnsignedByte(final ByteBuffer pByteBuffer, final int pPosition) 
+ {static} void putUnsignedByte(final ByteBuffer pByteBuffer, final int pPosition, final int pValue) 
+ {static} int getUnsignedShort(final ByteBuffer pByteBuffer) 
+ {static} void putUnsignedShort(final ByteBuffer pByteBuffer, final int pValue) 
+ {static} int getUnsignedShort(final ByteBuffer pByteBuffer, final int pPosition) 
+ {static} void putUnsignedShort(final ByteBuffer pByteBuffer, final int pPosition, final int pValue) 
+ {static} long getUnsignedInt(final ByteBuffer pByteBuffer) 
+ {static} void putUnsignedInt(final ByteBuffer pByteBuffer, final long pValue) 
+ {static} long getUnsignedInt(final ByteBuffer pByteBuffer, final int pPosition) 
+ {static} void putUnsignedInt(final ByteBuffer pByteBuffer, final int pPosition, final long pValue) 
	- {static} final boolean NATIVE_LIB_LOADED;
	- {static} final boolean WORKAROUND_BYTEBUFFER_PUT_FLOATARRAY;
	- {static} final boolean WORKAROUND_BYTEBUFFER_ALLOCATE_DIRECT;
 
}
class org.andengine.opengl.util.GLHelper {
 + {static} Buffer getPixels(final Bitmap pBitmap, final PixelFormat pPixelFormat) 
+ {static} Buffer getPixels(final Bitmap pBitmap, final PixelFormat pPixelFormat, final ByteOrder pByteOrder) 
+ {static} int[] convertARGB_8888toRGBA_8888(final int[] pPixelsARGB_8888) 
+ {static} int[] convertARGB_8888toRGBA_8888(final int[] pPixelsARGB_8888, final ByteOrder pByteOrder) 
+ {static} short[] convertARGB_8888toRGB_565(final int[] pPixelsARGB_8888) 
+ {static} short[] convertARGB_8888toRGB_565(final int[] pPixelsARGB_8888, final ByteOrder pByteOrder) 
+ {static} short[] convertARGB_8888toRGBA_4444(final int[] pPixelsARGB_8888) 
+ {static} short[] convertARGB_8888toRGBA_4444(final int[] pPixelsARGB_8888, final ByteOrder pByteOrder) 
+ {static} byte[] convertARGB_8888toA_8(final int[] pPixelsARGB_8888) 
+ {static} int[] getPixelsARGB_8888(final Bitmap pBitmap) 
+ {static} int[] convertRGBA_8888toARGB_8888(final int[] pPixelsRGBA_8888) 
+ {static} int[] convertRGBA_8888toARGB_8888(final int[] pPixelsRGBA_8888, final ByteOrder pByteOrder) 
+ {static} int[] convertRGBA_8888toARGB_8888_FlippedVertical(final int[] pPixelsRGBA_8888, final int pWidth, final int pHeight) 
+ {static} int[] convertRGBA_8888toARGB_8888_FlippedVertical(final int[] pPixelsRGBA_8888, final int pWidth, final int pHeight, final ByteOrder pByteOrder) 
 
}
class org.andengine.opengl.util.GLMatrixStack {
 + void getMatrix(final float[] pMatrix) 
+ void glLoadIdentity() 
+ void glTranslatef(final float pX, final float pY, final float pZ) 
+ void glRotatef(final float pAngle, final float pX, final float pY, final float pZ) 
+ void glScalef(final float pScaleX, final float pScaleY, final float pScaleZ) 
+ void glSkewf(final float pSkewX, final float pSkewY) 
+ void glOrthof(final float pLeft, final float pRight, final float pBottom, final float pTop, final float pZNear, final float pZFar) 
+ void glPushMatrix() 
+ void glPopMatrix() 
+ void reset() 
- {static} void setSkewM(final float[] pMatrixStack, final int pOffset, final float pSkewX, final float pSkewY) 
 
}
class org.andengine.opengl.util.GLState {
 + String getVersion() 
+ String getRenderer() 
+ String getExtensions() 
+ int getMaximumVertexAttributeCount() 
+ int getMaximumVertexShaderUniformVectorCount() 
+ int getMaximumFragmentShaderUniformVectorCount() 
+ int getMaximumTextureUnits() 
+ int getMaximumTextureSize() 
+ void reset(final RenderOptions pRenderOptions, final ConfigChooser pConfigChooser, final EGLConfig pEGLConfig) 
+ boolean isScissorTestEnabled() 
+ boolean enableScissorTest() 
+ boolean disableScissorTest() 
+ boolean setScissorTestEnabled(final boolean pEnabled) 
+ boolean isBlendEnabled() 
+ boolean enableBlend() 
+ boolean disableBlend() 
+ boolean setBlendEnabled(final boolean pEnabled) 
+ boolean isCullingEnabled() 
+ boolean enableCulling() 
+ boolean disableCulling() 
+ boolean setCullingEnabled(final boolean pEnabled) 
+ boolean isDitherEnabled() 
+ boolean enableDither() 
+ boolean disableDither() 
+ boolean setDitherEnabled(final boolean pEnabled) 
+ boolean isDepthTestEnabled() 
+ boolean enableDepthTest() 
+ boolean disableDepthTest() 
+ boolean setDepthTestEnabled(final boolean pEnabled) 
+ int generateBuffer() 
+ int generateArrayBuffer(final int pSize, final int pUsage) 
+ void bindArrayBuffer(final int pHardwareBufferID) 
+ void deleteArrayBuffer(final int pHardwareBufferID) 
+ int generateIndexBuffer(final int pSize, final int pUsage) 
+ void bindIndexBuffer(final int pHardwareBufferID) 
+ void deleteIndexBuffer(final int pHardwareBufferID) 
+ int generateFramebuffer() 
+ void bindFramebuffer(final int pFramebufferID) 
+ int getFramebufferStatus() 
+ void checkFramebufferStatus() 
+ int getActiveFramebuffer() 
+ void deleteFramebuffer(final int pHardwareFramebufferID) 
+ void useProgram(final int pShaderProgramID) 
+ void deleteProgram(final int pShaderProgramID) 
+ int generateTexture() 
+ boolean isTexture(final int pHardwareTextureID) 
+ int getActiveTexture() 
+ void activeTexture(final int pGLActiveTexture) 
+ void bindTexture(final int pHardwareTextureID) 
+ void deleteTexture(final int pHardwareTextureID) 
+ void blendFunction(final int pSourceBlendMode, final int pDestinationBlendMode) 
+ void lineWidth(final float pLineWidth) 
+ void pushModelViewGLMatrix() 
+ void popModelViewGLMatrix() 
+ void loadModelViewGLMatrixIdentity() 
+ void translateModelViewGLMatrixf(final float pX, final float pY, final float pZ) 
+ void rotateModelViewGLMatrixf(final float pAngle, final float pX, final float pY, final float pZ) 
+ void scaleModelViewGLMatrixf(final float pScaleX, final float pScaleY, final int pScaleZ) 
+ void skewModelViewGLMatrixf(final float pSkewX, final float pSkewY) 
+ void orthoModelViewGLMatrixf(final float pLeft, final float pRight, final float pBottom, final float pTop, final float pZNear, final float pZFar) 
+ void pushProjectionGLMatrix() 
+ void popProjectionGLMatrix() 
+ void loadProjectionGLMatrixIdentity() 
+ void translateProjectionGLMatrixf(final float pX, final float pY, final float pZ) 
+ void rotateProjectionGLMatrixf(final float pAngle, final float pX, final float pY, final float pZ) 
+ void scaleProjectionGLMatrixf(final float pScaleX, final float pScaleY, final float pScaleZ) 
+ void skewProjectionGLMatrixf(final float pSkewX, final float pSkewY) 
+ void orthoProjectionGLMatrixf(final float pLeft, final float pRight, final float pBottom, final float pTop, final float pZNear, final float pZFar) 
+ float[] getModelViewGLMatrix() 
+ float[] getProjectionGLMatrix() 
+ float[] getModelViewProjectionGLMatrix() 
+ void resetModelViewGLMatrixStack() 
+ void resetProjectionGLMatrixStack() 
+ void resetGLMatrixStacks() 
+ void glTexImage2D(final int pTarget, final int pLevel, final Bitmap pBitmap, final int pBorder, final PixelFormat pPixelFormat) 
+ void glTexSubImage2D(final int pTarget, final int pLevel, final int pX, final int pY, final Bitmap pBitmap, final PixelFormat pPixelFormat) 
+ void flush() 
+ void finish() 
+ int getInteger(final int pAttribute) 
+ int getError() 
+ void checkError() 
+ void clearError() 
	- String mVersion;
	- String mRenderer;
	- String mExtensions;
	- int mMaximumVertexAttributeCount;
	- int mMaximumVertexShaderUniformVectorCount;
	- int mMaximumFragmentShaderUniformVectorCount;
	- int mMaximumTextureSize;
	- int mMaximumTextureUnits;
 
}
class org.andengine.opengl.util.VertexUtils {
 + {static} float getVertex(final float[] pVertices, final int pVertexOffset, final int pVertexStride, final int pVertexIndex) 
 
}
class org.andengine.opengl.util.criteria.AndroidVersionCodeGLCriteria {
 # int getActualCriteria(final GLState pGLState) 
 
}
class org.andengine.opengl.util.criteria.BuildModelGLCriteria {
 # String getActualCriteria(final GLState pGLState) 
 
}
class org.andengine.opengl.util.criteria.GLExtensionsGLCriteria {
 # String getActualCriteria(final GLState pGLState) 
 
}
class org.andengine.opengl.util.criteria.GLRendererGLCriteria {
 # String getActualCriteria(final GLState pGLState) 
 
}
class org.andengine.opengl.util.criteria.GLVersionGLCriteria {
 # String getActualCriteria(final GLState pGLState) 
 
}
class org.andengine.opengl.util.criteria.LogicalAndGLCriteria {
 + boolean isMet(final GLState pGLState) 
	- final IGLCriteria[] mGLCriterias;
 
}
class org.andengine.opengl.util.criteria.LogicalOrGLCriteria {
 + boolean isMet(final GLState pGLState) 
	- final IGLCriteria[] mGLCriterias;
 
}
class org.andengine.opengl.vbo.HighPerformanceVertexBufferObject {
 + float[] getBufferData() 
+ int getHeapMemoryByteSize() 
+ int getNativeHeapMemoryByteSize() 
# void onBufferData() 
	# final float[] mBufferData;
	# final FloatBuffer mFloatBuffer;
 
}
class org.andengine.opengl.vbo.LowMemoryVertexBufferObject {
 + FloatBuffer getFloatBuffer() 
+ int getHeapMemoryByteSize() 
+ int getNativeHeapMemoryByteSize() 
# void onBufferData() 
	# final FloatBuffer mFloatBuffer;
 
}
class org.andengine.opengl.vbo.VertexBufferObjectManager {
 + synchronized int getHeapMemoryByteSize() 
+ synchronized int getNativeHeapMemoryByteSize() 
+ synchronized int getGPUHeapMemoryByteSize() 
+ void onCreate() 
+ synchronized void onDestroy() 
+ synchronized void onVertexBufferObjectLoaded(final IVertexBufferObject pVertexBufferObject) 
+ synchronized void onUnloadVertexBufferObject(final IVertexBufferObject pVertexBufferObject) 
+ synchronized void onReload() 
+ synchronized void updateVertexBufferObjects(final GLState pGLState) 
 
}
class org.andengine.opengl.vbo.attribute.VertexBufferObjectAttribute {
 + int getLocation() 
+ String getName() 
+ int getSize() 
+ int getType() 
+ boolean isNormalized() 
+ int getOffset() 
+ void glVertexAttribPointer(final int pStride) 
~	/* package */ final int mLocation;
~	/* package */ final String mName;
~	/* package */ final int mSize;
~	/* package */ final int mType;
~	/* package */ final boolean mNormalized;
~	/* package */ final int mOffset;
 
}
class org.andengine.opengl.vbo.attribute.VertexBufferObjectAttributeFix {
 + void glVertexAttribPointer(final int pStride) 
 
}
class org.andengine.opengl.vbo.attribute.VertexBufferObjectAttributes {
 + void glVertexAttribPointers() 
	- final int mStride;
	- final VertexBufferObjectAttribute[] mVertexBufferObjectAttributes;
 
}
class org.andengine.opengl.vbo.attribute.VertexBufferObjectAttributesBuilder {
 + VertexBufferObjectAttributesBuilder add(final int pLocation, final String pName, final int pSize, final int pType, final boolean pNormalized) 
+ VertexBufferObjectAttributes build() 
	- {static} final boolean WORAROUND_GLES2_GLVERTEXATTRIBPOINTER_MISSING;
	- int mIndex;
	- final VertexBufferObjectAttribute[] mVertexBufferObjectAttributes;
	- int mOffset;
 
}
class org.andengine.opengl.view.ConfigChooser {
 + boolean isMultiSampling() 
+ boolean isCoverageMultiSampling() 
+ int getRedSize() 
+ int getGreenSize() 
+ int getBlueSize() 
+ int getAlphaSize() 
+ int getDepthSize() 
+ int getStencilSize() 
+ EGLConfig chooseConfig(final EGL10 pEGL, final EGLDisplay pEGLDisplay) 
- EGLConfig chooseConfig(final EGL10 pEGL, final EGLDisplay pEGLDisplay, final ConfigChooserMatcher pConfigChooserMatcher) 
- {static} int getEGLConfigCount(final EGL10 pEGL, final EGLDisplay pEGLDisplay, final int[] pEGLConfigAttributes) 
- EGLConfig findEGLConfig(final EGL10 pEGL, final EGLDisplay pEGLDisplay, final int[] pEGLConfigAttributes, final int pEGLConfigCount, final ConfigChooserMatcher pConfigChooserMatcher) 
- EGLConfig findEGLConfig(final EGL10 pEGL, final EGLDisplay pEGLDisplay, final EGLConfig[] pEGLConfigs, final ConfigChooserMatcher pConfigChooserMatcher) 
- {static} int getConfigAttrib(final EGL10 pEGL, final EGLDisplay pEGLDisplay, final EGLConfig pEGLConfig, final int pAttribute, final int pDefaultValue) 
+ boolean matches(final int pRedSize, final int pGreenSize, final int pBlueSize, final int pAlphaSize, final int pDepthSize, final int pStencilSize) 
+ {abstract} boolean matches(final int pRedSize, final int pGreenSize, final int pBlueSize, final int pAlphaSize, final int pDepthSize, final int pStencilSize)
	- final boolean mMultiSamplingRequested;
	- boolean mMultiSampling;
	- boolean mCoverageMultiSampling;
 
}
class org.andengine.opengl.view.EngineRenderer {
 + void onSurfaceCreated(final GL10 pGL, final EGLConfig pEGLConfig) 
+ void onSurfaceChanged(final GL10 pGL, final int pWidth, final int pHeight) 
+ void onDrawFrame(final GL10 pGL) 
~	final Engine mEngine;
~	final ConfigChooser mConfigChooser;
~	final boolean mMultiSampling;
~	final IRendererListener mRendererListener;
~	final GLState mGLState;
 
}
class org.andengine.opengl.view.RenderSurfaceView {
 + ConfigChooser getConfigChooser() 
# void onMeasure(final int pWidthMeasureSpec, final int pHeightMeasureSpec) 
+ void setMeasuredDimensionProxy(final int pMeasuredWidth, final int pMeasuredHeight) 
+ void setRenderer(final Engine pEngine, final IRendererListener pRendererListener) 
	- EngineRenderer mEngineRenderer;
	- ConfigChooser mConfigChooser;
 
}
class org.andengine.ui.dialog.StringInputDialogBuilder {
 # String generateResult(final String pInput) 
 
}
class org.andengine.util.ActivityUtils {
 + {static} void requestFullscreen(final Activity pActivity) 
+ {static} void setScreenBrightness(final Activity pActivity, final float pScreenBrightness) 
+ {static} void keepScreenOn(final Activity pActivity) 
+ {static} <T> void doAsync(final Context pContext, final int pTitleResourceID, final int pMessageResourceID, final Callable<T> pCallable, final Callback<T> pCallback) 
+ {static} <T> void doAsync(final Context pContext, final CharSequence pTitle, final CharSequence pMessage, final Callable<T> pCallable, final Callback<T> pCallback) 
+ {static} <T> void doAsync(final Context pContext, final int pTitleResourceID, final int pMessageResourceID, final Callable<T> pCallable, final Callback<T> pCallback, final boolean pCancelable) 
+ {static} <T> void doAsync(final Context pContext, final CharSequence pTitle, final CharSequence pMessage, final Callable<T> pCallable, final Callback<T> pCallback, final boolean pCancelable) 
+ {static} <T> void doAsync(final Context pContext, final int pTitleResourceID, final int pMessageResourceID, final Callable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
+ {static} <T> void doAsync(final Context pContext, final CharSequence pTitle, final CharSequence pMessage, final Callable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
+ {static} <T> void doAsync(final Context pContext, final int pTitleResourceID, final int pMessageResourceID, final Callable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback, final boolean pCancelable) 
+ {static} <T> void doAsync(final Context pContext, final CharSequence pTitle, final CharSequence pMessage, final Callable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback, final boolean pCancelable) 
+ T doInBackground(final Void... params) 
+ void onPostExecute(final T result) 
+ {static} <T> void doProgressAsync(final Context pContext, final int pTitleResourceID, final int pIconResourceID, final ProgressCallable<T> pCallable, final Callback<T> pCallback) 
+ {static} <T> void doProgressAsync(final Context pContext, final CharSequence pTitle, final int pIconResourceID, final ProgressCallable<T> pCallable, final Callback<T> pCallback) 
+ {static} <T> void doProgressAsync(final Context pContext, final int pTitleResourceID, final int pIconResourceID, final ProgressCallable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
+ {static} <T> void doProgressAsync(final Context pContext, final CharSequence pTitle, final int pIconResourceID, final ProgressCallable<T> pCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
+ void onProgressUpdate(final Integer... values) 
+ {static} <T> void doAsync(final Context pContext, final int pTitleResourceID, final int pMessageResourceID, final AsyncCallable<T> pAsyncCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
+ {static} <T> void doAsync(final Context pContext, final CharSequence pTitle, final CharSequence pMessage, final AsyncCallable<T> pAsyncCallable, final Callback<T> pCallback, final Callback<Exception> pExceptionCallback) 
 
}
class org.andengine.util.BetaUtils {
 + {static} boolean finishWhenExpired(final Activity pActivity, final GregorianCalendar pExpirationDate, final int pTitleResourceID, final int pMessageResourceID) 
+ {static} boolean finishWhenExpired(final Activity pActivity, final GregorianCalendar pExpirationDate, final int pTitleResourceID, final int pMessageResourceID, final Intent pOkIntent, final Intent pCancelIntent) 
+ void onClick(final DialogInterface pDialog, final int pWhich) 
 
}
class org.andengine.util.DialogUtils {
 + {static} void keepScreenOn(final Dialog pDialog) 
 
}
class org.andengine.util.FileUtils {
 + {static} void copyToExternalStorage(final Context pContext, final int pSourceResourceID, final String pFilename) 
+ {static} void copyToInternalStorage(final Context pContext, final int pSourceResourceID, final String pFilename) 
+ {static} void copyToExternalStorage(final Context pContext, final String pSourceAssetPath, final String pFilename) 
+ {static} void copyToInternalStorage(final Context pContext, final String pSourceAssetPath, final String pFilename) 
- {static} void copyToInternalStorage(final Context pContext, final InputStream pInputStream, final String pFilename) 
+ {static} void copyToExternalStorage(final InputStream pInputStream, final String pFilePath) 
+ {static} void copyToExternalStorage(final Context pContext, final InputStream pInputStream, final String pFilePath) 
+ {static} boolean isFileExistingOnExternalStorage(final String pFilePath) 
+ {static} boolean isFileExistingOnExternalStorage(final Context pContext, final String pFilePath) 
+ {static} boolean isDirectoryExistingOnExternalStorage(final Context pContext, final String pDirectory) 
+ {static} boolean ensureDirectoriesExistOnExternalStorage(final Context pContext, final String pDirectory) 
+ {static} InputStream openOnExternalStorage(final String pFilePath) 
+ {static} InputStream openOnExternalStorage(final Context pContext, final String pFilePath) 
+ {static} String[] getDirectoryListOnExternalStorage(final Context pContext, final String pFilePath) 
+ {static} String[] getDirectoryListOnExternalStorage(final Context pContext, final String pFilePath, final FilenameFilter pFilenameFilter) 
+ {static} String getAbsolutePathOnInternalStorage(final Context pContext, final String pFilePath) 
+ {static} String getAbsolutePathOnExternalStorage(final String pFilePath) 
+ {static} String getAbsolutePathOnExternalStorage(final Context pContext, final String pFilePath) 
+ {static} boolean isExternalStorageWriteable() 
+ {static} boolean isExternalStorageReadable() 
+ {static} void copyFile(final File pSourceFile, final File pDestinationFile) 
+ {static} boolean deleteDirectory(final File pFileOrDirectory) 
 
}
class org.andengine.util.ProbabilityGenerator {
 + void add(final float pFactor, final T ... pElements)
+ T next() 
+ void clear() 
+ T getReturnValue() 
	- float mProbabilitySum;
		+ final float mFactor;
		+ final T[] mData;
 
}
class org.andengine.util.SAXUtils {
 + {static} final String getAttribute(final Attributes pAttributes, final String pAttributeName, final String pDefaultValue) 
+ {static} final String getAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final boolean getBooleanAttribute(final Attributes pAttributes, final String pAttributeName, final boolean pDefaultValue) 
+ {static} final boolean getBooleanAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final byte getByteAttribute(final Attributes pAttributes, final String pAttributeName, final byte pDefaultValue) 
+ {static} final byte getByteAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final short getShortAttribute(final Attributes pAttributes, final String pAttributeName, final short pDefaultValue) 
+ {static} final short getShortAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final int getIntAttribute(final Attributes pAttributes, final String pAttributeName, final int pDefaultValue) 
+ {static} final int getIntAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final long getLongAttribute(final Attributes pAttributes, final String pAttributeName, final long pDefaultValue) 
+ {static} final long getLongAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final float getFloatAttribute(final Attributes pAttributes, final String pAttributeName, final float pDefaultValue) 
+ {static} final float getFloatAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final double getDoubleAttribute(final Attributes pAttributes, final String pAttributeName, final double pDefaultValue) 
+ {static} final double getDoubleAttributeOrThrow(final Attributes pAttributes, final String pAttributeName) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final boolean pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final byte pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final short pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final int pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final long pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final float pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final double pValue) 
+ {static} final void appendAttribute(final StringBuilder pStringBuilder, final String pName, final String pValue) 
 
}
class org.andengine.util.SocketUtils {
 + {static} final void closeSocket(final DatagramSocket pDatagramSocket) 
+ {static} final void closeSocket(final Socket pSocket) 
+ {static} final void closeSocket(final ServerSocket pServerSocket) 
 
}
class org.andengine.util.StreamUtils {
 + {static} final String readFully(final InputStream pInputStream) 
+ {static} final byte[] streamToBytes(final InputStream pInputStream) 
+ {static} final byte[] streamToBytes(final InputStream pInputStream, final int pReadLimit) 
+ {static} final void streamToBytes(final InputStream pInputStream, final int pByteLimit, final byte[] pData) 
+ {static} final void streamToBytes(final InputStream pInputStream, final int pByteLimit, final byte[] pData, final int pOffset) 
+ {static} final void copy(final InputStream pInputStream, final OutputStream pOutputStream) 
+ {static} final void copy(final InputStream pInputStream, final byte[] pData) 
+ {static} final void copy(final InputStream pInputStream, final ByteBuffer pByteBuffer) 
+ {static} final void copy(final InputStream pInputStream, final OutputStream pOutputStream, final int pByteLimit) 
+ {static} final boolean copyAndClose(final InputStream pInputStream, final OutputStream pOutputStream) 
+ {static} final void close(final Closeable pCloseable) 
+ {static} final void flushCloseStream(final OutputStream pOutputStream) 
+ {static} final void flushCloseWriter(final Writer pWriter) 
 
}
class org.andengine.util.TextUtils {
 + {static} final CharSequence padFront(final CharSequence pText, final char pPadChar, final int pLength) 
+ {static} final int countOccurrences(final CharSequence pText, final char pCharacter) 
+ {static} final ArrayList<CharSequence> split(final CharSequence pText, final char pCharacter) 
+ {static} final <L extends List<CharSequence>> L split(final CharSequence pText, final char pCharacter, final L pResult) 
+ {static} final String formatStackTrace(final StackTraceElement pStackTraceElement) 
+ {static} final String formatStackTrace(final StackTraceElement[] pStackTraceElements) 
+ {static} int countCharacters(final List<CharSequence> pTexts) 
+ {static} int countCharacters(final List<CharSequence> pTexts, final boolean pIgnoreWhitespaces) 
 
}
class org.andengine.util.ThreadUtils {
 + {static} void dumpCurrentThreadInfo() 
+ {static} void dumpCurrentThreadInfo(final DebugLevel pDebugLevel) 
- {static} void dumpCurrentThreadInfo(final DebugLevel pDebugLevel, final StackTraceElement pCaller) 
 
}
class org.andengine.util.TimeUtils {
 + {static} final String formatSeconds(final int pSecondsTotal) 
+ {static} final String formatSeconds(final int pSecondsTotal, final StringBuilder pStringBuilder) 
 
}
class org.andengine.util.ViewUtils {
 + {static} final View inflate(final Context pContext, final int pLayoutID)
+ {static} final View inflate(final Context pContext, final int pLayoutID, final ViewGroup pViewGroup)
 
}
class org.andengine.util.adt.array.ArrayUtils {
 + {static} final byte random(final byte[] pArray) 
+ {static} final short random(final short[] pArray) 
+ {static} final int random(final int[] pArray) 
+ {static} final long random(final long[] pArray) 
+ {static} final float random(final float[] pArray) 
+ {static} final double random(final double[] pArray) 
+ {static} final <T> T random(final T[] pArray) 
+ {static} final void reverse(final byte[] pArray) 
+ {static} final void reverse(final short[] pArray) 
+ {static} final void reverse(final int[] pArray) 
+ {static} final void reverse(final long[] pArray) 
+ {static} final void reverse(final float[] pArray) 
+ {static} final void reverse(final double[] pArray) 
+ {static} final void reverse(final Object[] pArray) 
+ {static} final boolean equals(final byte[] pArrayA, final int pOffsetA, final byte[] pArrayB, final int pOffsetB, final int pLength) 
+ {static} final byte[] toByteArray(final List<Byte> pItems) 
+ {static} final char[] toCharArray(final List<Character> pItems) 
+ {static} final short[] toShortArray(final List<Short> pItems) 
+ {static} final int[] toIntArray(final List<Integer> pItems) 
+ {static} final long[] toLongArray(final List<Long> pItems) 
+ {static} final float[] toFloatArray(final List<Float> pItems) 
+ {static} final double[] toDoubleArray(final List<Double> pItems) 
+ {static} final boolean contains(final byte[] pItems, final byte pItem) 
+ {static} final boolean contains(final char[] pItems, final char pItem) 
+ {static} final boolean contains(final short[] pItems, final short pItem) 
+ {static} final boolean contains(final int[] pItems, final int pItem) 
+ {static} final boolean contains(final long[] pItems, final long pItem) 
+ {static} final boolean contains(final float[] pItems, final float pItem) 
+ {static} final boolean contains(final double[] pItems, final double pItem) 
+ {static} <T> T[] join(final Class<T> pClass, final T[]... pArrays) 
+ {static} int idealByteArraySize(final int pSize) 
+ {static} int idealBooleanArraySize(final int pSize) 
+ {static} int idealShortArraySize(final int pSize) 
+ {static} int idealCharArraySize(final int pSize) 
+ {static} int idealIntArraySize(final int pSize) 
+ {static} int idealFloatArraySize(final int pSize) 
+ {static} int idealDoubleArraySize(final int pSize) 
+ {static} int idealLongArraySize(final int pSize) 
+ {static} int idealObjectArraySize(final int pSize) 
 
}
class org.andengine.util.adt.bit.BitVector {
 + int getCapacity() 
+ boolean getBit(final int pPosition) 
+ byte getByte(final int pPosition) 
+ short getShort(final int pPosition) 
+ int getInt(final int pPosition) 
+ long getLong(final int pPosition) 
+ long getBits(final int pPosition, final int pLength) 
+ String toString() 
+ byte[] toByteArray() 
	- final int mCapacity;
	- final long[] mData;
~		final int dataCapacity;
~		final long data;
 
}
class org.andengine.util.adt.bounds.BoundsSplit {
  
}.BoundsSplitException
class org.andengine.util.adt.bounds.FloatBounds {
 + float getXMin() 
+ float getYMin() 
+ float getXMax() 
+ float getYMax() 
+ void set(final float pX, final float pY) 
+ void set(final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
+ boolean contains(final float pX, final float pY) 
	- float mXMin;
	- float mYMin;
	- float mXMax;
	- float mYMax;
 
}
class org.andengine.util.adt.bounds.IntBounds {
 + int getXMin() 
+ int getYMin() 
+ int getXMax() 
+ int getYMax() 
+ void set(final int pX, final int pY) 
+ void set(final int pXMin, final int pYMin, final int pXMax, final int pYMax) 
+ boolean contains(final int pX, final int pY) 
	- int mXMin;
	- int mYMin;
	- int mXMax;
	- int mYMax;
 
}
class org.andengine.util.adt.cache.IntLRUCache {
 # IntLRUCacheValueHolder<V> onAllocatePoolItem() 
# void onHandleRecycleItem(final IntLRUCacheValueHolder<V> pIntLRUCacheValueHolder) 
+ int getCapacity() 
+ int getSize() 
+ boolean isEmpty() 
+ V put(final int pKey, final V pValue) 
+ V get(final int pKey) 
+ void clear() 
# IntLRUCacheQueueNode onAllocatePoolItem() 
# void onHandleRecycleItem(final IntLRUCacheQueueNode pIntLRUCacheQueueNode) 
+ IntLRUCacheQueueNode add(final int pKey) 
- IntLRUCacheQueueNode add(final IntLRUCacheQueueNode pIntLRUCacheQueueNode) 
+ int poll() 
+ void moveToTail(final IntLRUCacheQueueNode pIntLRUCacheQueueNode) 
	- final int mCapacity;
	- int mSize;
	- final SparseArray<IntLRUCacheValueHolder<V>> mSparseArray;
	- final IntLRUCacheQueue mIntLRUCacheQueue;
		- IntLRUCacheQueueNode mHead;
		- IntLRUCacheQueueNode mTail;
 
}
class org.andengine.util.adt.cache.LRUCache {
 # LRUCacheValueHolder<K, V> onAllocatePoolItem() 
# void onHandleRecycleItem(final LRUCacheValueHolder<K, V> pLRUCacheValueHolder) 
+ int getCapacity() 
+ int getSize() 
+ boolean isEmpty() 
+ V put(final K pKey, final V pValue) 
+ V get(final K pKey) 
+ void clear() 
# LRUCacheQueueNode<K> onAllocatePoolItem() 
# void onHandleRecycleItem(final LRUCacheQueueNode<K> pLRUCacheQueueNode) 
+ LRUCacheQueueNode<K> add(final K pKey) 
- LRUCacheQueueNode<K> add(final LRUCacheQueueNode<K> pLRUCacheQueueNode) 
+ K poll() 
+ void moveToTail(final LRUCacheQueueNode<K> pLRUCacheQueueNode) 
	- final int mCapacity;
	- int mSize;
	- final HashMap<K, LRUCacheValueHolder<K, V>> mMap;
	- final LRUCacheQueue<K> mLRUCacheQueue;
		- LRUCacheQueueNode<K> mHead;
		- LRUCacheQueueNode<K> mTail;
 
}
class org.andengine.util.adt.cache.concurrent.SynchronizedIntLRUCache {
 + synchronized int getSize() 
+ synchronized boolean isEmpty() 
+ synchronized V put(final int pKey, final V pValue) 
+ synchronized V get(final int pKey) 
+ synchronized void clear() 
 
}
class org.andengine.util.adt.cache.concurrent.SynchronizedLRUCache {
 + synchronized int getSize() 
+ synchronized boolean isEmpty() 
+ synchronized V put(final K pKey, final V pValue) 
+ synchronized V get(final K pKey) 
+ synchronized void clear() 
 
}
class org.andengine.util.adt.data.DataUtils {
 + {static} final int unsignedByteToInt(final byte pByte) 
 
}
class org.andengine.util.adt.io.in.AssetInputStreamOpener {
 + InputStream open() 
	- final AssetManager mAssetManager;
	- final String mAssetPath;
 
}
class org.andengine.util.adt.io.in.ByteArrayInputStreamOpener {
 + InputStream open() 
	- final byte[] mBytes;
	- final int mOffset;
	- final int mLength;
 
}
class org.andengine.util.adt.io.in.ResourceInputStreamOpener {
 + InputStream open() 
	- final Resources mResources;
	- final int mResourceID;
 
}
class org.andengine.util.adt.io.out.ByteBufferOutputStream {
 + void write(final int pByte) 
+ void write(final byte pData[], final int pOffset, final int pLength) 
+ void close() 
- void ensureCapacity(final int pDesiredCapacity) 
- void grow(final int pDesiredCapacity) 
+ ByteBuffer toByteBuffer() 
	# final int mMaximumGrow;
	# byte mData[];
	# int mCount;
 
}
class org.andengine.util.adt.list.CircularList {
 + boolean isEmpty() 
+ void add(final T pItem) 
+ T get(final int pIndex) 
+ void set(final int pIndex, final T pItem) 
+ int indexOf(final T pItem) 
+ void add(final int pIndex, final T pItem) 
+ T removeFirst() 
+ T removeLast() 
+ boolean remove(final T pItem) 
+ T remove(final int pIndex) 
+ int size() 
+ void clear() 
- void ensureCapacity() 
- int encodeToInternalIndex(final int pIndex) 
	- Object[] mItems;
	- int mHead;
	- int mSize;
 
}
class org.andengine.util.adt.list.FloatArrayList {
 + boolean isEmpty() 
+ float get(final int pIndex) 
+ void add(final float pItem) 
+ void add(final int pIndex, final float pItem) 
+ float remove(final int pIndex) 
+ int size() 
+ void clear() 
+ float[] toArray() 
- void ensureCapacity(final int pCapacity) 
	- float[] mItems;
	- int mSize;
 
}
class org.andengine.util.adt.list.IntArrayList {
 + boolean isEmpty() 
+ float get(final int pIndex) 
+ void add(final int pItem) 
+ void add(final int pIndex, final int pItem) 
+ float remove(final int pIndex) 
+ int size() 
+ void clear() 
+ int[] toArray() 
- void ensureCapacity(final int pCapacity) 
	- int[] mItems;
	- int mSize;
 
}
class org.andengine.util.adt.list.ListUtils {
 + {static} final <T> IQueue<T> synchronizedQueue(final IQueue<T> pQueue) 
+ {static} final <T> T random(final List<T> pList) 
+ {static} <T> void swap(final List<T> pItems, final int pIndexA, final int pIndexB) 
+ {static} <T> void swap(final IList<T> pItems, final int pIndexA, final int pIndexB) 
+ {static} final int encodeInsertionIndex(final int pIndex) 
 
}
class org.andengine.util.adt.list.LongArrayList {
 + boolean isEmpty() 
+ float get(final int pIndex) 
+ void add(final long pItem) 
+ void add(final int pIndex, final long pItem) 
+ float remove(final int pIndex) 
+ int size() 
+ void clear() 
+ long[] toArray() 
- void ensureCapacity(final int pCapacity) 
	- long[] mItems;
	- int mSize;
 
}
class org.andengine.util.adt.list.ShiftList {
 + boolean isEmpty() 
+ T get(final int pIndex) 
+ void set(final int pIndex, final T pItem) 
+ int indexOf(final T pItem) 
+ T peek() 
+ T poll() 
+ void enter(final T pItem) 
+ void enter(final int pIndex, final T pItem) 
- void enterShiftingRight(final int pIndex, final T pItem, final int size) 
- void enterShiftingLeft(final int pIndex, final T pItem) 
+ void add(final T pItem) 
+ void add(final int pIndex, final T pItem) 
+ T removeFirst() 
+ T removeLast() 
+ boolean remove(final T pItem) 
+ T remove(final int pIndex) 
+ int size() 
+ void clear() 
+ void shift() 
- void ensureShiftableRight() 
- void ensureShiftableLeft() 
	# Object[] mItems;
	# int mHead;
	# int mTail;
 
}
class org.andengine.util.adt.list.SmartList {
 + void addFirst(final T pItem) 
+ void addLast(final T pItem) 
+ T getFirst() 
+ T getLast() 
+ T get(final IMatcher<T> pMatcher) 
+ T removeFirst() 
+ T removeLast() 
+ boolean remove(final T pItem, final ParameterCallable<T> pParameterCallable) 
+ T remove(final IMatcher<T> pMatcher) 
+ T remove(final IMatcher<T> pMatcher, final ParameterCallable<T> pParameterCallable) 
+ boolean removeAll(final IMatcher<T> pMatcher) 
+ boolean removeAll(final IMatcher<T> pMatcher, final ParameterCallable<T> pParameterCallable) 
+ void clear(final ParameterCallable<T> pParameterCallable) 
+ int indexOf(final IMatcher<T> pMatcher) 
+ int lastIndexOf(final IMatcher<T> pMatcher) 
+ ArrayList<T> query(final IMatcher<T> pMatcher) 
+ <L extends List<T>> L query(final IMatcher<T> pMatcher, final L pResult) 
+ <S extends T> ArrayList<S> queryForSubclass(final IMatcher<T> pMatcher) 
+ <L extends List<S>, S extends T> L queryForSubclass(final IMatcher<T> pMatcher, final L pResult) 
+ void call(final ParameterCallable<T> pParameterCallable) 
+ void call(final IMatcher<T> pMatcher, final ParameterCallable<T> pParameterCallable) 
 
}
class org.andengine.util.adt.list.SortedList {
 + boolean isEmpty() 
+ T get(final int pIndex) 
+ void set(final int pIndex, final T pItem) 
+ int indexOf(final T pItem) 
+ void add(final int pIndex, final T pItem) 
+ void add(final T pItem) 
+ T removeFirst() 
+ T removeLast() 
+ boolean remove(final T pItem) 
+ T remove(final int pIndex) 
+ int size() 
+ void clear() 
- int binarySearch(final T pItem, final boolean pReturnSequenceEndIfNoEqualItemFound) 
- int binarySearch(final int pStart, final int pEnd, final T pItem) 
- int scanForEqualItem(final int pStart, final int pEnd, final int pGuess, final T pItem, final boolean pReturnSequenceEndIfNoEqualItemFound) 
	- final IList<T> mList;
 
}
class org.andengine.util.adt.list.UniqueList {
 + boolean isEmpty() 
+ T get(final int pIndex) 
+ void set(final int pIndex, final T pItem) 
+ int indexOf(final T pItem) 
+ void add(final int pIndex, final T pItem) 
+ void add(final T pItem) 
+ T removeFirst() 
+ T removeLast() 
+ boolean remove(final T pItem) 
+ T remove(final int pIndex) 
+ int size() 
+ void clear() 
	- final IList<T> mList;
 
}
class org.andengine.util.adt.list.concurrent.SynchronizedList {
 + synchronized boolean isEmpty() 
+ synchronized T get(final int pIndex) 
+ synchronized void set(final int pIndex, final T pItem) 
+ synchronized int indexOf(final T pItem) 
+ synchronized void add(final T pItem) 
+ synchronized void add(final int pIndex, final T pItem) 
+ synchronized T removeFirst() 
+ synchronized T removeLast() 
+ synchronized boolean remove(final T pItem) 
+ synchronized T remove(final int pIndex) 
+ synchronized int size() 
+ synchronized void clear() 
	# final IList<T> mList;
 
}
class org.andengine.util.adt.map.Library {
 + T get(final int pID) 
+ void put(final int pID, final T pItem) 
+ void remove(final int pID) 
+ void clear() 
	# final SparseArray<T> mItems;
 
}
class org.andengine.util.adt.map.LongSparseArray {
 + long[] getKeys() 
+ void setValues(long[] keys, E uniqueValue) 
+ E get(long key) 
+ E get(long key, E valueIfKeyNotFound) 
+ void delete(long key) 
+ void remove(long key) 
- void gc() 
+ void put(long key, E value) 
+ int size() 
+ long keyAt(int index) 
+ E valueAt(int index) 
+ void setValueAt(int index, E value) 
+ int indexOfKey(long key) 
+ int indexOfValue(E value) 
+ void clear() 
+ void append(long key, E value) 
- {static} int binarySearch(long[] a, int start, int len, long key) 
- void checkIntegrity() 
    - long[] mKeys;
    - Object[] mValues;
    - int mSize;
 
}
class org.andengine.util.adt.map.MultiKey {
 + K[] getKeys() 
+ boolean equals(final Object pOther) 
+ {static} int hash(final Object ... pKeys) 
+ int hashCode() 
+ String toString() 
+ K getKey(final int pIndex) 
+ int size() 
	- final K[] mKeys;
	- final int mCachedHashCode;
 
}
class org.andengine.util.adt.map.MultiKeyHashMap {
 + V get(final K ... pKeys) 
- boolean isEqualKey(final K[] pKeysA, final K[] pKeysB) 
 
}
class org.andengine.util.adt.map.SparseArrayUtils {
 + {static} final String toString(final SparseArray<?> pSparseArray) 
+ {static} final String toString(final SparseIntArray pSparseIntArray) 
+ {static} final String toString(final SparseBooleanArray pSparseBooleanArray) 
+ {static} final String toString(final LongSparseArray<?> pLongSparseArray) 
 
}
class org.andengine.util.adt.pool.EntityDetachRunnablePoolItem {
 + void setEntity(final IEntity pEntity) 
+ void setCallback(final Callback<IEntity> pCallback) 
+ void run() 
	# IEntity mEntity;
	# Callback<IEntity> mCallback;
 
}
class org.andengine.util.adt.pool.EntityDetachRunnablePoolUpdateHandler {
 # EntityDetachRunnablePoolItem onAllocatePoolItem() 
+ void scheduleDetach(final IEntity pEntity) 
+ void scheduleDetach(final IEntity pEntity, final Callback<IEntity> pCallback) 
 
}
class org.andengine.util.adt.pool.MultiPool {
 + void registerPool(final int pID, final GenericPool<T> pPool) 
+ T obtainPoolItem(final int pID) 
+ void recyclePoolItem(final int pID, final T pItem) 
 
}
class org.andengine.util.adt.queue.CircularQueue {
 + T peek() 
+ T poll() 
+ void enter(final T pItem) 
+ void enter(final int pIndex, final T pItem) 
 
}
class org.andengine.util.adt.queue.ShiftQueue {
 + T peek() 
+ T poll() 
+ void enter(final T pItem) 
+ void enter(final int pIndex, final T pItem) 
 
}
class org.andengine.util.adt.queue.SortedQueue {
 + T peek() 
+ T poll() 
+ void enter(final T pItem) 
+ void enter(final int pIndex, final T pItem) 
 
}
class org.andengine.util.adt.queue.UniqueQueue {
 + T peek() 
+ T poll() 
+ void enter(final T pItem) 
+ void enter(final int pIndex, final T pItem) 
 
}
class org.andengine.util.adt.queue.concurrent.SynchronizedQueue {
 + synchronized boolean isEmpty() 
+ synchronized T get(final int pIndex) 
+ synchronized void set(int pIndex, T pItem) 
+ synchronized int indexOf(final T pItem) 
+ synchronized void add(final T pItem) 
+ synchronized void add(final int pIndex, final T pItem) 
+ synchronized T peek() 
+ synchronized T poll() 
+ synchronized void enter(final T pItem) 
+ synchronized void enter(final int pIndex, final T pItem) 
+ synchronized T removeFirst() 
+ synchronized T removeLast() 
+ synchronized boolean remove(final T pItem) 
+ synchronized T remove(final int pIndex) 
+ synchronized int size() 
+ synchronized void clear() 
	- final IQueue<T> mQueue;
 
}
class org.andengine.util.adt.spatial.bounds.util.FloatBoundsUtils {
 + {static} final boolean intersects(final IFloatBounds pFloatBoundsA, final IFloatBounds pFloatBoundsB) 
+ {static} final boolean intersects(final float pXMinA, final float pYMinA, final float pXMaxA, final float pYMaxA, final float pXMinB, final float pYMinB, final float pXMaxB, final float pYMaxB) 
+ {static} final boolean contains(final IFloatBounds pFloatBounds, final float pX, final float pY) 
+ {static} final boolean contains(final IFloatBounds pFloatBoundsA, final IFloatBounds pFloatBoundsB) 
+ {static} final boolean contains(final IFloatBounds pFloatBounds, final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
+ {static} final boolean contains(final float pXMin, final float pYMin, final float pXMax, final float pYMax, final float pX, final float pY) 
+ {static} final boolean contains(final float pXMinA, final float pYMinA, final float pXMaxA, final float pYMaxA, final float pXMinB, final float pYMinB, final float pXMaxB, final float pYMaxB) 
 
}
class org.andengine.util.adt.spatial.bounds.util.IntBoundsUtils {
 + {static} final boolean intersects(final IIntBounds pIntBoundsA, final IIntBounds pIntBoundsB) 
+ {static} final boolean intersects(final int pXMinA, final int pYMinA, final int pXMaxA, final int pYMaxA, final int pXMinB, final int pYMinB, final int pXMaxB, final int pYMaxB) 
+ {static} final boolean contains(final IIntBounds pIntBoundsA, final IIntBounds pIntBoundsB) 
+ {static} final boolean contains(final IIntBounds pIntBounds, final int pX, final int pY) 
+ {static} final boolean contains(final IIntBounds pIntBounds, final int pXMin, final int pYMin, final int pXMax, final int pYMax) 
+ {static} final boolean contains(final int pXMin, final int pYMin, final int pXMax, final int pYMax, final int pX, final int pY) 
+ {static} final boolean contains(final int pXMinA, final int pYMinA, final int pXMaxA, final int pYMaxA, final int pXMinB, final int pYMinB, final int pXMaxB, final int pYMaxB) 
+ {static} final boolean adjacent(final IIntBounds pIntBoundsA, final IIntBounds pIntBoundsB) 
+ {static} final boolean adjacent(final int pXMinA, final int pYMinA, final int pXMaxA, final int pYMaxA, final int pXMinB, final int pYMinB, final int pXMaxB, final int pYMaxB) 
 
}
class org.andengine.util.adt.spatial.quadtree.FloatQuadTree {
 # FloatQuadTreeNode initRoot(final IFloatBounds pFloatBounds) 
+ float getXMin() 
+ float getYMin() 
+ float getXMax() 
+ float getYMax() 
# FloatQuadTreeNode getRoot() 
+ synchronized ArrayList<T> query(final float pX, final float pY) 
+ synchronized <L extends List<T>> L query(final float pX, final float pY, final L pResult) 
+ synchronized ArrayList<T> query(final float pX, final float pY, final IMatcher<T> pMatcher) 
+ synchronized <L extends List<T>> L query(final float pX, final float pY, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized ArrayList<T> query(final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
+ synchronized <L extends List<T>> L query(final float pXMin, final float pYMin, final float pXMax, final float pYMax, final L pResult) 
+ synchronized ArrayList<T> query(final float pXMin, final float pYMin, final float pXMax, final float pYMax, final IMatcher<T> pMatcher) 
+ synchronized <L extends List<T>> L query(final float pXMin, final float pYMin, final float pXMax, final float pYMax, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized <S extends T> List<S> queryForSubclass(final float pX, final float pY, final IMatcher<T> pMatcher, final List<S> pResult) 
+ synchronized <S extends T> List<S> queryForSubclass(final float pXMin, final float pYMin, final float pXMax, final float pYMax, final IMatcher<T> pMatcher, final List<S> pResult) 
+ synchronized boolean containsAny(final float pX, final float pY) 
+ synchronized boolean containsAny(final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
+ synchronized boolean containsAny(final float pX, final float pY, final IMatcher<T> pMatcher) 
+ synchronized boolean containsAny(final float pXMin, final float pYMin, final float pXMax, final float pYMax, final IMatcher<T> pMatcher) 
+ float getWidth() 
+ float getHeight() 
# FloatQuadTreeNode split(final BoundsSplit pBoundsSplit) 
# boolean contains(final IFloatBounds pFloatBounds) 
# boolean contains(final BoundsSplit pBoundsSplit, final IFloatBounds pFloatBounds) 
# boolean intersects(final IFloatBounds pFloatBounds) 
# boolean intersects(final IFloatBounds pFloatBoundsA, final IFloatBounds pFloatBoundsB) 
# boolean containedBy(final IFloatBounds pFloatBounds) 
# void appendBoundsToString(final StringBuilder pStringBuilder) 
- float getXMin(final BoundsSplit pBoundsSplit) 
- float getYMin(final BoundsSplit pBoundsSplit) 
- float getXMax(final BoundsSplit pBoundsSplit) 
- float getYMax(final BoundsSplit pBoundsSplit) 
+ boolean intersects(final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
+ boolean contains(final float pXMin, final float pYMin, final float pXMax, final float pYMax) 
		- final float mXMin;
		- final float mYMin;
		- final float mXMax;
		- final float mYMax;
 
}
class org.andengine.util.adt.spatial.quadtree.IntQuadTree {
 # IntQuadTreeNode initRoot(final IIntBounds pIntBounds) 
+ int getXMin() 
+ int getYMin() 
+ int getXMax() 
+ int getYMax() 
# IntQuadTreeNode getRoot() 
+ synchronized ArrayList<T> query(final int pX, final int pY) 
+ synchronized <L extends List<T>> L query(final int pX, final int pY, final L pResult) 
+ synchronized ArrayList<T> query(final int pX, final int pY, final IMatcher<T> pMatcher) 
+ synchronized <L extends List<T>> L query(final int pX, final int pY, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized ArrayList<T> query(final int pXMin, final int pYMin, final int pXMax, final int pYMax) 
+ synchronized <L extends List<T>> L query(final int pXMin, final int pYMin, final int pXMax, final int pYMax, final L pResult) 
+ synchronized ArrayList<T> query(final int pXMin, final int pYMin, final int pXMax, final int pYMax, final IMatcher<T> pMatcher) 
+ synchronized <L extends List<T>> L query(final int pXMin, final int pYMin, final int pXMax, final int pYMax, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized <L extends List<S>, S extends T> L queryForSubclass(final int pX, final int pY, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized <L extends List<S>, S extends T> L queryForSubclass(final int pXMin, final int pYMin, final int pXMax, final int pYMax, final IMatcher<T> pMatcher, final L pResult) 
+ synchronized boolean containsAny(final int pX, final int pY) 
+ synchronized boolean containsAny(final int pXMin, final int pYMin, final int pXMax, final int pYMax) 
+ synchronized boolean containsAny(final int pX, final int pY, final IMatcher<T> pMatcher) 
+ synchronized boolean containsAny(final int pXMin, final int pYMin, final int pXMax, final int pYMax, final IMatcher<T> pMatcher) 
+ int getWidth() 
+ int getHeight() 
# IntQuadTreeNode split(final BoundsSplit pBoundsSplit) 
# boolean contains(final IIntBounds pIntBounds) 
# boolean contains(final BoundsSplit pBoundsSplit, final IIntBounds pIntBounds) 
# boolean intersects(final IIntBounds pIntBounds) 
# boolean intersects(final IIntBounds pIntBoundsA, final IIntBounds pIntBoundsB) 
# boolean containedBy(final IIntBounds pBounds) 
# void appendBoundsToString(final StringBuilder pStringBuilder) 
- int getXMin(final BoundsSplit pBoundsSplit) 
- int getYMin(final BoundsSplit pBoundsSplit) 
- int getXMax(final BoundsSplit pBoundsSplit) 
- int getYMax(final BoundsSplit pBoundsSplit) 
+ boolean intersects(final int pXMin, final int pYMin, final int pXMax, final int pYMax) 
+ boolean contains(final int pXMin, final int pYMin, final int pXMax, final int pYMax) 
		- final int mXMin;
		- final int mYMin;
		- final int mXMax;
		- final int mYMax;
 
}
class org.andengine.util.adt.transformation.Transformation {
 + String toString() 
+ final void reset() 
+ final void setToIdentity() 
+ final void setTo(final Transformation pTransformation) 
+ final void preTranslate(final float pX, final float pY) 
+ final void postTranslate(final float pX, final float pY) 
+ final Transformation setToTranslate(final float pX, final float pY) 
+ final void preRotate(final float pAngle) 
+ final void postRotate(final float pAngle) 
+ final Transformation setToRotate(final float pAngle) 
+ final void preScale(final float pScaleX, final float pScaleY) 
+ final void postScale(final float pScaleX, final float pScaleY) 
+ final Transformation setToScale(final float pScaleX, final float pScaleY) 
+ final void preSkew(final float pSkewX, final float pSkewY) 
+ final void postSkew(final float pSkewX, final float pSkewY) 
+ final Transformation setToSkew(final float pSkewX, final float pSkewY) 
+ final void postConcat(final Transformation pTransformation) 
- void postConcat(final float pA, final float pB, final float pC, final float pD, final float pTX, final float pTY) 
+ final void preConcat(final Transformation pTransformation) 
- void preConcat(final float pA, final float pB, final float pC, final float pD, final float pTX, final float pTY) 
+ final void transform(final float[] pVertices) 
 
}
class org.andengine.util.adt.transformation.TransformationPool {
 # Transformation onAllocatePoolItem() 
+ {static} Transformation obtain() 
+ {static} void recycle(final Transformation pTransformation) 
 
}
class org.andengine.util.adt.trie.Trie {
 + void add(final CharSequence pCharSequence) 
+ void add(final CharSequence pCharSequence, final int pStart, final int pEnd) 
+ boolean contains(final CharSequence pCharSequence) 
+ boolean contains(final CharSequence pCharSequence, final int pStart, final int pEnd) 
		- SparseArray<TrieNode> mChildren;
		- boolean mWordEndFlag;
 
}
class org.andengine.util.algorithm.Spiral {
 + int getCenterX() 
+ int getCenterY() 
+ int getX() 
+ int getY() 
+ void step() 
	- final int mCenterX;
	- final int mCenterY;
	- final int mStepSize;
	- int mX;
	- int mY;
	- Direction mDirection;
	- int mDirectionSegmentLength;
	- int mDirectionSegmentIndex;
 
}
class org.andengine.util.algorithm.collision.BaseCollisionChecker {
 + {static} boolean checkAxisAlignedRectangleCollision(final float pLeftA, final float pTopA, final float pRightA, final float pBottomA, final float pLeftB, final float pTopB, final float pRightB, final float pBottomB) 
+ {static} boolean checkAxisAlignedRectangleContains(final float pLeft, final float pTop, final float pRight, final float pBottom, final float pX, final float pY) 
+ {static} int relativeCCW(final float pX1, final float pY1, float pX2, float pY2, float pPX, float pPY) 
 
}
class org.andengine.util.algorithm.collision.LineCollisionChecker {
 + {static} boolean checkLineCollision(final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX4, final float pY4) 
+ {static} void fillVertices(final Line pLine, final float[] pVertices) 
 
}
class org.andengine.util.algorithm.collision.RectangularShapeCollisionChecker {
 + {static} boolean checkContains(final float pLocalX, final float pLocalY, final float pLocalWidth, final float pLocalHeight, final Transformation pLocalToSceneTransformation, final float pX, final float pY) 
+ {static} boolean checkContains(final Entity pEntity, final float pLocalWidth, final float pLocalHeight, final float pX, final float pY) 
+ {static} boolean checkContains(final RectangularShape pRectangularShape, final float pX, final float pY) 
+ {static} boolean isVisible(final Camera pCamera, final RectangularShape pRectangularShape) 
+ {static} boolean isVisible(final Camera pCamera, final float pX, final float pY, final float pWidth, final float pHeight, final Transformation pLocalToSceneTransformation) 
+ {static} boolean isVisible(final Camera pCamera, final Line pLine) 
+ {static} boolean checkCollision(final RectangularShape pRectangularShapeA, final RectangularShape pRectangularShapeB) 
+ {static} boolean checkCollision(final RectangularShape pRectangularShape, final Line pLine) 
+ {static} void fillVertices(final RectangularShape pRectangularShape, final float[] pVertices) 
+ {static} void fillVertices(final float pLocalX, final float pLocalY, final float pLocalWidth, final float pLocalHeight, final Transformation pLocalToSceneTransformation, final float[] pVertices) 
- {static} void fillVertices(final Camera pCamera, final float[] pVertices) 
 
}
class org.andengine.util.algorithm.collision.ShapeCollisionChecker {
 + {static} boolean checkCollision(final float[] pVerticesA, final int pVertexCountA, final float[] pVerticesB, final int pVertexCountB) 
+ {static} boolean checkCollision(final float[] pVerticesA, final int pVertexCountA, final int pVertexOffsetXA, final int pVertexOffsetYA, final int pVertexStrideA, final float[] pVerticesB, final int pVertexCountB, final int pVertexOffsetXB, final int pVertexOffsetYB, final int pVertexStrideB) 
- {static} boolean checkCollisionSub(final float[] pVerticesA, final int pVertexOffsetXA, final int pVertexOffsetYA, final int pVertexStrideA, final int pVertexIndexA1, final int pVertexIndexA2, final float[] pVerticesB, final int pVertexCountB, final int pVertexOffsetXB, final int pVertexOffsetYB, final int pVertexStrideB) 
+ {static} boolean checkContains(final float[] pVertices, final int pVertexCount, final float pX, final float pY) 
+ {static} boolean checkContains(final float[] pVertices, final int pVertexCount, final int pVertexOffsetX, final int pVertexOffsetY, final int pVertexStride, final float pX, final float pY) 
 
}
class org.andengine.util.algorithm.collision.TriangleCollisionChecker {
 + {static} boolean checkContains(final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final float pX, final float pY) 
+ {static} boolean checkContains(final float pX1, final float pY1, final float pX2, final float pY2, final float pX3, final float pY3, final Transformation pTransformation, final float pX, final float pY) 
 
}
class org.andengine.util.algorithm.hull.HullUtils {
 + {static} int indexOfLowestVertex(final float[] pVertices, final int pVertexCount, final int pVertexOffsetY, final int pVertexStride) 
+ {static} void swap(final float[] pVertices, final int pVertexStride, final int pVertexIndexA, final int pVertexIndexB) 
 
}
class org.andengine.util.algorithm.hull.JarvisMarch {
 + int computeHull(final float[] pVertices, final int pVertexCount, final int pVertexOffsetX, final int pVertexOffsetY, final int pVertexStride) 
- {static} int jarvisMarch(final float[] pVertices, final int pVertexCount, final int pVertexOffsetX, final int pVertexOffsetY, final int pVertexStride) 
 
}
class org.andengine.util.algorithm.path.Path {
 + int getLength() 
+ int getFromX() 
+ int getFromY() 
+ int getToX() 
+ int getToY() 
+ int getX(final int pIndex) 
+ int getY(final int pIndex) 
+ void set(final int pIndex, final int pX, final int pY) 
+ boolean contains(final int pX, final int pY) 
+ Direction getDirectionToPreviousStep(final int pIndex) 
+ Direction getDirectionToNextStep(final int pIndex) 
	- final int[] mXs;
	- final int[] mYs;
 
}
class org.andengine.util.algorithm.path.astar.AStarPathFinder {
 + Path findPath(final IPathFinderMap<T> pPathFinderMap, final int pXMin, final int pYMin, final int pXMax, final int pYMax, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY, final boolean pAllowDiagonal, final IAStarHeuristic<T> pAStarHeuristic, final ICostFunction<T> pCostFunction) 
+ Path findPath(final IPathFinderMap<T> pPathFinderMap, final int pXMin, final int pYMin, final int pXMax, final int pYMax, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY, final boolean pAllowDiagonal, final IAStarHeuristic<T> pAStarHeuristic, final ICostFunction<T> pCostFunction, final float pMaxCost) 
+ Path findPath(final IPathFinderMap<T> pPathFinderMap, final int pXMin, final int pYMin, final int pXMax, final int pYMax, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY, final boolean pAllowDiagonal, final IAStarHeuristic<T> pAStarHeuristic, final ICostFunction<T> pCostFunction, final float pMaxCost, final IPathFinderListener<T> pPathFinderListener) 
+ void setParent(final Node pParent, final float pCost) 
+ int compareTo(final Node pNode) 
+ boolean equals(final Object pOther) 
+ String toString() 
+ {static} long calculateID(final int pX, final int pY) 
+ boolean equals(final Node pNode) 
~					final boolean neighborNodeIsNew;
~		/* package */ final int mX;
~		/* package */ final int mY;
~		/* package */ final long mID;
~		/* package */ final float mExpectedRestCost;
 
}
class org.andengine.util.algorithm.path.astar.EuclideanHeuristic {
 + float getExpectedRestCost(final IPathFinderMap<T> pPathFinderMap, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY) 
 
}
class org.andengine.util.algorithm.path.astar.ManhattanHeuristic {
 + float getExpectedRestCost(final IPathFinderMap<T> pPathFinderMap, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY) 
 
}
class org.andengine.util.algorithm.path.astar.NullHeuristic {
 + float getExpectedRestCost(final IPathFinderMap<T> pPathFinderMap, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY) 
 
}
class org.andengine.util.algorithm.sort.InsertionSorter {
 + void sort(final T[] pArray, final int pStart, final int pEnd, final Comparator<T> pComparator) 
+ void sort(final List<T> pList, final int pStart, final int pEnd, final Comparator<T> pComparator) 
+ void sort(final IList<T> pList, final int pStart, final int pEnd, final Comparator<T> pComparator) 
 
}
class org.andengine.util.animationpack.AnimationPack {
 + TexturePackLibrary getTexturePackLibrary() 
+ AnimationPackTiledTextureRegionLibrary getAnimationPackAnimationDataLibrary() 
	- final TexturePackLibrary mTexturePackLibrary;
	- final AnimationPackTiledTextureRegionLibrary mAnimationPackTiledTextureRegionLibrary;
 
}
class org.andengine.util.animationpack.AnimationPackLoader {
 + AnimationPack loadFromAsset(final String pAssetPath, final String pAssetBasePath) 
+ AnimationPack load(final InputStream pInputStream, final String pAssetBasePath) 
	- final AssetManager mAssetManager;
	- final TextureManager mTextureManager;
 
}
class org.andengine.util.animationpack.AnimationPackParser {
 + AnimationPack getAnimationPack() 
+ void startElement(final String pUri, final String pLocalName, final String pQualifiedName, final Attributes pAttributes) 
+ void endElement(final String pUri, final String pLocalName, final String pQualifiedName) 
	- final AssetManager mAssetManager;
	- final String mAssetBasePath;
	- final TextureManager mTextureManager;
	- AnimationPack mAnimationPack;
	- AnimationPackTiledTextureRegionLibrary mAnimationPackTiledTextureRegionLibrary;
	- TexturePackLibrary mTexturePackLibrary;
	- TexturePackLoader mTexturePackLoader;
	- String mCurrentAnimationName;
 
}
class org.andengine.util.animationpack.AnimationPackTiledTextureRegion {
 + String getAnimationName() 
+ AnimationData getAnimationData() 
	- final String mAnimationName;
	- final AnimationData mAnimationData;
 
}
class org.andengine.util.animationpack.AnimationPackTiledTextureRegionLibrary {
 + void put(final AnimationPackTiledTextureRegion pAnimationPackTiledTextureRegion) 
+ AnimationPackTiledTextureRegion get(final String pAnimationName) 
 
}
class org.andengine.util.animationpack.exception.AnimationPackParseException {
  
}
class org.andengine.util.base64.Base64 {
 + {abstract} boolean process(byte[] input, int offset, int len, boolean finish)
+ {static} byte[] decode(final String str, final int flags) 
+ {static} byte[] decode(final byte[] input, final int flags) 
+ {static} byte[] decode(final byte[] input, final int offset, final int len, final int flags) 
+ int maxOutputSize(final int len) 
+ boolean process(final byte[] input, final int offset, int len, final boolean finish) 
+ {static} String encodeToString(final byte[] input, final int flags) 
+ {static} String encodeToString(final byte[] input, final int offset, final int len, final int flags) 
+ {static} byte[] encode(final byte[] input, final int flags) 
+ {static} byte[] encode(final byte[] input, final int offset, final int len, final int flags) 
		+ byte[] output;
		+ int op;
		- int state;
		- int value;
		final - int[] alphabet;
		final - byte[] tail;
		- int count;
		final + boolean do_padding;
		final + boolean do_newline;
		final + boolean do_cr;
		final - byte[] alphabet;
 
}
class org.andengine.util.base64.Base64InputStream {
 + boolean markSupported() 
+ void mark(final int readlimit) 
+ void reset() 
+ void close() 
+ int available() 
+ long skip(final long n) 
+ int read() 
+ int read(final byte[] b, final int off, final int len) 
- void refill() 
	- boolean eof;
	- byte[] inputBuffer;
	- int outputStart;
	- int outputEnd;
 
}
class org.andengine.util.color.Color {
 + final float getRed() 
+ final float getGreen() 
+ final float getBlue() 
+ final float getAlpha() 
+ final void setRed(final float pRed) 
+ final boolean setRedChecking(final float pRed) 
+ final void setGreen(final float pGreen) 
+ final boolean setGreenChecking(final float pGreen) 
+ final void setBlue(final float pBlue) 
+ final boolean setBlueChecking(final float pBlue) 
+ final void setAlpha(final float pAlpha) 
+ final boolean setAlphaChecking(final float pAlpha) 
+ final void set(final float pRed, final float pGreen, final float pBlue) 
+ final boolean setChecking(final float pRed, final float pGreen, final float pBlue) 
+ final void set(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ final boolean setChecking(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ final void set(final Color pColor) 
+ final boolean setChecking(final Color pColor) 
+ final int getABGRPackedInt() 
+ final float getABGRPackedFloat() 
+ final int getARGBPackedInt() 
+ final void reset() 
+ int hashCode() 
+ boolean equals(final Object pObject) 
+ String toString() 
+ boolean equals(final Color pColor) 
- final void packABGRRed() 
- final void packABGRGreen() 
- final void packABGRBlue() 
- final void packABGRAlpha() 
- final void packABGR() 
+ final void mix(final Color pColorA, final float pPercentageA, final Color pColorB, final float pPercentageB) 
	- float mRed;
	- float mGreen;
	- float mBlue;
	- float mAlpha;
	- int mABGRPackedInt;
	- float mABGRPackedFloat;
 
}
class org.andengine.util.color.ColorPool {
 # Color onAllocatePoolItem() 
# void onHandleRecycleItem(final Color pColor) 
 
}
class org.andengine.util.color.ColorUtils {
 + {static} final int convertHSVToARGBPackedInt(final float pHue, final float pSaturation, final float pValue) 
+ {static} final Color convertHSVToColor(final float pHue, final float pSaturation, final float pValue) 
+ {static} Color convertARGBPackedIntToColor(final int pARGBPackedInt) 
+ {static} Color convertABGRPackedIntToColor(final int pABGRPackedInt) 
+ {static} final int convertRGBAToARGBPackedInt(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ {static} final float convertRGBAToARGBPackedFloat(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ {static} final int convertRGBAToABGRPackedInt(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ {static} final float convertRGBAToABGRPackedFloat(final float pRed, final float pGreen, final float pBlue, final float pAlpha) 
+ {static} final float convertPackedIntToPackedFloat(final int pPackedInt) 
+ {static} float extractRedFromABGRPackedInt(final int pABGRPackedInt) 
+ {static} float extractGreenFromABGRPackedInt(final int pABGRPackedInt) 
+ {static} float extractBlueFromABGRPackedInt(final int pABGRPackedInt) 
+ {static} float extractAlphaFromABGRPackedInt(final int pABGRPackedInt) 
+ {static} float extractBlueFromARGBPackedInt(final int pARGBPackedInt) 
+ {static} float extractGreenFromARGBPackedInt(final int pARGBPackedInt) 
+ {static} float extractRedFromARGBPackedInt(final int pARGBPackedInt) 
+ {static} float extractAlphaFromARGBPackedInt(final int pARGBPackedInt) 
 
}
class org.andengine.util.debug.Debug {
 + {static} String getTag() 
+ {static} void setTag(final String pTag) 
+ {static} DebugLevel getDebugLevel() 
+ {static} void setDebugLevel(final DebugLevel pDebugLevel) 
+ {static} void setDebugUser(final String pDebugUser) 
+ {static} void log(final DebugLevel pDebugLevel, final String pMessage) 
+ {static} void log(final DebugLevel pDebugLevel, final String pMessage, final Throwable pThrowable) 
+ {static} void log(final DebugLevel pDebugLevel, final String pTag, final String pMessage) 
+ {static} void log(final DebugLevel pDebugLevel, final String pTag, final String pMessage, final Throwable pThrowable) 
+ {static} void v(final String pMessage) 
+ {static} void v(final String pMessage, final Throwable pThrowable) 
+ {static} void v(final String pTag, final String pMessage) 
+ {static} void v(final String pTag, final String pMessage, final Throwable pThrowable) 
+ {static} void vUser(final String pMessage, final String pDebugUser) 
+ {static} void vUser(final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void vUser(final String pTag, final String pMessage, final String pDebugUser) 
+ {static} void vUser(final String pTag, final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void d(final String pMessage) 
+ {static} void d(final String pMessage, final Throwable pThrowable) 
+ {static} void d(final String pTag, final String pMessage) 
+ {static} void d(final String pTag, final String pMessage, final Throwable pThrowable) 
+ {static} void dUser(final String pMessage, final String pDebugUser) 
+ {static} void dUser(final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void dUser(final String pTag, final String pMessage, final String pDebugUser) 
+ {static} void dUser(final String pTag, final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void i(final String pMessage) 
+ {static} void i(final String pMessage, final Throwable pThrowable) 
+ {static} void i(final String pTag, final String pMessage) 
+ {static} void i(final String pTag, final String pMessage, final Throwable pThrowable) 
+ {static} void iUser(final String pMessage, final String pDebugUser) 
+ {static} void iUser(final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void iUser(final String pTag, final String pMessage, final String pDebugUser) 
+ {static} void iUser(final String pTag, final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void w(final String pMessage) 
+ {static} void w(final Throwable pThrowable) 
+ {static} void w(final String pMessage, final Throwable pThrowable) 
+ {static} void w(final String pTag, final String pMessage) 
+ {static} void w(final String pTag, final String pMessage, final Throwable pThrowable) 
+ {static} void wUser(final String pMessage, final String pDebugUser) 
+ {static} void wUser(final Throwable pThrowable, final String pDebugUser) 
+ {static} void wUser(final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void wUser(final String pTag, final String pMessage, final String pDebugUser) 
+ {static} void wUser(final String pTag, final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void e(final String pMessage) 
+ {static} void e(final Throwable pThrowable) 
+ {static} void e(final String pMessage, final Throwable pThrowable) 
+ {static} void e(final String pTag, final String pMessage) 
+ {static} void e(final String pTag, final String pMessage, final Throwable pThrowable) 
+ {static} void eUser(final String pMessage, final String pDebugUser) 
+ {static} void eUser(final Throwable pThrowable, final String pDebugUser) 
+ {static} void eUser(final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ {static} void eUser(final String pTag, final String pMessage, final String pDebugUser) 
+ {static} void eUser(final String pTag, final String pMessage, final Throwable pThrowable, final String pDebugUser) 
+ boolean isSameOrLessThan(final DebugLevel pDebugLevel) 
 
}
class org.andengine.util.debug.Debug.DebugLevel
class org.andengine.util.debug.DebugTimer {
 - void init(final String pLabel) 
+ void begin(final String pLabel) 
+ void split(final String pLabel) 
+ void end() 
+ void dump() 
+ void dump(final boolean pClear) 
+ void clear() 
+ void begin(final DebugTime pDebugTime) 
+ void end(final long pEndTime) 
+ void dump(final int pIndent) 
+ void dump(final int pIndent, final String pPostfix) 
- void ensureChildrenAllocated() 
	- final DebugLevel mDebugLevel;
		- final long mStartTime;
		- final String mLabel;
		- final boolean mSplit;
		- long mEndTime;
		- ArrayList<DebugTime> mChildren;
		- DebugTime mLastSplit;
 
}
class org.andengine.util.exception.AndEngineException {
  
}
class org.andengine.util.exception.AndEngineRuntimeException {
  
}
class org.andengine.util.exception.CancelledException {
  
}
class org.andengine.util.exception.DeviceNotSupportedException {
 + DeviceNotSupportedCause getDeviceNotSupportedCause() 
	- final DeviceNotSupportedCause mDeviceNotSupportedCause;
 
}
class org.andengine.util.exception.DeviceNotSupportedException.DeviceNotSupportedCause
class org.andengine.util.exception.MethodNotSupportedException {
  
}
class org.andengine.util.exception.MethodNotYetImplementedException {
  
}
class org.andengine.util.exception.NullBitmapException {
  
}
class org.andengine.util.level.LevelLoader {
 + IEntityLoader getDefaultEntityLoader() 
+ void setDefaultEntityLoader(final IEntityLoader pDefaultEntityLoader) 
+ void setAssetBasePath(final String pAssetBasePath) 
+ String getAssetBasePath() 
# void onAfterLoadLevel() 
# void onBeforeLoadLevel() 
+ void registerEntityLoader(final String pEntityName, final IEntityLoader pEntityLoader) 
+ void registerEntityLoader(final String[] pEntityNames, final IEntityLoader pEntityLoader) 
+ void loadLevelFromAsset(final AssetManager pAssetManager, final String pAssetPath) 
+ void loadLevelFromResource(final Resources pResources, final int pRawResourceID) 
+ void loadLevelFromStream(final InputStream pInputStream) 
	- String mAssetBasePath;
	- IEntityLoader mDefaultEntityLoader;
 
}
class org.andengine.util.level.LevelParser {
 + void startElement(final String pUri, final String pLocalName, final String pQualifiedName, final Attributes pAttributes) 
+ void endElement(final String pUri, final String pLocalName, final String pQualifiedName) 
	- final IEntityLoader mDefaultEntityLoader;
	- final HashMap<String, IEntityLoader> mEntityLoaders;
 
}
class org.andengine.util.levelstats.LevelStatsDBConnector {
 + void submitAsync(final int pLevelID, final boolean pSolved, final int pSecondsElapsed) 
+ void submitAsync(final int pLevelID, final boolean pSolved, final int pSecondsElapsed, final Callback<Boolean> pCallback) 
	- final String mSecret;
	- final String mSubmitURL;
	- final int mPlayerID;
 
}
class org.andengine.util.math.MathUtils {
 + {static} final float atan2(final float dY, final float dX) 
+ {static} final float radToDeg(final float pRad) 
+ {static} final float degToRad(final float pDegree) 
+ {static} final int signum(final int n) 
+ {static} final int randomSign() 
+ {static} final float random(final float pMin, final float pMax) 
+ {static} final int random(final int pMin, final int pMax) 
+ {static} final boolean isPowerOfTwo(final int n) 
+ {static} final int nextPowerOfTwo(final float f) 
+ {static} final int nextPowerOfTwo(final int n) 
+ {static} final int sum(final int[] pValues) 
+ {static} final void arraySumInternal(final int[] pValues) 
+ {static} final void arraySumInternal(final long[] pValues) 
+ {static} final void arraySumInternal(final long[] pValues, final long pFactor) 
+ {static} final void arraySumInto(final long[] pValues, final long[] pTargetValues, final long pFactor) 
+ {static} final float arraySum(final float[] pValues) 
+ {static} final float arrayAverage(final float[] pValues) 
+ {static} float[] rotateAroundCenter(final float[] pVertices, final float pRotation, final float pRotationCenterX, final float pRotationCenterY) 
+ {static} float[] scaleAroundCenter(final float[] pVertices, final float pScaleX, final float pScaleY, final float pScaleCenterX, final float pScaleCenterY) 
+ {static} float[] rotateAndScaleAroundCenter(final float[] pVertices, final float pRotation, final float pRotationCenterX, final float pRotationCenterY, final float pScaleX, final float pScaleY, final float pScaleCenterX, final float pScaleCenterY) 
+ {static} float[] revertScaleAroundCenter(final float[] pVertices, final float pScaleX, final float pScaleY, final float pScaleCenterX, final float pScaleCenterY) 
+ {static} float[] revertRotateAroundCenter(final float[] pVertices, final float pRotation, final float pRotationCenterX, final float pRotationCenterY) 
+ {static} float[] revertRotateAndScaleAroundCenter(final float[] pVertices, final float pRotation, final float pRotationCenterX, final float pRotationCenterY, final float pScaleX, final float pScaleY, final float pScaleCenterX, final float pScaleCenterY) 
+ {static} final boolean isInBounds(final int pMinValue, final int pMaxValue, final int pValue) 
+ {static} final boolean isInBounds(final float pMinValue, final float pMaxValue, final float pValue) 
+ {static} final int bringToBounds(final int pMinValue, final int pMaxValue, final int pValue) 
+ {static} final float bringToBounds(final float pMinValue, final float pMaxValue, final float pValue) 
+ {static} final float distance(final float pX1, final float pY1, final float pX2, final float pY2)
+ {static} final float length(final float pX, final float pY)
+ {static} final float mix(final float pX, final float pY, final float pMix) 
+ {static} final int mix(final int pX, final int pY, final float pMix) 
+ {static} final boolean isEven(final int n) 
+ {static} final boolean isOdd(final int n) 
+ {static} float dot(final float pXA, final float pYA, final float pXB, final float pYB) 
+ {static} float cross(final float pXA, final float pYA, final float pXB, final float pYB) 
 
}
class org.andengine.util.modifier.IModifier {
 + int compare(final IModifier<?> pModifierA, final IModifier<?> pModifierB) 
+ void reset()
 
}.DeepCopyNotSupportedException
class org.andengine.util.modifier.LoopModifier {
 + LoopModifier<T> deepCopy() 
+ ILoopModifierListener<T> getLoopModifierListener() 
+ void setLoopModifierListener(final ILoopModifierListener<T> pLoopModifierListener) 
+ float getSecondsElapsed() 
+ float getDuration() 
+ float onUpdate(final float pSecondsElapsed, final T pItem) 
+ void reset() 
+ void onModifierStarted(final IModifier<T> pModifier, final T pItem) 
+ void onModifierFinished(final IModifier<T> pModifier, final T pItem) 
+ void onLoopStarted(final LoopModifier<T> pLoopModifier, final int pLoop, final int pLoopCount)
	- float mSecondsElapsed;
	- final float mDuration;
	- final IModifier<T> mModifier;
	- ILoopModifierListener<T> mLoopModifierListener;
	- final int mLoopCount;
	- int mLoop;
	- boolean mModifierStartedCalled;
	- boolean mFinishedCached;
 
}
class org.andengine.util.modifier.ModifierList {
 + T getTarget() 
+ boolean add(final IModifier<T> pModifier) 
+ void onUpdate(final float pSecondsElapsed) 
+ void reset() 
	- final T mTarget;
 
}
class org.andengine.util.modifier.ParallelModifier {
 + ParallelModifier<T> deepCopy() 
+ float getSecondsElapsed() 
+ float getDuration() 
+ float onUpdate(final float pSecondsElapsed, final T pItem) 
+ void reset() 
+ void onModifierStarted(final IModifier<T> pModifier, final T pItem) 
+ void onModifierFinished(final IModifier<T> pModifier, final T pItem) 
	- float mSecondsElapsed;
	- final float mDuration;
	- final IModifier<T>[] mModifiers;
	- boolean mFinishedCached;
 
}
class org.andengine.util.modifier.SequenceModifier {
 + SequenceModifier<T> deepCopy() 
+ ISubSequenceModifierListener<T> getSubSequenceModifierListener() 
+ void setSubSequenceModifierListener(final ISubSequenceModifierListener<T> pSubSequenceModifierListener) 
+ float getSecondsElapsed() 
+ float getDuration() 
+ float onUpdate(final float pSecondsElapsed, final T pItem) 
+ void reset() 
+ void onModifierStarted(final IModifier<T> pModifier, final T pItem) 
+ void onModifierFinished(final IModifier<T> pModifier, final T pItem) 
+ void onSubSequenceStarted(final IModifier<T> pModifier, final T pItem, final int pIndex)
	- ISubSequenceModifierListener<T> mSubSequenceModifierListener;
	- final IModifier<T>[] mSubSequenceModifiers;
	- int mCurrentSubSequenceModifierIndex;
	- float mSecondsElapsed;
	- final float mDuration;
	- boolean mFinishedCached;
 
}
class org.andengine.util.modifier.SequenceModifier.ISubSequenceModifierListener
class org.andengine.util.modifier.ease.EaseBackIn {
 + {static} EaseBackIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseBackIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseBackInOut {
 + {static} EaseBackInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseBackInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseBackOut {
 + {static} EaseBackOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseBackOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseBounceIn {
 + {static} EaseBounceIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseBounceIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseBounceInOut {
 + {static} EaseBounceInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseBounceInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseBounceOut {
 + {static} EaseBounceOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseBounceOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseCircularIn {
 + {static} EaseCircularIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseCircularIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseCircularInOut {
 + {static} EaseCircularInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseCircularInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseCircularOut {
 + {static} EaseCircularOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseCircularOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseCubicIn {
 + {static} EaseCubicIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseCubicIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseCubicInOut {
 + {static} EaseCubicInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseCubicInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseCubicOut {
 + {static} EaseCubicOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseCubicOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseElasticIn {
 + {static} EaseElasticIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pSecondsElapsed, final float pDuration, final float pPercentage) 
	- {static} EaseElasticIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseElasticInOut {
 + {static} EaseElasticInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseElasticInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseElasticOut {
 + {static} EaseElasticOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pSecondsElapsed, final float pDuration, final float pPercentageDone) 
	- {static} EaseElasticOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseExponentialIn {
 + {static} EaseExponentialIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseExponentialIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseExponentialInOut {
 + {static} EaseExponentialInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseExponentialInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseExponentialOut {
 + {static} EaseExponentialOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseExponentialOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseLinear {
 + {static} EaseLinear getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseLinear INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuadIn {
 + {static} EaseQuadIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseQuadIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuadInOut {
 + {static} EaseQuadInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseQuadInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuadOut {
 + {static} EaseQuadOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseQuadOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuartIn {
 + {static} EaseQuartIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseQuartIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuartInOut {
 + {static} EaseQuartInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseQuartInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuartOut {
 + {static} EaseQuartOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseQuartOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuintIn {
 + {static} EaseQuintIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseQuintIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuintInOut {
 + {static} EaseQuintInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseQuintInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseQuintOut {
 + {static} EaseQuintOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseQuintOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseSineIn {
 + {static} EaseSineIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseSineIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseSineInOut {
 + {static} EaseSineInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseSineInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseSineOut {
 + {static} EaseSineOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseSineOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseStrongIn {
 + {static} EaseStrongIn getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseStrongIn INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseStrongInOut {
 + {static} EaseStrongInOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
	- {static} EaseStrongInOut INSTANCE;
 
}
class org.andengine.util.modifier.ease.EaseStrongOut {
 + {static} EaseStrongOut getInstance() 
+ float getPercentage(final float pSecondsElapsed, final float pDuration) 
+ {static} float getValue(final float pPercentage) 
	- {static} EaseStrongOut INSTANCE;
 
}
class org.andengine.util.modifier.util.ModifierUtils {
 + {static} float getSequenceDurationOfModifier(final IModifier<?>[] pModifiers)
 
}
class org.andengine.util.preferences.SimplePreferences {
 + {static} SharedPreferences getInstance(final Context pContext) 
+ {static} Editor getEditorInstance(final Context pContext) 
+ {static} int incrementAccessCount(final Context pContext, final String pKey) 
+ {static} int incrementAccessCount(final Context pContext, final String pKey, final int pIncrement) 
+ {static} int getAccessCount(final Context pCtx, final String pKey) 
	- {static} SharedPreferences INSTANCE;
	- {static} Editor EDITORINSTANCE;
 
}
class org.andengine.util.progress.ProgressMonitor {
 + void onProgressChanged(final int pProgress) 
+ void registerChildProgressMonitor(final ProgressMonitor pChildProgressMonitor, final int pChildProgressMonitorRangeFrom, final int pChildProgressMonitorRangeTo) 
+ void unregisterChildProgressMonitor(final ProgressMonitor pChildProgressMonitor) 
- void addProgressListener(final IProgressListener pProgressListener) 
- void removeProgressListener(final IProgressListener pProgressListener) 
 
}
class org.andengine.util.system.CPUUsage {
 + float getUsage() 
+ void update() 
 
}
class org.andengine.util.system.SystemUtils {
 + {static} boolean isGoogleTV(final Context pContext) 
+ {static} int getPackageVersionCode(final Context pContext) 
+ {static} String getPackageVersionName(final Context pContext) 
+ {static} String getPackageName(final Context pContext) 
+ {static} String getApkFilePath(final Context pContext) 
- {static} PackageInfo getPackageInfo(final Context pContext) 
+ {static} boolean hasSystemFeature(final Context pContext, final String pFeature) 
+ {static} boolean isAndroidVersionOrLower(final int pBuildVersionCode) 
+ {static} boolean isAndroidVersionOrHigher(final int pBuildVersionCode) 
+ {static} boolean isAndroidVersion(final int pBuildVersionCodeMin, final int pBuildVersionCodeMax) 
+ {static} float getCPUBogoMips() 
+ {static} int getMemoryTotal() 
+ {static} int getMemoryFree() 
+ {static} int getCPUFrequencyCurrent() 
+ {static} int getCPUFrequencyMin() 
+ {static} int getCPUFrequencyMax() 
+ {static} int getCPUFrequencyMinScaling() 
+ {static} int getCPUFrequencyMaxScaling() 
- {static} MatchResult matchSystemFile(final String pSystemFile, final String pPattern, final int pHorizon) 
- {static} int readSystemFileAsInt(final String pSystemFile) 
 
}
class org.andengine.util.texturepack.TexturePack {
 + ITexture getTexture() 
+ TexturePackTextureRegionLibrary getTexturePackTextureRegionLibrary() 
+ void loadTexture() 
+ void unloadTexture() 
	- final ITexture mTexture;
	- final TexturePackTextureRegionLibrary mTexturePackTextureRegionLibrary;
 
}
class org.andengine.util.texturepack.TexturePackLibrary {
 + void put(final String pID, final TexturePack pTexturePack) 
+ TexturePackTextureRegion getTexturePackTextureRegion(final String pTexturePackTextureRegionSource) 
 
}
class org.andengine.util.texturepack.TexturePackLoader {
 + TexturePack loadFromAsset(final String pAssetPath, final String pAssetBasePath) 
+ TexturePack load(final InputStream pInputStream, final String pAssetBasePath) 
	- final AssetManager mAssetManager;
	- final TextureManager mTextureManager;
 
}
class org.andengine.util.texturepack.TexturePackParser {
 + TexturePack getTexturePack() 
+ void startElement(final String pUri, final String pLocalName, final String pQualifiedName, final Attributes pAttributes) 
# InputStream onGetInputStream(final String pFilename) 
- ITexture parseTexture(final Attributes pAttributes) 
+ InputStream open() 
# InputStream onGetInputStream() 
- {static} PixelFormat parsePixelFormat(final Attributes pAttributes) 
- TextureOptions parseTextureOptions(final Attributes pAttributes) 
- {static} int parseMinFilter(final Attributes pAttributes) 
- {static} int parseMagFilter(final Attributes pAttributes) 
- int parseWrapT(final Attributes pAttributes) 
- int parseWrapS(final Attributes pAttributes) 
- int parseWrap(final Attributes pAttributes, final String pWrapAttributeName) 
- {static} boolean parsePremultiplyalpha(final Attributes pAttributes) 
	- final AssetManager mAssetManager;
	- final String mAssetBasePath;
	- final TextureManager mTextureManager;
	- TexturePack mTexturePack;
	- TexturePackTextureRegionLibrary mTextureRegionLibrary;
	- ITexture mTexture;
	- int mVersion;
~		final ITexture texture;
 
}
class org.andengine.util.texturepack.TexturePackTextureRegion {
 + int getID() 
+ String getSource() 
+ boolean isTrimmed() 
+ int getSourceX() 
+ int getSourceY() 
+ int getSourceWidth() 
+ int getSourceHeight() 
	- final int mID;
	- final String mSource;
	- final boolean mTrimmed;
	- final int mSourceX;
	- final int mSourceY;
	- final int mSourceWidth;
	- final int mSourceHeight;
 
}
class org.andengine.util.texturepack.TexturePackTextureRegionLibrary {
 + SparseArray<TexturePackTextureRegion> getIDMapping() 
+ HashMap<String, TexturePackTextureRegion> getSourceMapping() 
+ void put(final TexturePackTextureRegion pTexturePackTextureRegion) 
+ void remove(final int pID) 
+ TexturePackTextureRegion get(final int pID) 
+ TexturePackTextureRegion get(final String pSource) 
+ TexturePackTextureRegion get(final String pSource, final boolean pStripExtension) 
- void throwOnCollision(final TexturePackTextureRegion pTexturePackTextureRegion) 
	- final SparseArray<TexturePackTextureRegion> mIDMapping;
	- final HashMap<String, TexturePackTextureRegion> mSourceMapping;
 
}
class org.andengine.util.texturepack.exception.TexturePackParseException {
  
}
class org.apache.http.HttpResponse
class org.apache.http.HttpStatus
class org.apache.http.NameValuePair
class org.apache.http.client.HttpClient
class org.apache.http.client.entity.UrlEncodedFormEntity
class org.apache.http.client.methods.HttpPost
class org.apache.http.impl.client.DefaultHttpClient
class org.apache.http.message.BasicNameValuePair
class org.xml.sax.Attributes
class org.xml.sax.InputSource
class org.xml.sax.SAXException
class org.xml.sax.XMLReader
class org.xml.sax.helpers.DefaultHandler
interface GLSurfaceView.EGLConfigChooser
interface GLSurfaceView.Renderer
interface android.hardware.SensorEventListener
interface android.location.LocationListener
interface android.media.SoundPool.OnLoadCompleteListener
interface android.view.View.OnTouchListener
interface org.andengine.audio.IAudioEntity {
 + void play()
 
}
interface org.andengine.audio.IAudioManager {
 + float getMasterVolume()
 
}
interface org.andengine.engine.handler.IDrawHandler {
 + void onDraw(final GLState pGLState, final Camera pCamera)
 
}
interface org.andengine.engine.handler.IUpdateHandler {
 + void onUpdate(final float pSecondsElapsed)
 
}
interface org.andengine.engine.handler.collision.ICollisionCallback {
 + boolean onCollision(final IShape pCheckShape, final IShape pTargetShape)
 
}
interface org.andengine.engine.handler.timer.ITimerCallback {
 + void onTimePassed(final TimerHandler pTimerHandler)
 
}
interface org.andengine.engine.options.resolutionpolicy.IResolutionPolicy {
 + void onMeasure(final RenderSurfaceView pRenderSurfaceView, final int pWidthMeasureSpec, final int pHeightMeasureSpec)
 
}
interface org.andengine.entity.IEntity {
 + boolean isVisible()
+ ArrayList<IEntity> query(final IEntityMatcher pEntityMatcher)
+ IEntity queryFirst(final IEntityMatcher pEntityMatcher)
+ <L extends List<IEntity>> L query(final IEntityMatcher pEntityMatcher, final L pResult)
+ <S extends IEntity> S queryFirstForSubclass(final IEntityMatcher pEntityMatcher)
+ <S extends IEntity> ArrayList<S> queryForSubclass(final IEntityMatcher pEntityMatcher) 
+ <L extends List<S>, S extends IEntity> L queryForSubclass(final IEntityMatcher pEntityMatcher, final L pResult) 
+ void sortChildren()
+ void sortChildren(final boolean pImmediate)
+ void sortChildren(final IEntityComparator pEntityComparator)
+ boolean detachChild(final IEntity pEntity)
+ IEntity detachChild(final int pTag)
+ IEntity detachChild(final IEntityMatcher pEntityMatcher)
+ boolean detachChildren(final IEntityMatcher pEntityMatcher)
+ boolean isCulled(final Camera pCamera)
 
}
interface org.andengine.entity.IEntityComparator {
  
}
interface org.andengine.entity.IEntityFactory {
 + T create(final float pX, final float pY)
 
}
interface org.andengine.entity.IEntityMatcher {
 + boolean matches(final IEntity pEntity)
 
}
interface org.andengine.entity.IEntityParameterCallable {
 + void call(final IEntity pEntity)
 
}
interface org.andengine.entity.modifier.IEntityModifier {
 + IEntityModifier deepCopy() 
 
}
interface org.andengine.entity.particle.emitter.IParticleEmitter {
 + void getPositionOffset(final float[] pOffset)
 
}
interface org.andengine.entity.particle.initializer.IParticleInitializer {
 + void onInitializeParticle(final Particle<T> pParticle)
 
}
interface org.andengine.entity.particle.modifier.IParticleModifier {
 + void onUpdateParticle(final Particle<T> pParticle)
 
}
interface org.andengine.entity.primitive.vbo.ILineVertexBufferObject {
 + void onUpdateColor(final Line pLine)
 
}
interface org.andengine.entity.primitive.vbo.IMeshVertexBufferObject {
 + float[] getBufferData()
 
}
interface org.andengine.entity.primitive.vbo.IRectangleVertexBufferObject {
 + void onUpdateColor(final Rectangle pRectangle)
 
}
interface org.andengine.entity.scene.IOnAreaTouchListener {
 + boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final ITouchArea pTouchArea, final float pTouchAreaLocalX, final float pTouchAreaLocalY)
 
}
interface org.andengine.entity.scene.IOnSceneTouchListener {
 + boolean onSceneTouchEvent(final Scene pScene, final TouchEvent pSceneTouchEvent)
 
}
interface org.andengine.entity.scene.ITouchArea {
 + boolean contains(final float pX, final float pY)
+ boolean onAreaTouched(final TouchEvent pSceneTouchEvent, final float pTouchAreaLocalX, final float pTouchAreaLocalY)
 
}
interface org.andengine.entity.scene.background.IBackground {
 + void registerBackgroundModifier(final IModifier<IBackground> pBackgroundModifier)
 
}
interface org.andengine.entity.scene.background.modifier.IBackgroundModifier {
 + IBackgroundModifier deepCopy() 
 
}
interface org.andengine.entity.scene.menu.animator.IMenuAnimator {
 + void prepareAnimations(final ArrayList<IMenuItem> pMenuItems, final float pCameraWidth, final float pCameraHeight)
 
}
interface org.andengine.entity.scene.menu.item.IMenuItem {
 + int getID()
 
}
interface org.andengine.entity.shape.IAreaShape {
 + float getWidth()
 
}
interface org.andengine.entity.shape.IShape {
 + boolean collidesWith(final IShape pOtherShape)
 
}
interface org.andengine.entity.sprite.IAnimationData {
 + int[] getFrames()
 
}
interface org.andengine.entity.sprite.batch.vbo.ISpriteBatchVertexBufferObject {
 + int getBufferDataOffset()
 
}
interface org.andengine.entity.sprite.vbo.IDiamondSpriteVertexBufferObject {
  
}
interface org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject {
 + void onUpdateColor(final Sprite pSprite)
 
}
interface org.andengine.entity.sprite.vbo.ITiledSpriteVertexBufferObject {
 + void onUpdateColor(final TiledSprite pTiledSprite)
 
}
interface org.andengine.entity.sprite.vbo.IUncoloredSpriteVertexBufferObject {
  
}
interface org.andengine.entity.sprite.vbo.IUniformColorSpriteVertexBufferObject {
  
}
interface org.andengine.entity.text.vbo.ITextVertexBufferObject {
 + void onUpdateColor(final Text pText)
 
}
interface org.andengine.entity.util.ScreenGrabber {
 # void onManagedDraw(final GLState pGLState, final Camera pCamera) 
# void onManagedUpdate(final float pSecondsElapsed) 
+ void reset() 
+ void grab(final int pGrabWidth, final int pGrabHeight, final IScreenGrabberCallback pScreenGrabCallback) 
+ void grab(final int pGrabX, final int pGrabY, final int pGrabWidth, final int pGrabHeight, final IScreenGrabberCallback pScreenGrabCallback) 
- {static} Bitmap grab(final int pGrabX, final int pGrabY, final int pGrabWidth, final int pGrabHeight) 
+ void onScreenGrabbed(final Bitmap pBitmap)
	- int mGrabX;
	- int mGrabY;
	- int mGrabWidth;
	- int mGrabHeight;
	- IScreenGrabberCallback mScreenGrabCallback;
 
}.IScreenGrabberCallback
interface org.andengine.input.sensor.acceleration.IAccelerationListener {
 + void onAccelerationAccuracyChanged(final AccelerationData pAccelerationData)
 
}
interface org.andengine.input.sensor.location.ILocationListener {
 + void onLocationProviderEnabled()
+ void onLocationChanged(final Location pLocation)
+ void onLocationProviderDisabled()
+ void onLocationProviderStatusChanged(final LocationProviderStatus pLocationProviderStatus, final Bundle pBundle)
 
}
interface org.andengine.input.sensor.orientation.IOrientationListener {
 + void onOrientationAccuracyChanged(final OrientationData pOrientationData)
 
}
interface org.andengine.input.touch.controller.ITouchController {
 + void setTouchEventCallback(final ITouchEventCallback pTouchEventCallback)
 
}
interface org.andengine.input.touch.controller.ITouchEventCallback {
 + boolean onTouchEvent(final TouchEvent pTouchEvent)
 
}
interface org.andengine.input.touch.detector.ClickDetector {
 + long getTriggerClickMaximumMilliseconds() 
+ void setTriggerClickMaximumMilliseconds(final long pClickMaximumMilliseconds) 
+ void reset() 
+ boolean onManagedTouchEvent(final TouchEvent pSceneTouchEvent) 
- void prepareClick(final TouchEvent pSceneTouchEvent) 
+ void onClick(final ClickDetector pClickDetector, final int pPointerID, final float pSceneX, final float pSceneY)
	- long mTriggerClickMaximumMilliseconds;
	- final IClickDetectorListener mClickDetectorListener;
 
}.IClickDetectorListener
interface org.andengine.opengl.font.IFont {
 + void load()
 
}
interface org.andengine.opengl.shader.constants.ShaderProgramConstants {
  
}
interface org.andengine.opengl.shader.source.IShaderSource {
 + String getShaderSource(final GLState pGLState)
 
}
interface org.andengine.opengl.texture.ITexture {
 + int getWidth()
+ void load()
+ void load(final GLState pGLState) 
+ void unload()
+ void unload(final GLState pGLState)
+ void bind(final GLState pGLState, final int pGLActiveTexture)
 
}
interface org.andengine.opengl.texture.ITextureStateListener {
 + void onLoadedToHardware(final ITexture pTexture)
 
}
interface org.andengine.opengl.texture.atlas.ITextureAtlas {
 + void addTextureAtlasSource(final T pTextureAtlasSource, final int pTextureX, final int pTextureY) 
+ void onTextureAtlasSourceLoaded(final ITextureAtlas<T> pTextureAtlas, final T pTextureAtlasSource) 
+ void onTextureAtlasSourceLoadExeption(final ITextureAtlas<T> pTextureAtlas, final T pTextureAtlasSource, final Throwable pThrowable) 
+ void onUnloadedFromHardware(final ITexture pTexture) 
+ void onLoadedToHardware(final ITexture pTexture) 
 
}
interface org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource {
 + IBitmapTextureAtlasSource deepCopy()
 
}
interface org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.IBitmapTextureAtlasSourceDecoratorShape {
 + void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureAtlasSourceDecoratorOptions pDecoratorOptions)
 
}
interface org.andengine.opengl.texture.atlas.buildable.IBuildableTextureAtlas {
 + void addTextureAtlasSource(final S pTextureAtlasSource, final int pTextureX, final int pTextureY)
+ void addTextureAtlasSource(final S pTextureAtlasSource, final int pTextureX, final int pTextureY, final int pTextureAtlasSourcePadding)
+ void addTextureAtlasSource(final S pTextureAtlasSource, final Callback<S> pCallback)
+ void removeTextureAtlasSource(final ITextureAtlasSource pTextureAtlasSource)
+ IBuildableTextureAtlas<S, T> build(final ITextureAtlasBuilder<S, T> pTextureAtlasBuilder) 
 
}
interface org.andengine.opengl.texture.atlas.buildable.builder.ITextureAtlasBuilder {
 + void build(final A pTextureAtlas, final ArrayList<TextureAtlasSourceWithWithLocationCallback<T>> pTextureAtlasSourcesWithLocationCallback) 
 
}
interface org.andengine.opengl.texture.atlas.source.ITextureAtlasSource {
 + int getTextureX()
 
}
interface org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.IPVRTexturePixelBufferStrategy {
 + IPVRTexturePixelBufferStrategyBufferManager newPVRTexturePixelBufferStrategyManager(final PVRTexture pPVRTexture) 
 
}
interface org.andengine.opengl.texture.region.ITextureRegion {
 + float getTextureX()
+ float getWidth()
+ float getHeight()
 
}
interface org.andengine.opengl.texture.region.ITiledTextureRegion {
 + int getCurrentTileIndex()
+ float getWidth(final int pTileIndex)
+ float getHeight(final int pTileIndex)
 
}
interface org.andengine.opengl.util.criteria.IGLCriteria {
 + boolean isMet(final GLState pGLState)
 
}
interface org.andengine.opengl.vbo.IVertexBufferObject {
 + boolean isAutoDispose()
+ void setNotLoadedToHardware()
+ void setDirtyOnHardware()
+ int getCapacity()
+ int getByteCapacity()
+ int getNativeHeapMemoryByteSize()
 
}
interface org.andengine.opengl.view.IRendererListener {
 + void onSurfaceCreated(final GLState pGlState)
 
}
interface org.andengine.ui.IGameInterface {
 + EngineOptions onCreateEngineOptions()
+ void onCreateSceneFinished(final Scene pScene)
+ void onPopulateSceneFinished()
 
}
interface org.andengine.util.Constants {
  
}
interface org.andengine.util.IDisposable {
 + boolean isDisposed()
 
}
interface org.andengine.util.IMatcher {
 + boolean matches(final T pObject)
 
}
interface org.andengine.util.adt.DataConstants {
  
}
interface org.andengine.util.adt.bounds.IBounds {
  
}
interface org.andengine.util.adt.bounds.IFloatBounds {
 + float getXMin()
 
}
interface org.andengine.util.adt.bounds.IIntBounds {
 + int getXMin()
 
}
interface org.andengine.util.adt.io.in.IInputStreamOpener {
 + InputStream open() 
 
}
interface org.andengine.util.adt.list.IFloatList {
 + boolean isEmpty()
 
}
interface org.andengine.util.adt.list.IIntList {
 + boolean isEmpty()
 
}
interface org.andengine.util.adt.list.IList {
 + boolean isEmpty()
 
}
interface org.andengine.util.adt.list.ILongList {
 + boolean isEmpty()
 
}
interface org.andengine.util.adt.list.ISortedList {
  
}
interface org.andengine.util.adt.list.IUniqueList {
  
}
interface org.andengine.util.adt.queue.IQueue {
 + T peek()
 
}
interface org.andengine.util.adt.queue.ISortedQueue {
  
}
interface org.andengine.util.adt.queue.IUniqueQueue {
  
}
interface org.andengine.util.adt.spatial.ISpatialItem {
 + B getBounds()
 
}
interface org.andengine.util.adt.trie.ITrie {
 + void add(final CharSequence pCharSequence)
 
}
interface org.andengine.util.algorithm.hull.IHullAlgorithm {
 + int computeHull(final float[] pVertices, final int pVertexCount, final int pVertexOffsetX, final int pVertexOffsetY, final int pStride)
 
}
interface org.andengine.util.algorithm.path.ICostFunction {
 + float getCost(final IPathFinderMap<T> pPathFinderMap, final int pFromX, final int pFromY, final int pToX, final int pToY, final T pEntity)
 
}
interface org.andengine.util.algorithm.path.IPathFinder {
 + Path findPath(final IPathFinderMap<T> pPathFinderMap, final int pXMin, final int pYMin, final int pXMax, final int pYMax, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY, final boolean pAllowDiagonal, final IAStarHeuristic<T> pAStarHeuristic, final ICostFunction<T> pCostFunction)
 
}
interface org.andengine.util.algorithm.path.IPathFinderMap {
 + boolean isBlocked(final int pX, final int pY, final T pEntity)
 
}
interface org.andengine.util.algorithm.path.astar.IAStarHeuristic {
 + float getExpectedRestCost(final IPathFinderMap<T> pPathFinderMap, final T pEntity, final int pFromX, final int pFromY, final int pToX, final int pToY)
 
}
interface org.andengine.util.call.AsyncCallable {
 + void call(final Callback<T> pCallback, final Callback<Exception> pExceptionCallback)
 
}
interface org.andengine.util.call.Callable {
 + T call() 
 
}
interface org.andengine.util.call.Callback {
 + void onCallback(final T pCallbackValue)
 
}
interface org.andengine.util.call.ParameterCallable {
 + void call(final T pParameter)
 
}
interface org.andengine.util.color.constants.ColorConstants {
  
}
interface org.andengine.util.level.IEntityLoader {
 + IEntity onLoadEntity(final String pEntityName, final Attributes pAttributes)
 
}
interface org.andengine.util.level.constants.LevelConstants {
  
}
interface org.andengine.util.math.MathConstants {
  
}
interface org.andengine.util.modifier.IModifier {
 + int compare(final IModifier<?> pModifierA, final IModifier<?> pModifierB) 
+ void reset()
 
}
interface org.andengine.util.modifier.IModifier.IModifierListener
interface org.andengine.util.modifier.ease.IEaseFunction {
 + float getPercentage(final float pSecondsElapsed, final float pDuration)
 
}
interface org.andengine.util.progress.IProgressListener {
 + void onProgressChanged(final int pProgress)
 
}
interface org.andengine.util.progress.ProgressCallable {
 + T call(final IProgressListener pProgressListener) 
 
}
interface org.andengine.util.time.TimeConstants {
  
}
org.andengine.audio.BaseAudioEntity --|> org.andengine.audio.IAudioEntity
org.andengine.audio.BaseAudioManager --|> org.andengine.audio.IAudioManager
org.andengine.engine.camera.hud.controls.BaseOnScreenControl --|> org.andengine.engine.camera.hud.HUD
org.andengine.engine.camera.hud.controls.BaseOnScreenControl --|> org.andengine.entity.scene.IOnSceneTouchListener
org.andengine.engine.handler.BaseEntityUpdateHandler --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.engine.options.resolutionpolicy.BaseResolutionPolicy --|> org.andengine.engine.options.resolutionpolicy.IResolutionPolicy
org.andengine.entity.modifier.DoubleValueChangeEntityModifier --|> org.andengine.util.modifier.BaseDoubleValueChangeModifier
org.andengine.entity.modifier.DoubleValueChangeEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.DoubleValueSpanEntityModifier --|> org.andengine.util.modifier.BaseDoubleValueSpanModifier
org.andengine.entity.modifier.DoubleValueSpanEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.DurationEntityModifier --|> org.andengine.util.modifier.BaseDurationModifier
org.andengine.entity.modifier.DurationEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.EntityModifier --|> org.andengine.util.modifier.BaseModifier
org.andengine.entity.modifier.EntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.SingleValueChangeEntityModifier --|> org.andengine.util.modifier.BaseSingleValueChangeModifier
org.andengine.entity.modifier.SingleValueChangeEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.SingleValueSpanEntityModifier --|> org.andengine.util.modifier.BaseSingleValueSpanModifier
org.andengine.entity.modifier.SingleValueSpanEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.TripleValueSpanEntityModifier --|> org.andengine.util.modifier.BaseTripleValueSpanModifier
org.andengine.entity.modifier.TripleValueSpanEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.particle.emitter.BaseCircleParticleEmitter --|> org.andengine.entity.particle.emitter.BaseParticleEmitter
org.andengine.entity.particle.emitter.BaseParticleEmitter --|> org.andengine.entity.particle.emitter.IParticleEmitter
org.andengine.entity.particle.emitter.BaseRectangleParticleEmitter --|> org.andengine.entity.particle.emitter.BaseParticleEmitter
org.andengine.entity.particle.initializer.BaseDoubleValueParticleInitializer --|> org.andengine.entity.particle.initializer.BaseSingleValueParticleInitializer
org.andengine.entity.particle.initializer.BaseSingleValueParticleInitializer --|> org.andengine.entity.particle.initializer.IParticleInitializer
org.andengine.entity.particle.initializer.BaseTripleValueParticleInitializer --|> org.andengine.entity.particle.initializer.BaseDoubleValueParticleInitializer
org.andengine.entity.particle.modifier.BaseDoubleValueSpanParticleModifier --|> org.andengine.entity.particle.modifier.BaseSingleValueSpanParticleModifier
org.andengine.entity.particle.modifier.BaseSingleValueSpanParticleModifier --|> org.andengine.entity.particle.modifier.IParticleModifier
org.andengine.entity.particle.modifier.BaseTripleValueSpanParticleModifier --|> org.andengine.entity.particle.modifier.BaseDoubleValueSpanParticleModifier
org.andengine.entity.scene.menu.animator.BaseMenuAnimator --|> org.andengine.entity.scene.menu.animator.IMenuAnimator
org.andengine.entity.scene.menu.item.decorator.BaseMenuItemDecorator --|> org.andengine.entity.scene.menu.item.IMenuItem
org.andengine.entity.shape.RectangularShape --|> org.andengine.entity.shape.Shape
org.andengine.entity.shape.RectangularShape --|> org.andengine.entity.shape.IAreaShape
org.andengine.entity.shape.Shape --|> org.andengine.entity.Entity
org.andengine.entity.shape.Shape --|> org.andengine.entity.shape.IShape
org.andengine.entity.sprite.batch.DynamicSpriteBatch --|> org.andengine.entity.sprite.batch.SpriteBatch
org.andengine.entity.util.AverageFPSCounter --|> org.andengine.entity.util.FPSCounter
org.andengine.input.touch.controller.BaseTouchController --|> org.andengine.input.touch.controller.ITouchController
org.andengine.input.touch.detector.BaseDetector --|> org.andengine.entity.scene.IOnSceneTouchListener
org.andengine.input.touch.detector.SurfaceGestureDetector --|> org.andengine.input.touch.detector.BaseDetector
org.andengine.opengl.texture.Texture --|> org.andengine.opengl.texture.ITexture
org.andengine.opengl.texture.atlas.TextureAtlas --|> org.andengine.opengl.texture.Texture
org.andengine.opengl.texture.atlas.TextureAtlas --|> org.andengine.opengl.texture.atlas.ITextureAtlas
org.andengine.opengl.texture.atlas.bitmap.source.PictureBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.PictureBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.ITextureAtlasSource
org.andengine.opengl.texture.compressed.etc1.ETC1Texture --|> org.andengine.opengl.texture.Texture
org.andengine.opengl.texture.compressed.pvr.PVRCCZTexture --|> org.andengine.opengl.texture.compressed.pvr.PVRTexture
org.andengine.opengl.texture.compressed.pvr.PVRGZTexture --|> org.andengine.opengl.texture.compressed.pvr.PVRTexture
org.andengine.opengl.texture.compressed.pvr.PVRTexture --|> org.andengine.opengl.texture.Texture
org.andengine.opengl.texture.region.BaseTextureRegion --|> org.andengine.opengl.texture.region.ITextureRegion
org.andengine.opengl.util.criteria.IntGLCriteria --|> org.andengine.opengl.util.criteria.IGLCriteria
org.andengine.opengl.util.criteria.StringGLCriteria --|> org.andengine.opengl.util.criteria.IGLCriteria
org.andengine.opengl.vbo.SharedMemoryVertexBufferObject --|> org.andengine.opengl.vbo.ZeroMemoryVertexBufferObject
org.andengine.opengl.vbo.VertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.opengl.vbo.ZeroMemoryVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.ui.activity.BaseActivity --|> android.app.Activity
org.andengine.ui.activity.BaseGameActivity --|> org.andengine.ui.activity.BaseActivity
org.andengine.ui.activity.BaseGameActivity --|> org.andengine.opengl.view.IRendererListener
org.andengine.ui.activity.BaseGameActivity --|> org.andengine.ui.IGameInterface
org.andengine.ui.activity.LayoutGameActivity --|> org.andengine.ui.activity.BaseGameActivity
org.andengine.ui.activity.LegacyBaseGameActivity --|> org.andengine.ui.activity.BaseGameActivity
org.andengine.ui.activity.SimpleAsyncGameActivity --|> org.andengine.ui.activity.BaseGameActivity
org.andengine.ui.activity.SimpleBaseGameActivity --|> org.andengine.ui.activity.BaseGameActivity
org.andengine.ui.activity.SimpleLayoutGameActivity --|> org.andengine.ui.activity.LayoutGameActivity
org.andengine.util.adt.pool.Pool --|> org.andengine.util.adt.pool.GenericPool
org.andengine.util.adt.pool.PoolUpdateHandler --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.util.adt.pool.RunnablePoolItem --|> org.andengine.util.adt.pool.PoolItem
org.andengine.util.adt.pool.RunnablePoolUpdateHandler --|> org.andengine.util.adt.pool.PoolUpdateHandler
org.andengine.util.adt.spatial.quadtree.QuadTree --|> org.andengine.util.adt.bounds.IBounds
org.andengine.util.modifier.BaseDoubleValueChangeModifier --|> org.andengine.util.modifier.BaseSingleValueChangeModifier
org.andengine.util.modifier.BaseDoubleValueSpanModifier --|> org.andengine.util.modifier.BaseSingleValueSpanModifier
org.andengine.util.modifier.BaseDurationModifier --|> org.andengine.util.modifier.BaseModifier
org.andengine.util.modifier.BaseModifier --|> org.andengine.util.modifier.IModifier
org.andengine.util.modifier.BaseQuadrupelValueSpanModifier --|> org.andengine.util.modifier.BaseTripleValueSpanModifier
org.andengine.util.modifier.BaseSingleValueChangeModifier --|> org.andengine.util.modifier.BaseDurationModifier
org.andengine.util.modifier.BaseSingleValueSpanModifier --|> org.andengine.util.modifier.BaseDurationModifier
org.andengine.util.modifier.BaseTripleValueSpanModifier --|> org.andengine.util.modifier.BaseDoubleValueSpanModifier
org.andengine.audio.exception.AudioException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.audio.music.Music --|> org.andengine.audio.BaseAudioEntity
org.andengine.audio.music.MusicLibrary --|> org.andengine.util.adt.map.Library
org.andengine.audio.music.MusicManager --|> org.andengine.audio.BaseAudioManager
org.andengine.audio.music.exception.MusicException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.audio.music.exception.MusicReleasedException --|> org.andengine.audio.music.exception.MusicException
org.andengine.audio.sound.Sound --|> org.andengine.audio.BaseAudioEntity
org.andengine.audio.sound.SoundLibrary --|> org.andengine.util.adt.map.Library
org.andengine.audio.sound.SoundManager --|> org.andengine.audio.BaseAudioManager
org.andengine.audio.sound.SoundManager --|> android.media.SoundPool.OnLoadCompleteListener
org.andengine.audio.sound.exception.SoundException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.audio.sound.exception.SoundReleasedException --|> org.andengine.audio.sound.exception.SoundException
org.andengine.engine.Engine --|> android.hardware.SensorEventListener
org.andengine.engine.Engine --|> android.location.LocationListener
org.andengine.engine.Engine --|> android.view.View.OnTouchListener
org.andengine.engine.Engine --|> org.andengine.input.touch.controller.ITouchEventCallback
org.andengine.engine.FixedStepEngine --|> org.andengine.engine.Engine
org.andengine.engine.LimitedFPSEngine --|> org.andengine.engine.Engine
org.andengine.engine.camera.BoundCamera --|> org.andengine.engine.camera.Camera
org.andengine.engine.camera.Camera --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.engine.camera.SmoothCamera --|> org.andengine.engine.camera.ZoomCamera
org.andengine.engine.camera.ZoomCamera --|> org.andengine.engine.camera.BoundCamera
org.andengine.engine.camera.hud.HUD --|> org.andengine.entity.scene.CameraScene
org.andengine.engine.camera.hud.controls.AnalogOnScreenControl --|> org.andengine.engine.camera.hud.controls.BaseOnScreenControl
org.andengine.engine.camera.hud.controls.AnalogOnScreenControl --|> org.andengine.input.touch.detector.ClickDetector.IClickDetectorListener
org.andengine.engine.camera.hud.controls.DigitalOnScreenControl --|> org.andengine.engine.camera.hud.controls.BaseOnScreenControl
org.andengine.engine.handler.DrawHandlerList --|> org.andengine.util.adt.list.SmartList
org.andengine.engine.handler.DrawHandlerList --|> org.andengine.engine.handler.IDrawHandler
org.andengine.engine.handler.UpdateHandlerList --|> org.andengine.util.adt.list.SmartList
org.andengine.engine.handler.UpdateHandlerList --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.engine.handler.collision.CollisionHandler --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.engine.handler.physics.PhysicsHandler --|> org.andengine.engine.handler.BaseEntityUpdateHandler
org.andengine.engine.handler.runnable.RunnableHandler --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.engine.handler.timer.TimerHandler --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.engine.options.resolutionpolicy.FillResolutionPolicy --|> org.andengine.engine.options.resolutionpolicy.BaseResolutionPolicy
org.andengine.engine.options.resolutionpolicy.FixedResolutionPolicy --|> org.andengine.engine.options.resolutionpolicy.BaseResolutionPolicy
org.andengine.engine.options.resolutionpolicy.RatioResolutionPolicy --|> org.andengine.engine.options.resolutionpolicy.BaseResolutionPolicy
org.andengine.engine.options.resolutionpolicy.RelativeResolutionPolicy --|> org.andengine.engine.options.resolutionpolicy.BaseResolutionPolicy
org.andengine.engine.splitscreen.DoubleSceneSplitScreenEngine --|> org.andengine.engine.Engine
org.andengine.engine.splitscreen.SingleSceneSplitScreenEngine --|> org.andengine.engine.Engine
org.andengine.entity.Entity --|> org.andengine.entity.IEntity
org.andengine.entity.TagEntityMatcher --|> org.andengine.entity.IEntityMatcher
org.andengine.entity.ZIndexSorter --|> org.andengine.util.algorithm.sort.InsertionSorter
org.andengine.entity.modifier.AlphaModifier --|> org.andengine.entity.modifier.SingleValueSpanEntityModifier
org.andengine.entity.modifier.CardinalSplineMoveModifier --|> org.andengine.entity.modifier.DurationEntityModifier
org.andengine.entity.modifier.CatmullRomSplineMoveModifier --|> org.andengine.entity.modifier.CardinalSplineMoveModifier
org.andengine.entity.modifier.ColorModifier --|> org.andengine.entity.modifier.TripleValueSpanEntityModifier
org.andengine.entity.modifier.CubicBezierCurveMoveModifier --|> org.andengine.entity.modifier.DurationEntityModifier
org.andengine.entity.modifier.DelayModifier --|> org.andengine.entity.modifier.DurationEntityModifier
org.andengine.entity.modifier.EntityModifierList --|> org.andengine.util.modifier.ModifierList
org.andengine.entity.modifier.FadeInModifier --|> org.andengine.entity.modifier.AlphaModifier
org.andengine.entity.modifier.FadeOutModifier --|> org.andengine.entity.modifier.AlphaModifier
org.andengine.entity.modifier.JumpModifier --|> org.andengine.entity.modifier.MoveModifier
org.andengine.entity.modifier.LoopEntityModifier --|> org.andengine.util.modifier.LoopModifier
org.andengine.entity.modifier.LoopEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.MoveByModifier --|> org.andengine.entity.modifier.DoubleValueChangeEntityModifier
org.andengine.entity.modifier.MoveModifier --|> org.andengine.entity.modifier.DoubleValueSpanEntityModifier
org.andengine.entity.modifier.MoveXModifier --|> org.andengine.entity.modifier.SingleValueSpanEntityModifier
org.andengine.entity.modifier.MoveYModifier --|> org.andengine.entity.modifier.SingleValueSpanEntityModifier
org.andengine.entity.modifier.ParallelEntityModifier --|> org.andengine.util.modifier.ParallelModifier
org.andengine.entity.modifier.ParallelEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.PathModifier --|> org.andengine.entity.modifier.EntityModifier
org.andengine.entity.modifier.QuadraticBezierCurveMoveModifier --|> org.andengine.entity.modifier.DurationEntityModifier
org.andengine.entity.modifier.RotationAtModifier --|> org.andengine.entity.modifier.RotationModifier
org.andengine.entity.modifier.RotationByModifier --|> org.andengine.entity.modifier.SingleValueChangeEntityModifier
org.andengine.entity.modifier.RotationModifier --|> org.andengine.entity.modifier.SingleValueSpanEntityModifier
org.andengine.entity.modifier.ScaleAtModifier --|> org.andengine.entity.modifier.ScaleModifier
org.andengine.entity.modifier.ScaleModifier --|> org.andengine.entity.modifier.DoubleValueSpanEntityModifier
org.andengine.entity.modifier.SequenceEntityModifier --|> org.andengine.util.modifier.SequenceModifier
org.andengine.entity.modifier.SequenceEntityModifier --|> org.andengine.entity.modifier.IEntityModifier
org.andengine.entity.modifier.SkewModifier --|> org.andengine.entity.modifier.DoubleValueSpanEntityModifier
org.andengine.entity.modifier.SkewXModifier --|> org.andengine.entity.modifier.SingleValueSpanEntityModifier
org.andengine.entity.modifier.SkewYModifier --|> org.andengine.entity.modifier.SingleValueSpanEntityModifier
org.andengine.entity.particle.BatchedPseudoSpriteParticleSystem --|> org.andengine.entity.particle.BlendFunctionParticleSystem
org.andengine.entity.particle.BatchedSpriteParticleSystem --|> org.andengine.entity.particle.BlendFunctionParticleSystem
org.andengine.entity.particle.BlendFunctionParticleSystem --|> org.andengine.entity.particle.ParticleSystem
org.andengine.entity.particle.ParticleSystem --|> org.andengine.entity.Entity
org.andengine.entity.particle.SpriteParticleSystem --|> org.andengine.entity.particle.ParticleSystem
org.andengine.entity.particle.emitter.CircleOutlineParticleEmitter --|> org.andengine.entity.particle.emitter.BaseCircleParticleEmitter
org.andengine.entity.particle.emitter.CircleParticleEmitter --|> org.andengine.entity.particle.emitter.BaseCircleParticleEmitter
org.andengine.entity.particle.emitter.PointParticleEmitter --|> org.andengine.entity.particle.emitter.BaseParticleEmitter
org.andengine.entity.particle.emitter.RectangleOutlineParticleEmitter --|> org.andengine.entity.particle.emitter.BaseRectangleParticleEmitter
org.andengine.entity.particle.emitter.RectangleParticleEmitter --|> org.andengine.entity.particle.emitter.BaseRectangleParticleEmitter
org.andengine.entity.particle.initializer.AccelerationParticleInitializer --|> org.andengine.entity.particle.initializer.BaseDoubleValueParticleInitializer
org.andengine.entity.particle.initializer.AlphaParticleInitializer --|> org.andengine.entity.particle.initializer.BaseSingleValueParticleInitializer
org.andengine.entity.particle.initializer.BlendFunctionParticleInitializer --|> org.andengine.entity.particle.initializer.IParticleInitializer
org.andengine.entity.particle.initializer.ColorParticleInitializer --|> org.andengine.entity.particle.initializer.BaseTripleValueParticleInitializer
org.andengine.entity.particle.initializer.GravityParticleInitializer --|> org.andengine.entity.particle.initializer.AccelerationParticleInitializer
org.andengine.entity.particle.initializer.RotationParticleInitializer --|> org.andengine.entity.particle.initializer.BaseSingleValueParticleInitializer
org.andengine.entity.particle.initializer.ScaleParticleInitializer --|> org.andengine.entity.particle.initializer.BaseSingleValueParticleInitializer
org.andengine.entity.particle.initializer.VelocityParticleInitializer --|> org.andengine.entity.particle.initializer.BaseDoubleValueParticleInitializer
org.andengine.entity.particle.modifier.AlphaParticleModifier --|> org.andengine.entity.particle.modifier.BaseSingleValueSpanParticleModifier
org.andengine.entity.particle.modifier.ColorParticleModifier --|> org.andengine.entity.particle.modifier.BaseTripleValueSpanParticleModifier
org.andengine.entity.particle.modifier.ExpireParticleInitializer --|> org.andengine.entity.particle.initializer.IParticleInitializer
org.andengine.entity.particle.modifier.OffCameraExpireParticleModifier --|> org.andengine.entity.particle.modifier.IParticleModifier
org.andengine.entity.particle.modifier.RotationParticleModifier --|> org.andengine.entity.particle.modifier.BaseSingleValueSpanParticleModifier
org.andengine.entity.particle.modifier.ScaleParticleModifier --|> org.andengine.entity.particle.modifier.BaseDoubleValueSpanParticleModifier
org.andengine.entity.primitive.Line --|> org.andengine.entity.shape.Shape
org.andengine.entity.primitive.Mesh --|> org.andengine.entity.shape.Shape
org.andengine.entity.primitive.Rectangle --|> org.andengine.entity.shape.RectangularShape
org.andengine.entity.primitive.vbo.HighPerformanceLineVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.primitive.vbo.HighPerformanceLineVertexBufferObject --|> org.andengine.entity.primitive.vbo.ILineVertexBufferObject
org.andengine.entity.primitive.vbo.HighPerformanceMeshVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.primitive.vbo.HighPerformanceMeshVertexBufferObject --|> org.andengine.entity.primitive.vbo.IMeshVertexBufferObject
org.andengine.entity.primitive.vbo.HighPerformanceRectangleVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.primitive.vbo.HighPerformanceRectangleVertexBufferObject --|> org.andengine.entity.primitive.vbo.IRectangleVertexBufferObject
org.andengine.entity.primitive.vbo.LowMemoryLineVertexBufferObject --|> org.andengine.opengl.vbo.LowMemoryVertexBufferObject
org.andengine.entity.primitive.vbo.LowMemoryLineVertexBufferObject --|> org.andengine.entity.primitive.vbo.ILineVertexBufferObject
org.andengine.entity.primitive.vbo.LowMemoryRectangleVertexBufferObject --|> org.andengine.opengl.vbo.LowMemoryVertexBufferObject
org.andengine.entity.primitive.vbo.LowMemoryRectangleVertexBufferObject --|> org.andengine.entity.primitive.vbo.IRectangleVertexBufferObject
org.andengine.entity.scene.CameraScene --|> org.andengine.entity.scene.Scene
org.andengine.entity.scene.Scene --|> org.andengine.entity.Entity
org.andengine.entity.scene.background.AutoParallaxBackground --|> org.andengine.entity.scene.background.ParallaxBackground
org.andengine.entity.scene.background.Background --|> org.andengine.entity.scene.background.IBackground
org.andengine.entity.scene.background.EntityBackground --|> org.andengine.entity.scene.background.Background
org.andengine.entity.scene.background.ParallaxBackground --|> org.andengine.entity.scene.background.Background
org.andengine.entity.scene.background.RepeatingSpriteBackground --|> org.andengine.entity.scene.background.SpriteBackground
org.andengine.entity.scene.background.SpriteBackground --|> org.andengine.entity.scene.background.EntityBackground
org.andengine.entity.scene.background.modifier.ColorBackgroundModifier --|> org.andengine.util.modifier.BaseTripleValueSpanModifier
org.andengine.entity.scene.background.modifier.ColorBackgroundModifier --|> org.andengine.entity.scene.background.modifier.IBackgroundModifier
org.andengine.entity.scene.background.modifier.LoopBackgroundModifier --|> org.andengine.util.modifier.LoopModifier
org.andengine.entity.scene.background.modifier.LoopBackgroundModifier --|> org.andengine.entity.scene.background.modifier.IBackgroundModifier
org.andengine.entity.scene.background.modifier.ParallelBackgroundModifier --|> org.andengine.util.modifier.ParallelModifier
org.andengine.entity.scene.background.modifier.ParallelBackgroundModifier --|> org.andengine.entity.scene.background.modifier.IBackgroundModifier
org.andengine.entity.scene.background.modifier.SequenceBackgroundModifier --|> org.andengine.util.modifier.SequenceModifier
org.andengine.entity.scene.background.modifier.SequenceBackgroundModifier --|> org.andengine.entity.scene.background.modifier.IBackgroundModifier
org.andengine.entity.scene.menu.MenuScene --|> org.andengine.entity.scene.CameraScene
org.andengine.entity.scene.menu.MenuScene --|> org.andengine.entity.scene.IOnAreaTouchListener
org.andengine.entity.scene.menu.MenuScene --|> org.andengine.entity.scene.IOnSceneTouchListener
org.andengine.entity.scene.menu.animator.AlphaMenuAnimator --|> org.andengine.entity.scene.menu.animator.BaseMenuAnimator
org.andengine.entity.scene.menu.animator.DirectMenuAnimator --|> org.andengine.entity.scene.menu.animator.BaseMenuAnimator
org.andengine.entity.scene.menu.animator.SlideMenuAnimator --|> org.andengine.entity.scene.menu.animator.BaseMenuAnimator
org.andengine.entity.scene.menu.item.AnimatedSpriteMenuItem --|> org.andengine.entity.sprite.AnimatedSprite
org.andengine.entity.scene.menu.item.AnimatedSpriteMenuItem --|> org.andengine.entity.scene.menu.item.IMenuItem
org.andengine.entity.scene.menu.item.SpriteMenuItem --|> org.andengine.entity.sprite.Sprite
org.andengine.entity.scene.menu.item.SpriteMenuItem --|> org.andengine.entity.scene.menu.item.IMenuItem
org.andengine.entity.scene.menu.item.TextMenuItem --|> org.andengine.entity.text.Text
org.andengine.entity.scene.menu.item.TextMenuItem --|> org.andengine.entity.scene.menu.item.IMenuItem
org.andengine.entity.scene.menu.item.decorator.ColorMenuItemDecorator --|> org.andengine.entity.scene.menu.item.decorator.BaseMenuItemDecorator
org.andengine.entity.scene.menu.item.decorator.ScaleMenuItemDecorator --|> org.andengine.entity.scene.menu.item.decorator.BaseMenuItemDecorator
org.andengine.entity.sprite.AnimatedSprite --|> org.andengine.entity.sprite.TiledSprite
org.andengine.entity.sprite.AnimationData --|> org.andengine.entity.sprite.IAnimationData
org.andengine.entity.sprite.ButtonSprite --|> org.andengine.entity.sprite.TiledSprite
org.andengine.entity.sprite.DiamondSprite --|> org.andengine.entity.sprite.Sprite
org.andengine.entity.sprite.Sprite --|> org.andengine.entity.shape.RectangularShape
org.andengine.entity.sprite.TiledSprite --|> org.andengine.entity.sprite.Sprite
org.andengine.entity.sprite.UncoloredSprite --|> org.andengine.entity.sprite.Sprite
org.andengine.entity.sprite.UniformColorSprite --|> org.andengine.entity.sprite.Sprite
org.andengine.entity.sprite.batch.SpriteBatch --|> org.andengine.entity.shape.Shape
org.andengine.entity.sprite.batch.SpriteGroup --|> org.andengine.entity.sprite.batch.DynamicSpriteBatch
org.andengine.entity.sprite.batch.vbo.HighPerformanceSpriteBatchVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.sprite.batch.vbo.HighPerformanceSpriteBatchVertexBufferObject --|> org.andengine.entity.sprite.batch.vbo.ISpriteBatchVertexBufferObject
org.andengine.entity.sprite.batch.vbo.LowMemorySpriteBatchVertexBufferObject --|> org.andengine.opengl.vbo.LowMemoryVertexBufferObject
org.andengine.entity.sprite.batch.vbo.LowMemorySpriteBatchVertexBufferObject --|> org.andengine.entity.sprite.batch.vbo.ISpriteBatchVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceDiamondSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.HighPerformanceSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceDiamondSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.IDiamondSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceSpriteVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceTiledSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.HighPerformanceSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceTiledSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ITiledSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceUncoloredSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.HighPerformanceSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceUncoloredSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.IUncoloredSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceUniformColorSpriteVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.sprite.vbo.HighPerformanceUniformColorSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.IUniformColorSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryDiamondSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.LowMemorySpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryDiamondSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.IDiamondSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemorySpriteVertexBufferObject --|> org.andengine.opengl.vbo.LowMemoryVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemorySpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryTiledSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.LowMemorySpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryTiledSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ITiledSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryUncoloredSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.LowMemorySpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryUncoloredSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.IUncoloredSpriteVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryUniformColorSpriteVertexBufferObject --|> org.andengine.opengl.vbo.LowMemoryVertexBufferObject
org.andengine.entity.sprite.vbo.LowMemoryUniformColorSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.IUniformColorSpriteVertexBufferObject
org.andengine.entity.text.Text --|> org.andengine.entity.shape.RectangularShape
org.andengine.entity.text.TickerText --|> org.andengine.entity.text.Text
org.andengine.entity.text.exception.OutOfCharactersException --|> org.andengine.entity.text.exception.TextException
org.andengine.entity.text.exception.TextException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.entity.text.vbo.HighPerformanceTextVertexBufferObject --|> org.andengine.opengl.vbo.HighPerformanceVertexBufferObject
org.andengine.entity.text.vbo.HighPerformanceTextVertexBufferObject --|> org.andengine.entity.text.vbo.ITextVertexBufferObject
org.andengine.entity.text.vbo.LowMemoryTextVertexBufferObject --|> org.andengine.opengl.vbo.LowMemoryVertexBufferObject
org.andengine.entity.text.vbo.LowMemoryTextVertexBufferObject --|> org.andengine.entity.text.vbo.ITextVertexBufferObject
org.andengine.entity.util.FPSCounter --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.entity.util.FPSLogger --|> org.andengine.entity.util.AverageFPSCounter
org.andengine.entity.util.FrameCountCrasher --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.entity.util.FrameCounter --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.entity.util.ScreenCapture --|> org.andengine.entity.Entity
org.andengine.entity.util.ScreenCapture --|> org.andengine.entity.util.ScreenGrabber.IScreenGrabberCallback
org.andengine.entity.util.ScreenGrabber --|> org.andengine.entity.Entity
org.andengine.input.sensor.acceleration.AccelerationData --|> org.andengine.input.sensor.BaseSensorData
org.andengine.input.sensor.location.LocationSensorOptions --|> android.location.Criteria
org.andengine.input.sensor.orientation.OrientationData --|> org.andengine.input.sensor.BaseSensorData
org.andengine.input.touch.controller.MultiTouchController --|> org.andengine.input.touch.controller.BaseTouchController
org.andengine.input.touch.controller.SingleTouchController --|> org.andengine.input.touch.controller.BaseTouchController
org.andengine.input.touch.detector.ClickDetector --|> org.andengine.input.touch.detector.BaseDetector
org.andengine.input.touch.detector.ContinuousHoldDetector --|> org.andengine.input.touch.detector.HoldDetector
org.andengine.input.touch.detector.ContinuousHoldDetector --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.input.touch.detector.HoldDetector --|> org.andengine.input.touch.detector.BaseDetector
org.andengine.input.touch.detector.PinchZoomDetector --|> org.andengine.input.touch.detector.BaseDetector
org.andengine.input.touch.detector.ScrollDetector --|> org.andengine.input.touch.detector.BaseDetector
org.andengine.input.touch.detector.SurfaceGestureDetectorAdapter --|> org.andengine.input.touch.detector.SurfaceGestureDetector
org.andengine.input.touch.detector.SurfaceScrollDetector --|> org.andengine.input.touch.detector.ScrollDetector
org.andengine.opengl.exception.GLFrameBufferException --|> org.andengine.opengl.exception.GLException
org.andengine.opengl.exception.RenderTextureInitializationException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.opengl.font.BitmapFont --|> org.andengine.opengl.font.IFont
org.andengine.opengl.font.Font --|> org.andengine.opengl.font.IFont
org.andengine.opengl.font.FontLibrary --|> org.andengine.util.adt.map.Library
org.andengine.opengl.font.StrokeFont --|> org.andengine.opengl.font.Font
org.andengine.opengl.font.exception.FontException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.opengl.font.exception.LetterNotFoundException --|> org.andengine.opengl.font.exception.FontException
org.andengine.opengl.shader.PositionColorShaderProgram --|> org.andengine.opengl.shader.ShaderProgram
org.andengine.opengl.shader.PositionColorTextureCoordinatesShaderProgram --|> org.andengine.opengl.shader.ShaderProgram
org.andengine.opengl.shader.PositionTextureCoordinatesPositionInterpolationTextureSelectShaderProgram --|> org.andengine.opengl.shader.ShaderProgram
org.andengine.opengl.shader.PositionTextureCoordinatesShaderProgram --|> org.andengine.opengl.shader.ShaderProgram
org.andengine.opengl.shader.PositionTextureCoordinatesTextureSelectShaderProgram --|> org.andengine.opengl.shader.ShaderProgram
org.andengine.opengl.shader.PositionTextureCoordinatesUniformColorShaderProgram --|> org.andengine.opengl.shader.ShaderProgram
org.andengine.opengl.shader.exception.ShaderProgramCompileException --|> org.andengine.opengl.shader.exception.ShaderProgramException
org.andengine.opengl.shader.exception.ShaderProgramException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.opengl.shader.exception.ShaderProgramLinkException --|> org.andengine.opengl.shader.exception.ShaderProgramException
org.andengine.opengl.shader.source.CriteriaShaderSource --|> org.andengine.opengl.shader.source.IShaderSource
org.andengine.opengl.shader.source.StringShaderSource --|> org.andengine.opengl.shader.source.IShaderSource
org.andengine.opengl.texture.DebugTextureStateListener --|> org.andengine.opengl.texture.ITextureStateListener
org.andengine.opengl.texture.TextureStateAdapter --|> org.andengine.opengl.texture.ITextureStateListener
org.andengine.opengl.texture.TextureWarmUpVertexBufferObject --|> org.andengine.opengl.vbo.VertexBufferObject
org.andengine.opengl.texture.atlas.bitmap.BitmapTextureAtlas --|> org.andengine.opengl.texture.atlas.TextureAtlas
org.andengine.opengl.texture.atlas.bitmap.BuildableBitmapTextureAtlas --|> org.andengine.opengl.texture.atlas.buildable.BuildableTextureAtlas
org.andengine.opengl.texture.atlas.bitmap.source.AssetBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.AssetBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.EmptyBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.EmptyBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.FileBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.FileBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.ResourceBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.BaseTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.ResourceBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource
org.andengine.opengl.texture.atlas.bitmap.source.decorator.ColorKeyBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.ColorSwapBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.bitmap.source.decorator.ColorSwapBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.bitmap.source.decorator.FillBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.bitmap.source.decorator.LinearGradientFillBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.bitmap.source.decorator.OutlineBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.bitmap.source.decorator.RadialGradientFillBitmapTextureAtlasSourceDecorator --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.BaseShapeBitmapTextureAtlasSourceDecorator
org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.ArcBitmapTextureAtlasSourceDecoratorShape --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.IBitmapTextureAtlasSourceDecoratorShape
org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.CircleBitmapTextureAtlasSourceDecoratorShape --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.IBitmapTextureAtlasSourceDecoratorShape
org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.EllipseBitmapTextureAtlasSourceDecoratorShape --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.IBitmapTextureAtlasSourceDecoratorShape
org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.RectangleBitmapTextureAtlasSourceDecoratorShape --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.IBitmapTextureAtlasSourceDecoratorShape
org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.RoundedRectangleBitmapTextureAtlasSourceDecoratorShape --|> org.andengine.opengl.texture.atlas.bitmap.source.decorator.shape.IBitmapTextureAtlasSourceDecoratorShape
org.andengine.opengl.texture.atlas.buildable.BuildableTextureAtlas --|> org.andengine.opengl.texture.atlas.buildable.IBuildableTextureAtlas
org.andengine.opengl.texture.atlas.buildable.builder.BlackPawnTextureAtlasBuilder --|> org.andengine.opengl.texture.atlas.buildable.builder.ITextureAtlasBuilder
org.andengine.opengl.texture.bitmap.AssetBitmapTexture --|> org.andengine.opengl.texture.bitmap.BitmapTexture
org.andengine.opengl.texture.bitmap.BitmapTexture --|> org.andengine.opengl.texture.Texture
org.andengine.opengl.texture.bitmap.ResourceBitmapTexture --|> org.andengine.opengl.texture.bitmap.BitmapTexture
org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.GreedyPVRTexturePixelBufferStrategy --|> org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.IPVRTexturePixelBufferStrategy
org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.SmartPVRTexturePixelBufferStrategy --|> org.andengine.opengl.texture.compressed.pvr.pixelbufferstrategy.IPVRTexturePixelBufferStrategy
org.andengine.opengl.texture.region.TextureRegion --|> org.andengine.opengl.texture.region.BaseTextureRegion
org.andengine.opengl.texture.region.TextureRegionLibrary --|> org.andengine.util.adt.map.Library
org.andengine.opengl.texture.region.TiledTextureRegion --|> org.andengine.opengl.texture.region.BaseTextureRegion
org.andengine.opengl.texture.region.TiledTextureRegion --|> org.andengine.opengl.texture.region.ITiledTextureRegion
org.andengine.opengl.texture.render.RenderTexture --|> org.andengine.opengl.texture.Texture
org.andengine.opengl.util.criteria.AndroidVersionCodeGLCriteria --|> org.andengine.opengl.util.criteria.IntGLCriteria
org.andengine.opengl.util.criteria.BuildModelGLCriteria --|> org.andengine.opengl.util.criteria.StringGLCriteria
org.andengine.opengl.util.criteria.GLExtensionsGLCriteria --|> org.andengine.opengl.util.criteria.StringGLCriteria
org.andengine.opengl.util.criteria.GLRendererGLCriteria --|> org.andengine.opengl.util.criteria.StringGLCriteria
org.andengine.opengl.util.criteria.GLVersionGLCriteria --|> org.andengine.opengl.util.criteria.StringGLCriteria
org.andengine.opengl.util.criteria.LogicalAndGLCriteria --|> org.andengine.opengl.util.criteria.IGLCriteria
org.andengine.opengl.util.criteria.LogicalOrGLCriteria --|> org.andengine.opengl.util.criteria.IGLCriteria
org.andengine.opengl.vbo.HighPerformanceVertexBufferObject --|> org.andengine.opengl.vbo.VertexBufferObject
org.andengine.opengl.vbo.LowMemoryVertexBufferObject --|> org.andengine.opengl.vbo.VertexBufferObject
org.andengine.opengl.vbo.attribute.VertexBufferObjectAttributeFix --|> org.andengine.opengl.vbo.attribute.VertexBufferObjectAttribute
org.andengine.opengl.view.ConfigChooser --|> GLSurfaceView.EGLConfigChooser
org.andengine.opengl.view.EngineRenderer --|> GLSurfaceView.Renderer
org.andengine.opengl.view.RenderSurfaceView --|> android.opengl.GLSurfaceView
org.andengine.ui.dialog.StringInputDialogBuilder --|> org.andengine.ui.dialog.GenericInputDialogBuilder
org.andengine.util.TimeUtils --|> org.andengine.util.time.TimeConstants
org.andengine.util.adt.bounds.FloatBounds --|> org.andengine.util.adt.bounds.IFloatBounds
org.andengine.util.adt.bounds.IntBounds --|> org.andengine.util.adt.bounds.IIntBounds
org.andengine.util.adt.cache.concurrent.SynchronizedIntLRUCache --|> org.andengine.util.adt.cache.IntLRUCache
org.andengine.util.adt.cache.concurrent.SynchronizedLRUCache --|> org.andengine.util.adt.cache.LRUCache
org.andengine.util.adt.io.in.AssetInputStreamOpener --|> org.andengine.util.adt.io.in.IInputStreamOpener
org.andengine.util.adt.io.in.ByteArrayInputStreamOpener --|> org.andengine.util.adt.io.in.IInputStreamOpener
org.andengine.util.adt.io.in.ResourceInputStreamOpener --|> org.andengine.util.adt.io.in.IInputStreamOpener
org.andengine.util.adt.list.CircularList --|> org.andengine.util.adt.list.IList
org.andengine.util.adt.list.FloatArrayList --|> org.andengine.util.adt.list.IFloatList
org.andengine.util.adt.list.IntArrayList --|> org.andengine.util.adt.list.IIntList
org.andengine.util.adt.list.LongArrayList --|> org.andengine.util.adt.list.ILongList
org.andengine.util.adt.list.ShiftList --|> org.andengine.util.adt.queue.IQueue
org.andengine.util.adt.list.SortedList --|> org.andengine.util.adt.list.ISortedList
org.andengine.util.adt.list.UniqueList --|> org.andengine.util.adt.list.ISortedList
org.andengine.util.adt.list.concurrent.SynchronizedList --|> org.andengine.util.adt.list.IList
org.andengine.util.adt.pool.EntityDetachRunnablePoolItem --|> org.andengine.util.adt.pool.RunnablePoolItem
org.andengine.util.adt.pool.EntityDetachRunnablePoolUpdateHandler --|> org.andengine.util.adt.pool.RunnablePoolUpdateHandler
org.andengine.util.adt.queue.CircularQueue --|> org.andengine.util.adt.list.CircularList
org.andengine.util.adt.queue.CircularQueue --|> org.andengine.util.adt.queue.IQueue
org.andengine.util.adt.queue.ShiftQueue --|> org.andengine.util.adt.list.ShiftList
org.andengine.util.adt.queue.SortedQueue --|> org.andengine.util.adt.list.SortedList
org.andengine.util.adt.queue.SortedQueue --|> org.andengine.util.adt.queue.ISortedQueue
org.andengine.util.adt.queue.UniqueQueue --|> org.andengine.util.adt.list.UniqueList
org.andengine.util.adt.queue.UniqueQueue --|> org.andengine.util.adt.queue.IUniqueQueue
org.andengine.util.adt.queue.concurrent.SynchronizedQueue --|> org.andengine.util.adt.queue.IQueue
org.andengine.util.adt.spatial.quadtree.FloatQuadTree --|> org.andengine.util.adt.spatial.quadtree.QuadTree
org.andengine.util.adt.spatial.quadtree.FloatQuadTree --|> org.andengine.util.adt.bounds.IFloatBounds
org.andengine.util.adt.spatial.quadtree.IntQuadTree --|> org.andengine.util.adt.spatial.quadtree.QuadTree
org.andengine.util.adt.spatial.quadtree.IntQuadTree --|> org.andengine.util.adt.bounds.IIntBounds
org.andengine.util.adt.trie.Trie --|> org.andengine.util.adt.trie.ITrie
org.andengine.util.algorithm.collision.LineCollisionChecker --|> org.andengine.util.algorithm.collision.ShapeCollisionChecker
org.andengine.util.algorithm.collision.RectangularShapeCollisionChecker --|> org.andengine.util.algorithm.collision.ShapeCollisionChecker
org.andengine.util.algorithm.collision.ShapeCollisionChecker --|> org.andengine.util.algorithm.collision.BaseCollisionChecker
org.andengine.util.algorithm.hull.JarvisMarch --|> org.andengine.util.algorithm.hull.IHullAlgorithm
org.andengine.util.algorithm.path.astar.AStarPathFinder --|> org.andengine.util.algorithm.path.IPathFinder
org.andengine.util.algorithm.path.astar.EuclideanHeuristic --|> org.andengine.util.algorithm.path.astar.IAStarHeuristic
org.andengine.util.algorithm.path.astar.ManhattanHeuristic --|> org.andengine.util.algorithm.path.astar.IAStarHeuristic
org.andengine.util.algorithm.path.astar.NullHeuristic --|> org.andengine.util.algorithm.path.astar.IAStarHeuristic
org.andengine.util.algorithm.sort.InsertionSorter --|> org.andengine.util.algorithm.sort.Sorter
org.andengine.util.animationpack.AnimationPackParser --|> org.xml.sax.helpers.DefaultHandler
org.andengine.util.animationpack.AnimationPackTiledTextureRegion --|> org.andengine.opengl.texture.region.TiledTextureRegion
org.andengine.util.animationpack.exception.AnimationPackParseException --|> org.xml.sax.SAXException
org.andengine.util.color.ColorPool --|> org.andengine.util.adt.pool.GenericPool
org.andengine.util.exception.CancelledException --|> org.andengine.util.exception.AndEngineException
org.andengine.util.exception.DeviceNotSupportedException --|> org.andengine.util.exception.AndEngineException
org.andengine.util.exception.MethodNotSupportedException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.util.exception.MethodNotYetImplementedException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.util.exception.NullBitmapException --|> org.andengine.util.exception.AndEngineRuntimeException
org.andengine.util.level.LevelParser --|> org.xml.sax.helpers.DefaultHandler
org.andengine.util.modifier.LoopModifier --|> org.andengine.util.modifier.BaseModifier
org.andengine.util.modifier.LoopModifier --|> org.andengine.util.modifier.IModifier.IModifierListener
org.andengine.util.modifier.ModifierList --|> org.andengine.util.adt.list.SmartList
org.andengine.util.modifier.ModifierList --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.util.modifier.ParallelModifier --|> org.andengine.util.modifier.BaseModifier
org.andengine.util.modifier.ParallelModifier --|> org.andengine.util.modifier.IModifier.IModifierListener
org.andengine.util.modifier.SequenceModifier --|> org.andengine.util.modifier.BaseModifier
org.andengine.util.modifier.SequenceModifier --|> org.andengine.util.modifier.IModifier.IModifierListener
org.andengine.util.modifier.ease.EaseBackIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseBackInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseBackOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseBounceIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseBounceInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseBounceOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseCircularIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseCircularInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseCircularOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseCubicIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseCubicInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseCubicOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseElasticIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseElasticInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseElasticOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseExponentialIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseExponentialInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseExponentialOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseLinear --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuadIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuadInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuadOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuartIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuartInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuartOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuintIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuintInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseQuintOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseSineIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseSineInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseSineOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseStrongIn --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseStrongInOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.modifier.ease.EaseStrongOut --|> org.andengine.util.modifier.ease.IEaseFunction
org.andengine.util.progress.ProgressMonitor --|> org.andengine.util.progress.IProgressListener
org.andengine.util.texturepack.TexturePackParser --|> org.xml.sax.helpers.DefaultHandler
org.andengine.util.texturepack.TexturePackTextureRegion --|> org.andengine.opengl.texture.region.TextureRegion
org.andengine.util.texturepack.exception.TexturePackParseException --|> org.xml.sax.SAXException
org.andengine.entity.IEntity --|> org.andengine.engine.handler.IDrawHandler
org.andengine.entity.IEntity --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.entity.IEntity --|> org.andengine.util.IDisposable
org.andengine.entity.IEntityMatcher --|> org.andengine.util.IMatcher
org.andengine.entity.IEntityParameterCallable --|> org.andengine.util.call.ParameterCallable
org.andengine.entity.modifier.IEntityModifier --|> org.andengine.util.modifier.IModifier
org.andengine.entity.particle.emitter.IParticleEmitter --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.entity.particle.modifier.IParticleModifier --|> org.andengine.entity.particle.initializer.IParticleInitializer
org.andengine.entity.primitive.vbo.ILineVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.entity.primitive.vbo.IMeshVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.entity.primitive.vbo.IRectangleVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.entity.scene.background.IBackground --|> org.andengine.engine.handler.IDrawHandler
org.andengine.entity.scene.background.IBackground --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.entity.scene.background.modifier.IBackgroundModifier --|> org.andengine.util.modifier.IModifier
org.andengine.entity.scene.menu.item.IMenuItem --|> org.andengine.entity.shape.IAreaShape
org.andengine.entity.shape.IAreaShape --|> org.andengine.entity.shape.IShape
org.andengine.entity.shape.IShape --|> org.andengine.entity.IEntity
org.andengine.entity.shape.IShape --|> org.andengine.entity.scene.ITouchArea
org.andengine.entity.sprite.batch.vbo.ISpriteBatchVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.entity.sprite.vbo.IDiamondSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject
org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.entity.sprite.vbo.ITiledSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject
org.andengine.entity.sprite.vbo.IUncoloredSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject
org.andengine.entity.sprite.vbo.IUniformColorSpriteVertexBufferObject --|> org.andengine.entity.sprite.vbo.ISpriteVertexBufferObject
org.andengine.entity.text.vbo.ITextVertexBufferObject --|> org.andengine.opengl.vbo.IVertexBufferObject
org.andengine.input.touch.controller.ITouchController --|> org.andengine.engine.handler.IUpdateHandler
org.andengine.opengl.texture.atlas.ITextureAtlas --|> org.andengine.opengl.texture.ITexture
org.andengine.opengl.texture.atlas.bitmap.source.IBitmapTextureAtlasSource --|> org.andengine.opengl.texture.atlas.source.ITextureAtlasSource
org.andengine.opengl.texture.atlas.buildable.IBuildableTextureAtlas --|> org.andengine.opengl.texture.atlas.ITextureAtlas
org.andengine.opengl.texture.region.ITiledTextureRegion --|> org.andengine.opengl.texture.region.ITextureRegion
org.andengine.opengl.vbo.IVertexBufferObject --|> org.andengine.util.IDisposable
org.andengine.util.adt.bounds.IFloatBounds --|> org.andengine.util.adt.bounds.IBounds
org.andengine.util.adt.bounds.IIntBounds --|> org.andengine.util.adt.bounds.IBounds
org.andengine.util.adt.list.ISortedList --|> org.andengine.util.adt.list.IList
org.andengine.util.adt.list.IUniqueList --|> org.andengine.util.adt.list.IList
org.andengine.util.adt.queue.IQueue --|> org.andengine.util.adt.list.IList
org.andengine.util.adt.queue.ISortedQueue --|> org.andengine.util.adt.list.ISortedList
org.andengine.util.adt.queue.ISortedQueue --|> org.andengine.util.adt.queue.IQueue
org.andengine.util.adt.queue.IUniqueQueue --|> org.andengine.util.adt.list.ISortedList
org.andengine.util.adt.queue.IUniqueQueue --|> org.andengine.util.adt.queue.IQueue
@enduml